### 用户:
项目背景 我正在开发一个 Windows 桌面应用「CardCraft」,核心目标是: - 用户输入 Markdown 文本 - 自动渲染成小红书风格的精美卡片 - 智能分页(3:4 比例,1080×1440px) - 批量导出高质量图片   # 技术栈 - 框架:PySide6 (Qt for Python) - 渲染:QWebEngineView (基于 Chromium) - Markdown解析:python-markdown + 扩展 - 样式:HTML + CSS (小红书风格) - 分页:JavaScript (在 WebEngine 中执行)   # 核心架构设计 ┌─────────────────────────────────────────┐ │           主窗口 (MainWindow)           │ ├─────────────┬──────────────┬────────────┤ │  编辑器组件  │   预览组件    │  工具栏   │ │ (QTextEdit) │(QWebEngineView)│ (QToolBar)│ └─────────────┴──────────────┴────────────┘ ↓ ┌──────────────┐ │ Markdown解析  │ └──────────────┘ ↓ ┌──────────────┐ │  HTML生成    │ └──────────────┘ ↓ ┌──────────────┐ │  智能分页    │ └──────────────┘ ↓ ┌──────────────┐ │  样式渲染    │ └──────────────┘ ↓ ┌──────────────┐ │  图片导出    │ └──────────────┘   # 项目结构
cardcraft/ ├── �� README.md                    # 项目说明文档 ├── �� requirements.txt             # Python依赖 ├── �� main.py                      # 程序入口 ├── �� build.py                      # 打包脚本 ├── �� create_icon.py                # 图标生成脚本 ├── �� version_info.txt              # Windows版本信息 ├── �� LICENSE                       # 开源协议(建议添加) ├── �� .gitignore                    # Git忽略文件(建议添加) │ ├── �� src/                          # 源代码目录 │   ├── �� ui/                       # UI组件 │   │   ├── �� **init**.py │   │   ├── �� main_window.py       # 主窗口(工具栏、布局) │   │   ├── �� editor_widget.py     # Markdown编辑器 │   │   └── �� preview_widget.py    # 预览组件 │   │ │   ├── �� core/                     # 核心功能 │   │   ├── �� **init**.py │   │   ├── �� markdown_processor.py # Markdown解析器 │   │   └── �� html_generator.py    # HTML生成器 │   │ │   └── �� utils/                    # 工具模块 │       ├── �� **init**.py │       ├── �� paginator.py          # 智能分页器 │       ├── �� exporter.py           # 图片导出器 │       └── �� style_manager.py      # 样式管理器 │ ├── �� resources/                    # 资源文件 │   ├── �� icons/                    # 应用图标 │   │   ├── �� app.ico              # Windows图标 │   │   └── �� icon_*.png           # 各尺寸PNG图标 │   ├── �� styles/                   # 样式文件(预留) │   └── �� templates/                # 模板文件(预留) │ ├── �� build/                        # 构建临时文件(自动生成) ├── �� dist/                         # 打包输出目录(自动生成) └── �� tests/                        # 测试文件(建议添加)     ├── �� **init**.py     ├── �� test_paginator.py     └── �� test_markdown.py核心功能需求   ## 1. 智能分页算法 - 每页固定尺寸:1080×1440px (3:4比例) - 分页原则:   * 段落完整性:不在段落中间分页   * 标题关联:标题与其后续内容保持同页   * 列表连续:列表项尽量不分离   * 代码完整:代码块不跨页   * 视觉平衡:避免页面过空或过满   ## 2. 样式系统 - 预设主题:小红书、Instagram、微信、知乎等 - 样式要素:   * 字体:中文用苹方/微软雅黑,西文用 Helvetica   * 颜色:主色 #FF2442,文字 #333333   * 间距:段落间距 20px,行高 1.8   * 特效:卡片阴影、圆角、渐变背景   ## 3. 渲染流程 ```python # 伪代码示例 markdown_text → parse_markdown() → generate_html() → apply_styles() → paginate() → render_preview() → export_images() 4. 导出功能   格式:PNG/JPEG 质量:支持 1x/2x/3x 分辨率 命名:自动编号,如 card_01.png, card_02.png 批量:一次导出所有分页   代码规范   使用类型注解 (typing) 遵循 PEP 8 中文注释说明关键逻辑 错误处理要完善   性能要求   实时预览延迟 < 300ms 支持 10000 字的文档 导出速度:每张卡片 < 1秒   问题描述 我发现当前问题是这样的,就是,markdown解析似乎存在很多问题,并不规范,很多时候很多情况会出现各种bug,整体有没有优化的空间? 期望输出 修改问题的代码;若修改小则直接告诉我位置,我个人进行修改;若变动大,则给我这个文件的完整代码
exporter.py->text/plain-># ============================================
# src/utils/exporter.py
# ============================================
from PySide6.QtCore import QObject, Signal, QTimer, QEventLoop, QSize, Qt, QPoint, QRect
from PySide6.QtGui import QImage, QPainter, QFont, QColor, QPageSize, QRegion
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtPrintSupport import QPrinter
from PySide6.QtWidgets import QWidget
from pathlib import Path
from typing import List, Optional
import json
import time

class ImageExporter(QObject):
    """图片导出器"""
    
    # 信号
    progress = Signal(int, int)  # 当前进度，总数
    finished = Signal(bool, str)  # 是否成功，消息
    page_exported = Signal(int, str)  # 页码，文件路径
    
    def __init__(self, web_view: QWebEngineView):
        super().__init__()
        self.web_view = web_view
        self.pages_to_export = []
        self.current_export_index = 0
        self.output_folder = ""
        self.html_generator = None
        self.export_format = "PNG"
        self.quality = 100
        self._is_exporting = False
        
    def export_pages(self, pages: List[str], output_folder: str, html_generator, 
                     format: str = "PNG", quality: int = 100) -> None:
        """
        导出多个页面为图片
        
        Args:
            pages: HTML页面内容列表
            output_folder: 输出文件夹路径
            html_generator: HTML生成器实例
            format: 图片格式 (PNG/JPEG)
            quality: 图片质量 (1-100)
        """
        self.pages_to_export = pages
        self.output_folder = Path(output_folder)
        self.current_export_index = 0
        self.html_generator = html_generator
        self.export_format = format
        self.quality = quality
        self._is_exporting = True
        
        # 确保输出文件夹存在
        self.output_folder.mkdir(parents=True, exist_ok=True)
        
        # 确保WebView是固定尺寸
        self.web_view.setFixedSize(1080, 1440)
        self.web_view.setZoomFactor(1.0)  # 重置缩放
        
        # 开始导出第一页
        self._export_next_page()
    
    def _export_next_page(self):
        """导出下一页"""
        if not self._is_exporting:
            return
            
        if self.current_export_index >= len(self.pages_to_export):
            # 导出完成
            self._is_exporting = False
            self.finished.emit(True, f"成功导出 {len(self.pages_to_export)} 张图片")
            return
        
        # 发送进度信号
        self.progress.emit(self.current_export_index + 1, len(self.pages_to_export))
        
        # 获取当前页内容
        page_content = self.pages_to_export[self.current_export_index]
        page_num = self.current_export_index + 1
        
        # 生成完整HTML（包含页码信息）
        full_html = self.html_generator.generate(
            page_content, 
            page_num=page_num, 
            total_pages=len(self.pages_to_export)
        )
        
        # 加载HTML到WebView
        self.web_view.setHtml(full_html, "file:///")
        
        # 等待页面加载完成后导出
        QTimer.singleShot(1500, lambda: self._capture_page(page_num))
    
    def _capture_page(self, page_num: int):
        """捕获当前页面为图片"""
        if not self._is_exporting:
            return
            
        # 构建输出文件名
        extension = self.export_format.lower()
        filename = f"card_{page_num:02d}.{extension}"
        output_path = self.output_folder / filename
        
        # 使用精确的捕获方法
        self._capture_fixed_size(output_path, page_num)
    
    def _capture_fixed_size(self, output_path: Path, page_num: int):
        """捕获固定尺寸的页面"""
        try:
            # 从html_generator获取当前尺寸
            target_width = self.html_generator.page_width
            target_height = self.html_generator.page_height
            
            # 创建目标图片
            image = QImage(target_width, target_height, QImage.Format_ARGB32)
            image.fill(Qt.white)
            
            # 创建painter
            painter = QPainter(image)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
            painter.setRenderHint(QPainter.RenderHint.TextAntialiasing, True)
            painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)
            
            # 确保WebView是正确的尺寸
            self.web_view.resize(target_width, target_height)
            
            # 渲染WebView到图片
            # 使用固定的源矩形来确保只捕获卡片区域
            source_rect = QRect(0, 0, target_width, target_height)
            target_rect = QRect(0, 0, target_width, target_height)
            
            # 渲染WebView
            if isinstance(self.web_view, QWidget):
                self.web_view.render(
                    painter,
                    QPoint(0, 0),
                    QRegion(source_rect),
                    QWidget.RenderFlag.DrawWindowBackground | QWidget.RenderFlag.DrawChildren
                )
            
            # 可选：添加导出时间水印
            self._add_export_watermark(painter, page_num)
            
            painter.end()
            
            # 保存图片
            success = image.save(str(output_path), self.export_format, self.quality)
            
            if success:
                self.page_exported.emit(page_num, str(output_path))
                # 继续导出下一页
                self.current_export_index += 1
                QTimer.singleShot(100, self._export_next_page)
            else:
                self._is_exporting = False
                self.finished.emit(False, f"保存图片失败: {output_path}")
                
        except Exception as e:
            self._is_exporting = False
            self.finished.emit(False, f"导出页面 {page_num} 时出错: {str(e)}")
    
    def _add_export_watermark(self, painter: QPainter, page_num: int):
        """添加导出水印（可选）"""
        # 设置水印字体和颜色
        font = QFont("Arial", 9)
        painter.setFont(font)
        painter.setPen(QColor(200, 200, 200, 80))
        
        # 在右下角添加生成时间（非常淡的水印）
        timestamp = time.strftime("%Y%m%d")
        painter.drawText(
            1000, 1420,
            f"{timestamp}"
        )
    
    def export_as_pdf(self, pages: List[str], output_file: str, html_generator):
        """
        导出为PDF文件（所有页面合并为一个PDF）
        
        Args:
            pages: HTML页面内容列表
            output_file: 输出PDF文件路径
            html_generator: HTML生成器实例
        """
        try:
            # 创建PDF打印机
            printer = QPrinter(QPrinter.PrinterMode.HighResolution)
            printer.setOutputFormat(QPrinter.OutputFormat.PdfFormat)
            printer.setOutputFileName(output_file)
            
            # 设置页面大小为小红书卡片比例
            # 注意：PDF使用点(point)作为单位，1点 = 1/72英寸
            # 1080px × 1440px 在 96 DPI 下约等于 810pt × 1080pt
            page_size = QPageSize(QSize(810, 1080), QPageSize.Unit.Point)
            printer.setPageSize(page_size)
            printer.setPageMargins(0, 0, 0, 0, QPrinter.Unit.Millimeter)
            
            # 合并所有页面内容
            combined_html = self._combine_pages_for_pdf(pages, html_generator)
            
            # 加载合并后的HTML
            self.web_view.setHtml(combined_html, "file:///")
            
            # 等待加载完成后打印
            loop = QEventLoop()
            
            def on_load_finished():
                self.web_view.page().print(printer, lambda success: loop.quit())
            
            QTimer.singleShot(1000, on_load_finished)
            loop.exec()
            
            self.finished.emit(True, f"PDF导出成功: {output_file}")
            
        except Exception as e:
            self.finished.emit(False, f"PDF导出失败: {str(e)}")
    
    def _combine_pages_for_pdf(self, pages: List[str], html_generator) -> str:
        """合并多个页面为PDF格式"""
        combined_content = ""
        
        for i, page in enumerate(pages, 1):
            if i > 1:
                # 添加分页符
                combined_content += '<div style="page-break-before: always;"></div>'
            
            # 添加页面内容，包装在固定尺寸的容器中
            combined_content += f'''
            <div style="width: 1080px; height: 1440px; position: relative; overflow: hidden;">
                {page}
            </div>
            '''
        
        # 生成完整HTML
        return html_generator.generate(combined_content)
    
    def cancel_export(self):
        """取消导出"""
        self._is_exporting = False
        self.pages_to_export = []
        self.finished.emit(False, "导出已取消") paginator.py->text/plain-># ============================================
# src/utils/paginator.py
# ============================================
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass
from bs4 import BeautifulSoup, NavigableString, Tag, Comment
import re

@dataclass
class PageElement:
    """页面元素"""
    type: str  # 'heading', 'paragraph', 'list', 'code', 'blockquote', 'table', 'hr', 'text', 'pagebreak'
    content: str  # HTML内容
    text: str  # 纯文本内容（用于计算高度）
    level: int = 0  # 标题级别或嵌套深度
    height: int = 0  # 估算高度（像素）
    can_break: bool = True  # 是否可以在此处分页
    is_forced_break: bool = False  # 是否是强制分页（用于标记用户添加的分页符）
    
class SmartPaginator:
    """智能分页器 - 支持多尺寸"""
    
    # 元素高度估算（像素）- 调整为更准确的值
    ELEMENT_HEIGHTS = {
        'h1': 90,        # 大标题 + 底部边框
        'h2': 70,        # 二级标题
        'h3': 60,        # 三级标题
        'h4': 50,        # 四级标题
        'h5': 45,        # 五级标题
        'h6': 40,        # 六级标题
        'p_base': 25,    # 段落基础高度
        'p_line': 28,    # 段落每行高度（考虑行高1.8）
        'li': 35,        # 列表项
        'code_block': 40,  # 代码块基础高度
        'code_line': 24,   # 代码每行高度
        'blockquote': 60,  # 引用块基础高度
        'blockquote_line': 28,  # 引用每行高度
        'table_header': 45,  # 表格头
        'table_row': 40,     # 表格行
        'hr': 35,           # 分隔线
        'margin_bottom': 20,  # 元素底部间距
    }
    
    # 页面尺寸配置
    PAGE_SIZES = {
        "small": {
            "width": 720,
            "height": 960,
            "padding_top": 35,
            "padding_bottom": 50,
            "padding_sides": 30
        },
        "medium": {
            "width": 1080,
            "height": 1440,
            "padding_top": 45,
            "padding_bottom": 70,
            "padding_sides": 40
        },
        "large": {
            "width": 1440,
            "height": 1920,
            "padding_top": 55,
            "padding_bottom": 90,
            "padding_sides": 50
        }
    }
    
    # 分页策略参数
    MIN_ORPHAN_LINES = 2  # 孤行控制：段落末尾最少保留行数
    MIN_WIDOW_LINES = 2   # 寡行控制：段落开头最少保留行数
    HEADING_KEEP_WITH = 150  # 标题后至少保留的内容高度
    
    # 字符宽度估算（像素）
    CHAR_WIDTH = 16  # 中文字符平均宽度
    CHAR_WIDTH_EN = 9  # 英文字符平均宽度
    
    def __init__(self, page_size: str = "medium"):
        """
        初始化分页器
        
        Args:
            page_size: 页面尺寸 ("small", "medium", "large")
        """
        self.elements: List[PageElement] = []
        self.set_page_size(page_size)
        self.forced_break_pages = set()  # 记录哪些页面是通过分页符创建的
        
    def set_page_size(self, size: str):
        """设置页面尺寸"""
        if size not in self.PAGE_SIZES:
            size = "medium"
        
        config = self.PAGE_SIZES[size]
        self.page_size_name = size
        self.page_width = config["width"]
        self.page_height = config["height"]
        self.padding_top = config["padding_top"]
        self.padding_bottom = config["padding_bottom"]
        self.padding_sides = config["padding_sides"]
        
        # 计算内容区域
        self.content_width = self.page_width - (self.padding_sides * 2)
        self.content_height = self.page_height - self.padding_top - self.padding_bottom
        
        # 根据尺寸调整分页策略
        if size == "small":
            self.HEADING_KEEP_WITH = 100  # 小尺寸页面，标题后保留空间可以更少
        elif size == "large":
            self.HEADING_KEEP_WITH = 200  # 大尺寸页面，标题后保留更多空间
        else:
            self.HEADING_KEEP_WITH = 150
    
    def get_page_info(self) -> Dict:
        """获取当前页面配置信息"""
        return {
            "size_name": self.page_size_name,
            "width": self.page_width,
            "height": self.page_height,
            "content_width": self.content_width,
            "content_height": self.content_height,
            "padding": {
                "top": self.padding_top,
                "bottom": self.padding_bottom,
                "sides": self.padding_sides
            }
        }
    
    def paginate(self, html_content: str) -> List[str]:
        """
        核心分页方法
        
        Args:
            html_content: HTML内容
            
        Returns:
            分页后的HTML内容列表
        """
        # 重置强制分页记录
        self.forced_break_pages = set()
        
        # 1. 解析HTML为元素列表
        elements = self.parse_html_to_elements(html_content)
        
        if not elements:
            return [html_content] if html_content else []
        
        # 2. 执行分页
        pages = []
        current_page_elements = []
        current_height = 0
        consecutive_breaks = 0  # 追踪连续的分页符数量
        
        i = 0
        while i < len(elements):
            element = elements[i]
            
            # 处理强制分页标记
            if element.type == 'pagebreak':
                consecutive_breaks += 1
                
                # 保存当前页（如果有内容）
                if current_page_elements:
                    pages.append(self._elements_to_html(current_page_elements))
                    self.forced_break_pages.add(len(pages) - 1)  # 记录这是强制分页
                    current_page_elements = []
                    current_height = 0
                elif consecutive_breaks > 1:
                    # 如果是连续的分页符，创建空页
                    pages.append("")
                    self.forced_break_pages.add(len(pages) - 1)  # 记录这是强制分页创建的空页
                
                i += 1
                continue
            
            # 非分页符元素，重置连续分页符计数
            consecutive_breaks = 0
            
            # 检查是否需要分页
            element_height = element.height
            
            # 特殊处理：标题元素
            if element.type == 'heading':
                # 检查标题后是否有足够空间放置内容
                if current_height + element_height + self.HEADING_KEEP_WITH > self.content_height:
                    # 需要分页，标题放到下一页
                    if current_page_elements:
                        pages.append(self._elements_to_html(current_page_elements))
                        current_page_elements = []
                        current_height = 0
            
            # 检查当前元素是否超出页面高度
            if current_height + element_height > self.content_height:
                # 检查是否可以分割元素
                if element.type == 'paragraph' and element_height > self.content_height * 0.3:
                    # 长段落可以尝试分割
                    split_result = self._try_split_paragraph(element, self.content_height - current_height)
                    if split_result:
                        first_part, second_part = split_result
                        if first_part:
                            current_page_elements.append(first_part)
                        pages.append(self._elements_to_html(current_page_elements))
                        current_page_elements = [second_part] if second_part else []
                        current_height = second_part.height if second_part else 0
                    else:
                        # 无法分割，整个元素放到下一页
                        if current_page_elements:
                            pages.append(self._elements_to_html(current_page_elements))
                        current_page_elements = [element]
                        current_height = element_height
                else:
                    # 不可分割的元素或不需要分割，放到下一页
                    if current_page_elements:
                        pages.append(self._elements_to_html(current_page_elements))
                    current_page_elements = [element]
                    current_height = element_height
            else:
                # 当前元素可以放入当前页
                current_page_elements.append(element)
                current_height += element_height
            
            i += 1
        
        # 3. 保存最后一页
        if current_page_elements:
            pages.append(self._elements_to_html(current_page_elements))
        
        # 4. 如果没有生成任何页面，返回原始内容
        if not pages:
            return [html_content]
        
        return pages
    
    def _elements_to_html(self, elements: List[PageElement]) -> str:
        """将元素列表转换回HTML字符串"""
        html_parts = []
        for element in elements:
            if element.type != 'pagebreak':  # 跳过分页标记
                html_parts.append(element.content)
        return '\n'.join(html_parts)
    
    def _try_split_paragraph(self, element: PageElement, available_height: int) -> Optional[Tuple[PageElement, PageElement]]:
        """
        尝试分割段落
        
        Args:
            element: 要分割的段落元素
            available_height: 当前页剩余高度
            
        Returns:
            分割后的两个元素，如果无法分割则返回None
        """
        # 简单实现：暂不分割段落，保持段落完整性
        # 未来可以实现更复杂的分割逻辑
        return None
    
    def _calculate_text_height(self, text: str) -> int:
        """计算纯文本高度"""
        if not text:
            return 0
        
        # 估算文本行数
        chars_per_line = self.content_width // self.CHAR_WIDTH
        total_chars = len(text)
        estimated_lines = max(1, (total_chars + chars_per_line - 1) // chars_per_line)
        
        return self.ELEMENT_HEIGHTS['p_base'] + estimated_lines * self.ELEMENT_HEIGHTS['p_line']
    
    def _calculate_paragraph_height(self, text: str) -> int:
        """计算段落高度"""
        if not text:
            return self.ELEMENT_HEIGHTS['p_base']
        
        # 考虑中英文混合
        chinese_chars = len(re.findall(r'[\u4e00-\u9fff]', text))
        english_chars = len(text) - chinese_chars
        
        # 计算平均每行字符数
        avg_char_width = (chinese_chars * self.CHAR_WIDTH + english_chars * self.CHAR_WIDTH_EN) / max(1, len(text))
        chars_per_line = self.content_width / avg_char_width
        
        # 计算行数
        lines = max(1, int(len(text) / chars_per_line) + 1)
        
        return self.ELEMENT_HEIGHTS['p_base'] + lines * self.ELEMENT_HEIGHTS['p_line'] + self.ELEMENT_HEIGHTS['margin_bottom']
    
    def _calculate_blockquote_height(self, text: str) -> int:
        """计算引用块高度"""
        if not text:
            return self.ELEMENT_HEIGHTS['blockquote']
        
        # 引用块内容宽度更窄
        effective_width = self.content_width - 60  # 减去左边框和内边距
        chars_per_line = effective_width // self.CHAR_WIDTH
        lines = max(1, (len(text) + chars_per_line - 1) // chars_per_line)
        
        return self.ELEMENT_HEIGHTS['blockquote'] + lines * self.ELEMENT_HEIGHTS['blockquote_line'] + self.ELEMENT_HEIGHTS['margin_bottom']
    
    def parse_html_to_elements(self, html: str) -> List[PageElement]:
        """
        将HTML解析为页面元素列表，保持原始顺序
        改进版：使用深度优先遍历，确保所有分页标记都被识别
        """
        elements = []
        
        # 使用BeautifulSoup解析HTML
        soup = BeautifulSoup(html, 'html.parser')
        
        # 深度优先遍历所有元素，扁平化处理
        elements = self._flatten_parse(soup)
        
        return elements
    
    def _flatten_parse(self, node) -> List[PageElement]:
        """
        扁平化解析所有节点，确保分页标记被正确识别
        这个方法会遍历整个DOM树，将所有内容扁平化为元素列表
        """
        elements = []
        
        # 如果是文本节点
        if isinstance(node, NavigableString):
            # 跳过注释和空白文本
            if not isinstance(node, Comment):
                text = str(node).strip()
                if text:
                    elements.append(PageElement(
                        type='text',
                        content=f'<p>{text}</p>',
                        text=text,
                        height=self._calculate_text_height(text),
                        can_break=True
                    ))
            return elements
        
        # 如果不是Tag，返回空列表
        if not isinstance(node, Tag):
            return elements
        
        # 首先检查是否是分页标记
        if self._is_pagebreak_marker(node):
            elements.append(PageElement(
                type='pagebreak',
                content='',
                text='',
                height=0,
                can_break=True,
                level=999,
                is_forced_break=True  # 标记为强制分页
            ))
            return elements
        
        # 处理具体的元素类型
        tag_name = node.name.lower()
        
        # 处理块级元素
        if tag_name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
            # 标题元素
            level = int(tag_name[1])
            text = node.get_text(strip=True)
            height = self.ELEMENT_HEIGHTS[tag_name] + self.ELEMENT_HEIGHTS['margin_bottom']
            
            elements.append(PageElement(
                type='heading',
                content=str(node),
                text=text,
                level=level,
                height=height,
                can_break=False
            ))
            
        elif tag_name == 'p':
            # 段落元素 - 需要检查内部是否有分页标记
            has_pagebreak = False
            sub_elements = []
            
            # 检查段落内部的所有子节点
            for child in node.children:
                if isinstance(child, Tag) and self._is_pagebreak_marker(child):
                    has_pagebreak = True
                    # 如果段落内有分页标记，需要特殊处理
                    # 先保存分页标记前的内容
                    text_before = ''.join(str(c) for c in list(node.children)[:list(node.children).index(child)])
                    if text_before.strip():
                        sub_elements.append(PageElement(
                            type='paragraph',
                            content=f'<p>{text_before}</p>',
                            text=text_before,
                            height=self._calculate_paragraph_height(text_before),
                            can_break=True
                        ))
                    # 添加分页标记
                    sub_elements.append(PageElement(
                        type='pagebreak',
                        content='',
                        text='',
                        height=0,
                        can_break=True,
                        level=999,
                        is_forced_break=True
                    ))
            
            if has_pagebreak:
                elements.extend(sub_elements)
            else:
                # 正常的段落
                text = node.get_text(strip=True)
                if text:
                    height = self._calculate_paragraph_height(text)
                    elements.append(PageElement(
                        type='paragraph',
                        content=str(node),
                        text=text,
                        height=height,
                        can_break=True
                    ))
                    
        elif tag_name in ['ul', 'ol']:
            # 列表元素
            items = node.find_all('li')
            text = node.get_text(strip=True)
            height = len(items) * self.ELEMENT_HEIGHTS['li'] + self.ELEMENT_HEIGHTS['margin_bottom']
            
            elements.append(PageElement(
                type='list',
                content=str(node),
                text=text,
                height=height,
                can_break=len(items) > 3
            ))
            
        elif tag_name == 'pre':
            # 代码块
            text = node.get_text()
            lines = text.count('\n') + 1
            height = (self.ELEMENT_HEIGHTS['code_block'] + 
                    lines * self.ELEMENT_HEIGHTS['code_line'] +
                    self.ELEMENT_HEIGHTS['margin_bottom'])
            
            elements.append(PageElement(
                type='code',
                content=str(node),
                text=text,
                height=height,
                can_break=lines > 10
            ))
            
        elif tag_name == 'blockquote':
            # 引用块
            text = node.get_text(strip=True)
            height = self._calculate_blockquote_height(text)
            
            elements.append(PageElement(
                type='blockquote',
                content=str(node),
                text=text,
                height=height,
                can_break=True
            ))
            
        elif tag_name == 'table':
            # 表格
            rows = node.find_all('tr')
            headers = node.find_all('th')
            text = node.get_text(strip=True)
            
            height = (len(headers) * self.ELEMENT_HEIGHTS['table_header'] +
                    (len(rows) - len(headers)) * self.ELEMENT_HEIGHTS['table_row'] +
                    self.ELEMENT_HEIGHTS['margin_bottom'])
            
            elements.append(PageElement(
                type='table',
                content=str(node),
                text=text,
                height=height,
                can_break=len(rows) > 5
            ))
            
        elif tag_name == 'hr':
            # 分隔线
            elements.append(PageElement(
                type='hr',
                content=str(node),
                text='',
                height=self.ELEMENT_HEIGHTS['hr'],
                can_break=True
            ))
            
        elif tag_name in ['div', 'section', 'article', 'main', 'aside', 'nav', 'header', 'footer']:
            # 容器元素 - 递归处理子元素
            for child in node.children:
                elements.extend(self._flatten_parse(child))
                
        else:
            # 其他元素 - 递归处理子元素
            # 但首先检查是否有实际内容
            text = node.get_text(strip=True)
            if text:
                # 检查子元素中是否有分页标记
                for child in node.children:
                    child_elements = self._flatten_parse(child)
                    if child_elements:
                        elements.extend(child_elements)
                
                # 如果没有子元素被解析，则将整个元素作为文本处理
                if not elements:
                    elements.append(PageElement(
                        type='text',
                        content=str(node),
                        text=text,
                        height=self._calculate_text_height(text),
                        can_break=True
                    ))
            else:
                # 递归处理子元素
                for child in node.children:
                    elements.extend(self._flatten_parse(child))
        
        return elements
    
    def _is_pagebreak_marker(self, element: Tag) -> bool:
        """
        检查元素是否是分页标记
        支持多种识别方式
        """
        if not isinstance(element, Tag):
            return False
            
        # 检查是否是带有特定class的div
        if element.name.lower() == 'div':
            classes = element.get('class', [])
            if isinstance(classes, str):
                classes = classes.split()
            
            # 检查class名
            if 'pagebreak-marker' in classes:
                return True
            
            # 检查data属性
            if element.get('data-pagebreak') == 'true':
                return True
        
        return False
    
    def optimize_pages(self, pages: List[str]) -> List[str]:
        """
        优化分页结果，合并过短的页面
        修改：保留通过分页符创建的页面，即使是空页
        """
        if len(pages) <= 1:
            return pages
        
        optimized = []
        i = 0
        
        # 根据页面尺寸调整合并阈值
        merge_threshold = 0.35 if self.page_size_name == "small" else 0.4
        
        while i < len(pages):
            current_page = pages[i]
            
            # 检查当前页是否是通过分页符创建的
            is_forced_page = i in self.forced_break_pages
            
            # 如果是强制分页创建的页面，直接保留（即使是空页）
            if is_forced_page:
                optimized.append(current_page)
                i += 1
                continue
            
            # 非强制分页的页面，进行常规优化
            # 过滤掉完全空的页面
            if not current_page or not current_page.strip():
                i += 1
                continue
            
            # 估算当前页面高度
            current_elements = self.parse_html_to_elements(current_page)
            current_height = sum(e.height for e in current_elements)
            
            # 如果页面过短，尝试与下一页合并（但不合并强制分页的页面）
            if current_height < self.content_height * merge_threshold and i < len(pages) - 1:
                next_page_index = i + 1
                # 检查下一页是否是强制分页
                if next_page_index not in self.forced_break_pages:
                    next_page = pages[next_page_index]
                    if next_page and next_page.strip():  # 确保下一页有内容
                        next_elements = self.parse_html_to_elements(next_page)
                        next_height = sum(e.height for e in next_elements)
                        
                        # 如果合并后不超过最大高度，则合并
                        if current_height + next_height <= self.content_height:
                            optimized.append(current_page + next_page)
                            i += 2  # 跳过下一页
                            continue
            
            optimized.append(current_page)
            i += 1
        
        # 如果优化后没有页面，至少返回一个页面
        return optimized if optimized else ['']
    
    def debug_pagination(self, html_content: str) -> List[dict]:
        """调试分页，返回详细信息"""
        elements = self.parse_html_to_elements(html_content)
        pages_info = []
        
        pages = self.paginate(html_content)
        for i, page in enumerate(pages, 1):
            page_elements = self.parse_html_to_elements(page)
            total_height = sum(e.height for e in page_elements)
            
            pages_info.append({
                'page_num': i,
                'page_size': self.page_size_name,
                'content_dimensions': f"{self.content_width}×{self.content_height}px",
                'elements_count': len(page_elements),
                'total_height': total_height,
                'max_height': self.content_height,
                'fill_rate': f"{(total_height / self.content_height * 100):.1f}%",
                'is_forced_break': (i-1) in self.forced_break_pages,  # 标记是否是强制分页
                'elements': [
                    {
                        'type': e.type,
                        'height': e.height,
                        'text_preview': e.text[:50] + '...' if len(e.text) > 50 else e.text
                    }
                    for e in page_elements
                ]
            })
        
        return pages_info style_manager.py->text/plain-># ============================================
# src/utils/style_manager.py
# ============================================
from typing import Dict, Any, Tuple
from dataclasses import dataclass
import colorsys

@dataclass
class ThemeConfig:
    """主题配置"""
    name: str
    primary_color: str
    secondary_color: str
    text_color: str
    background: str
    font_family: str
    heading_font: str
    code_font: str
    accent_color: str = ""  # 强调色
    link_color: str = ""    # 链接色
    
class StyleManager:
    """样式管理器 - 扩展版"""
    
    # 预设主题 - 12种风格
    THEMES = {
        # 社交媒体风格
        "xiaohongshu": ThemeConfig(
            name="小红书经典",
            primary_color="#FF2442",
            secondary_color="#FF6B6B",
            text_color="#2c3e50",
            background="linear-gradient(135deg, #ffeef8 0%, #ffe0f0 100%)",
            font_family='-apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"JetBrains Mono", "Cascadia Code", "Consolas", monospace',
            accent_color="#FFB6C1",
            link_color="#FF69B4"
        ),
        
        "instagram": ThemeConfig(
            name="Instagram渐变",
            primary_color="#E4405F",
            secondary_color="#BC2A8D",
            text_color="#262626",
            background="linear-gradient(45deg, #F9ED69 0%, #EE2A7B 50%, #6228D7 100%)",
            font_family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
            heading_font='"Segoe UI", Roboto, sans-serif',
            code_font='"Monaco", "Courier New", monospace',
            accent_color="#FCAF45",
            link_color="#833AB4"
        ),
        
        "wechat": ThemeConfig(
            name="微信简约",
            primary_color="#07C160",
            secondary_color="#4CAF50",
            text_color="#353535",
            background="linear-gradient(180deg, #F7F7F7 0%, #FFFFFF 100%)",
            font_family='"PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Microsoft YaHei", sans-serif',
            code_font='"SF Mono", "Monaco", "Inconsolata", monospace',
            accent_color="#95EC69",
            link_color="#576B95"
        ),
        
        "douyin": ThemeConfig(
            name="抖音酷黑",
            primary_color="#FE2C55",
            secondary_color="#25F4EE",
            text_color="#FFFFFF",
            background="linear-gradient(135deg, #000000 0%, #161823 100%)",
            font_family='"PingFang SC", "Helvetica Neue", Arial, sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"Fira Code", "Source Code Pro", monospace',
            accent_color="#00F2EA",
            link_color="#FE2C55"
        ),
        
        # 知识平台风格
        "zhihu": ThemeConfig(
            name="知乎蓝",
            primary_color="#0084FF",
            secondary_color="#1890FF",
            text_color="#1A1A1A",
            background="linear-gradient(180deg, #FFFFFF 0%, #F6F6F6 100%)",
            font_family='"PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"Source Code Pro", "Consolas", monospace',
            accent_color="#5BBCFF",
            link_color="#175199"
        ),
        
        "notion": ThemeConfig(
            name="Notion极简",
            primary_color="#000000",
            secondary_color="#2F3437",
            text_color="#37352F",
            background="linear-gradient(180deg, #FFFFFF 0%, #FAFAFA 100%)",
            font_family='"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            heading_font='"Inter", -apple-system, sans-serif',
            code_font='"SFMono-Regular", "Consolas", "Liberation Mono", monospace',
            accent_color="#EB5757",
            link_color="#0070F3"
        ),
        
        # 优雅风格
        "elegant_purple": ThemeConfig(
            name="优雅紫",
            primary_color="#6B46C1",
            secondary_color="#9333EA",
            text_color="#1F2937",
            background="linear-gradient(135deg, #F9FAFB 0%, #F3E8FF 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Playfair Display", "PingFang SC", serif',
            code_font='"JetBrains Mono", "Cascadia Code", monospace',
            accent_color="#A78BFA",
            link_color="#7C3AED"
        ),
        
        "ocean_blue": ThemeConfig(
            name="海洋蓝",
            primary_color="#0EA5E9",
            secondary_color="#06B6D4",
            text_color="#0F172A",
            background="linear-gradient(135deg, #F0F9FF 0%, #E0F2FE 50%, #BAE6FD 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Fira Code", "Consolas", monospace',
            accent_color="#38BDF8",
            link_color="#0284C7"
        ),
        
        "sunset_orange": ThemeConfig(
            name="日落橙",
            primary_color="#F97316",
            secondary_color="#FB923C",
            text_color="#1C1917",
            background="linear-gradient(135deg, #FFF7ED 0%, #FED7AA 50%, #FDBA74 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Source Code Pro", "Monaco", monospace',
            accent_color="#FCD34D",
            link_color="#EA580C"
        ),
        
        "forest_green": ThemeConfig(
            name="森林绿",
            primary_color="#059669",
            secondary_color="#10B981",
            text_color="#064E3B",
            background="linear-gradient(135deg, #ECFDF5 0%, #D1FAE5 50%, #A7F3D0 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"JetBrains Mono", monospace',
            accent_color="#34D399",
            link_color="#047857"
        ),
        
        # 深色主题
        "dark_mode": ThemeConfig(
            name="深色模式",
            primary_color="#00E0FF",
            secondary_color="#0096FF",
            text_color="#E0E6ED",
            background="linear-gradient(135deg, #0F0F1E 0%, #1A1A2E 50%, #16213E 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Fira Code", "JetBrains Mono", monospace',
            accent_color="#00F0FF",
            link_color="#00B8D4"
        ),
        
        "midnight": ThemeConfig(
            name="午夜紫",
            primary_color="#B794F4",
            secondary_color="#9F7AEA",
            text_color="#E9D8FD",
            background="linear-gradient(135deg, #1A202C 0%, #2D3748 50%, #4A5568 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Cascadia Code", "Fira Code", monospace',
            accent_color="#D6BCFA",
            link_color="#B794F4"
        )
    }
    
    def __init__(self, theme: str = "xiaohongshu"):
        self.current_theme = theme
        self.custom_styles = {}
        
    def get_theme(self, theme_name: str = None) -> ThemeConfig:
        """获取主题配置"""
        if theme_name is None:
            theme_name = self.current_theme
        return self.THEMES.get(theme_name, self.THEMES["xiaohongshu"])
    
    def get_theme_list(self) -> list:
        """获取所有主题列表"""
        return list(self.THEMES.keys())
    
    def get_theme_display_names(self) -> Dict[str, str]:
        """获取主题显示名称"""
        return {key: theme.name for key, theme in self.THEMES.items()}
    
    def set_theme(self, theme_name: str):
        """设置当前主题"""
        if theme_name in self.THEMES:
            self.current_theme = theme_name
    
    def hex_to_rgb(self, hex_color: str) -> Tuple[int, int, int]:
        """十六进制颜色转RGB"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    def rgb_to_hex(self, r: int, g: int, b: int) -> str:
        """RGB转十六进制"""
        return f"#{r:02x}{g:02x}{b:02x}"
    
    def lighten_color(self, hex_color: str, amount: float) -> str:
        """使颜色变浅（amount: 0-1）"""
        r, g, b = self.hex_to_rgb(hex_color)
        # 转换为HSL
        h, l, s = colorsys.rgb_to_hls(r/255, g/255, b/255)
        # 增加亮度
        l = min(1.0, l + (1 - l) * amount)
        # 转回RGB
        r, g, b = colorsys.hls_to_rgb(h, l, s)
        return self.rgb_to_hex(int(r*255), int(g*255), int(b*255))
    
    def darken_color(self, hex_color: str, amount: float) -> str:
        """使颜色变深（amount: 0-1）"""
        r, g, b = self.hex_to_rgb(hex_color)
        # 转换为HSL
        h, l, s = colorsys.rgb_to_hls(r/255, g/255, b/255)
        # 降低亮度
        l = max(0.0, l * (1 - amount))
        # 转回RGB
        r, g, b = colorsys.hls_to_rgb(h, l, s)
        return self.rgb_to_hex(int(r*255), int(g*255), int(b*255))
    
    def add_alpha(self, hex_color: str, alpha: float) -> str:
        """添加透明度（返回rgba格式）"""
        r, g, b = self.hex_to_rgb(hex_color)
        return f"rgba({r}, {g}, {b}, {alpha})"
    
    def generate_css(self, theme_name: str = None, font_size: int = 18) -> str:
        """生成主题CSS"""
        theme = self.get_theme(theme_name)
        
        # 生成派生颜色
        primary_light = self.lighten_color(theme.primary_color, 0.9)
        primary_dark = self.darken_color(theme.primary_color, 0.2)
        secondary_light = self.lighten_color(theme.secondary_color, 0.9)
        
        # 检查是否为深色主题
        is_dark = theme_name in ["dark_mode", "midnight", "douyin"]
        
        return f"""
        /* 主题: {theme.name} */
        :root {{
            --primary-color: {theme.primary_color};
            --secondary-color: {theme.secondary_color};
            --accent-color: {theme.accent_color or theme.secondary_color};
            --text-color: {theme.text_color};
            --link-color: {theme.link_color or theme.primary_color};
            --font-family: {theme.font_family};
            --heading-font: {theme.heading_font};
            --code-font: {theme.code_font};
            --primary-light: {primary_light};
            --primary-dark: {primary_dark};
            --secondary-light: {secondary_light};
            --base-font-size: {font_size}px;
        }}
        
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: var(--font-family);
            background: {theme.background};
            color: var(--text-color);
            font-size: var(--base-font-size);
            line-height: 1.85;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }}
        
        /* 标题样式 */
        h1, h2, h3, h4, h5, h6 {{
            font-family: var(--heading-font);
            color: var(--primary-color);
            font-weight: 700;
            letter-spacing: -0.02em;
        }}
        
        h1 {{
            font-size: calc(var(--base-font-size) + 16px);
            margin-bottom: 28px;
            padding-bottom: 16px;
            border-bottom: 3px solid {self.add_alpha(theme.primary_color, 0.2)};
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }}
        
        h2 {{
            font-size: calc(var(--base-font-size) + 10px);
            margin-top: 38px;
            margin-bottom: 22px;
            position: relative;
            padding-left: 20px;
        }}
        
        h2::before {{
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 24px;
            background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
            border-radius: 3px;
            box-shadow: 0 2px 8px {self.add_alpha(theme.primary_color, 0.3)};
        }}
        
        h3 {{
            font-size: calc(var(--base-font-size) + 5px);
            margin-top: 30px;
            margin-bottom: 18px;
            color: {theme.text_color if not is_dark else theme.secondary_color};
        }}
        
        /* 段落样式 */
        p {{
            margin-bottom: 22px;
            font-size: var(--base-font-size);
            color: var(--text-color);
            text-align: justify;
            line-height: 1.85;
        }}
        
        /* 强调样式 */
        strong {{
            color: var(--primary-color);
            font-weight: 600;
            background: linear-gradient(180deg, transparent 70%, {self.add_alpha(theme.primary_color, 0.2)} 70%);
            padding: 0 4px;
            border-radius: 2px;
        }}
        
        em {{
            font-style: italic;
            color: {self.darken_color(theme.text_color, 0.2) if not is_dark else self.lighten_color(theme.text_color, 0.2)};
        }}
        
        /* 列表样式 */
        ul, ol {{
            margin: 24px 0;
            padding-left: 38px;
        }}
        
        li {{
            margin-bottom: 16px;
            font-size: var(--base-font-size);
            color: var(--text-color);
            line-height: 1.85;
            position: relative;
        }}
        
        ul li::marker {{
            color: var(--primary-color);
            font-size: calc(var(--base-font-size) + 2px);
        }}
        
        ol li::marker {{
            color: var(--primary-color);
            font-weight: 600;
        }}
        
        /* 引用样式 */
        blockquote {{
            border-left: 4px solid var(--primary-color);
            margin: 28px 0;
            padding: 20px 28px;
            background: {self.add_alpha(theme.primary_color, 0.05) if not is_dark else self.add_alpha(theme.primary_color, 0.1)};
            border-radius: 10px;
            position: relative;
            box-shadow: 0 4px 15px {self.add_alpha(theme.primary_color, 0.1)};
        }}
        
        blockquote::before {{
            content: '"';
            position: absolute;
            top: -10px;
            left: 24px;
            font-size: 48px;
            color: {self.add_alpha(theme.primary_color, 0.3)};
            font-family: Georgia, serif;
            font-weight: bold;
        }}
        
        blockquote p {{
            color: {self.darken_color(theme.text_color, 0.1) if not is_dark else self.lighten_color(theme.text_color, 0.1)};
            font-style: italic;
            margin-bottom: 0;
            font-size: calc(var(--base-font-size) - 1px);
        }}
        
        /* 行内代码 */
        code {{
            background: {self.add_alpha(theme.primary_color, 0.1)};
            padding: 4px 10px;
            border-radius: 6px;
            font-family: var(--code-font);
            font-size: calc(var(--base-font-size) - 2px);
            color: {theme.primary_color if not is_dark else theme.accent_color};
            font-weight: 500;
            border: 1px solid {self.add_alpha(theme.primary_color, 0.2)};
        }}
        
        /* 代码块 */
        pre {{
            background: {('#1e1e1e' if not is_dark else '#0a0a0f')};
            color: #d4d4d4;
            padding: 26px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 28px 0;
            box-shadow: 0 8px 24px {self.add_alpha('#000000', 0.15)};
            position: relative;
            border: 1px solid {self.add_alpha(theme.primary_color, 0.2)};
        }}
        
        pre::before {{
            content: "CODE";
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 11px;
            color: {self.add_alpha(theme.text_color, 0.5)};
            font-weight: 600;
            letter-spacing: 1px;
            font-family: var(--font-family);
        }}
        
        pre code {{
            background: none;
            color: #d4d4d4;
            padding: 0;
            font-size: calc(var(--base-font-size) - 3px);
            line-height: 1.7;
            border: none;
        }}
        
        /* 表格样式 */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 28px 0;
            font-size: calc(var(--base-font-size) - 1px);
            box-shadow: 0 4px 15px {self.add_alpha(theme.primary_color, 0.08)};
            border-radius: 10px;
            overflow: hidden;
        }}
        
        th {{
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px 20px;
            text-align: left;
            font-weight: 600;
            font-size: calc(var(--base-font-size) - 1px);
            letter-spacing: 0.5px;
        }}
        
        td {{
            padding: 15px 20px;
            border-bottom: 1px solid {self.add_alpha(theme.text_color, 0.1)};
            color: var(--text-color);
        }}
        
        tr:nth-child(even) {{
            background: {self.add_alpha(theme.primary_color, 0.03)};
        }}
        
        tr:hover {{
            background: {self.add_alpha(theme.primary_color, 0.08)};
            transition: background 0.3s ease;
        }}
        
        tr:last-child td {{
            border-bottom: none;
        }}
        
        /* 分隔线 */
        hr {{
            border: none;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                {self.add_alpha(theme.primary_color, 0.3)} 20%, 
                {self.add_alpha(theme.primary_color, 0.3)} 80%, 
                transparent);
            margin: 38px 0;
            position: relative;
        }}
        
        hr::after {{
            content: "✦";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: {theme.background.split('(')[0] + '(180deg, #FFFFFF 0%, #FFFFFF 100%)' if 'gradient' in theme.background else '#FFFFFF'};
            color: var(--primary-color);
            padding: 0 10px;
            font-size: 20px;
        }}
        
        /* 链接样式 */
        a {{
            color: var(--link-color);
            text-decoration: none;
            border-bottom: 2px solid {self.add_alpha(theme.link_color or theme.primary_color, 0.3)};
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding-bottom: 1px;
            position: relative;
        }}
        
        a:hover {{
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
            background: {self.add_alpha(theme.primary_color, 0.08)};
            padding: 2px 6px;
            margin: -2px -6px;
            border-radius: 4px;
        }}
        
        /* 动画效果 */
        @keyframes fadeIn {{
            from {{
                opacity: 0;
                transform: translateY(10px);
            }}
            to {{
                opacity: 1;
                transform: translateY(0);
            }}
        }}
        
        .content > * {{
            animation: fadeIn 0.5s ease-out backwards;
        }}
        
        .content > *:nth-child(1) {{ animation-delay: 0.05s; }}
        .content > *:nth-child(2) {{ animation-delay: 0.1s; }}
        .content > *:nth-child(3) {{ animation-delay: 0.15s; }}
        .content > *:nth-child(4) {{ animation-delay: 0.2s; }}
        .content > *:nth-child(5) {{ animation-delay: 0.25s; }}
        
        /* 自定义滚动条 */
        ::-webkit-scrollbar {{
            width: 8px;
            height: 8px;
        }}
        
        ::-webkit-scrollbar-track {{
            background: {self.add_alpha(theme.text_color, 0.05)};
            border-radius: 4px;
        }}
        
        ::-webkit-scrollbar-thumb {{
            background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
            border-radius: 4px;
        }}
        
        ::-webkit-scrollbar-thumb:hover {{
            background: linear-gradient(180deg, var(--secondary-color), var(--primary-color));
        }}
        """
    
    def get_export_settings(self, theme_name: str = None) -> Dict[str, Any]:
        """获取导出设置"""
        theme = self.get_theme(theme_name)
        
        return {
            "theme_name": theme.name,
            "page_width": 1080,
            "page_height": 1440,
            "padding": {
                "top": 45,
                "bottom": 45,
                "left": 40,
                "right": 40
            },
            "font_size": 16,
            "line_height": 1.8,
            "paragraph_spacing": 20,
            "image_quality": 100,
            "format": "PNG",
            "colors": {
                "primary": theme.primary_color,
                "secondary": theme.secondary_color,
                "text": theme.text_color,
                "background": theme.background
            }
        }
    
    def apply_custom_styles(self, styles: Dict[str, str]):
        """应用自定义样式"""
        self.custom_styles.update(styles)
    
    def get_combined_css(self, theme_name: str = None, font_size: int = 18) -> str:
        """获取组合的CSS（主题 + 自定义）"""
        base_css = self.generate_css(theme_name, font_size)
        
        if self.custom_styles:
            custom_css = "\n/* 自定义样式 */\n"
            for selector, rules in self.custom_styles.items():
                custom_css += f"{selector} {{\n{rules}\n}}\n"
            return base_css + custom_css
        
        return base_css editor_widget.py->text/plain-># ============================================
# src/ui/editor_widget.py - Qt兼容版本（无警告）
# ============================================
from PySide6.QtWidgets import QTextEdit, QVBoxLayout, QWidget, QLabel, QFrame, QHBoxLayout
from PySide6.QtGui import QFont, QTextOption, QPalette, QColor, QSyntaxHighlighter, QTextCharFormat
from PySide6.QtCore import Signal, Qt, QRegularExpression

class MarkdownHighlighter(QSyntaxHighlighter):
    """Markdown 语法高亮器"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.highlighting_rules = []
        
        # 标题
        heading_format = QTextCharFormat()
        heading_format.setForeground(QColor(0, 255, 136))
        heading_format.setFontWeight(QFont.Bold)
        self.highlighting_rules.append((QRegularExpression(r'^#{1,6}\s.*'), heading_format))
        
        # 粗体
        bold_format = QTextCharFormat()
        bold_format.setForeground(QColor(255, 179, 71))
        bold_format.setFontWeight(QFont.Bold)
        self.highlighting_rules.append((QRegularExpression(r'\*\*[^\*]+\*\*'), bold_format))
        
        # 斜体
        italic_format = QTextCharFormat()
        italic_format.setForeground(QColor(255, 179, 71))
        italic_format.setFontItalic(True)
        self.highlighting_rules.append((QRegularExpression(r'\*[^\*]+\*'), italic_format))
        
        # 代码块
        code_format = QTextCharFormat()
        code_format.setForeground(QColor(139, 233, 253))
        code_format.setFontFamily("Cascadia Code, Consolas, monospace")
        self.highlighting_rules.append((QRegularExpression(r'`[^`]+`'), code_format))
        
        # 链接
        link_format = QTextCharFormat()
        link_format.setForeground(QColor(189, 147, 249))
        link_format.setFontUnderline(True)
        self.highlighting_rules.append((QRegularExpression(r'\[([^\]]+)\]\(([^\)]+)\)'), link_format))
        
        # 列表
        list_format = QTextCharFormat()
        list_format.setForeground(QColor(255, 121, 198))
        self.highlighting_rules.append((QRegularExpression(r'^\s*[\*\-\+]\s'), list_format))
        self.highlighting_rules.append((QRegularExpression(r'^\s*\d+\.\s'), list_format))
        
        # 引用
        quote_format = QTextCharFormat()
        quote_format.setForeground(QColor(98, 114, 164))
        quote_format.setFontItalic(True)
        self.highlighting_rules.append((QRegularExpression(r'^>\s.*'), quote_format))
        
    def highlightBlock(self, text):
        for pattern, format in self.highlighting_rules:
            iterator = pattern.globalMatch(text)
            while iterator.hasNext():
                match = iterator.next()
                self.setFormat(match.capturedStart(), match.capturedLength(), format)

class EditorWidget(QWidget):
    textChanged = Signal()
    scrollChanged = Signal(float)
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 编辑器容器
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: transparent;
                border: none;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(1, 1, 1, 1)
        container_layout.setSpacing(0)
        
        # 创建编辑器
        self.editor = QTextEdit()
        self.setup_editor()
        
        # 添加到容器
        container_layout.addWidget(self.editor)
        layout.addWidget(container)
        
    def setup_editor(self):
        """设置编辑器 - Qt兼容版本"""
        # 设置字体
        font = QFont("Cascadia Code, Consolas, Monaco, monospace", 13)
        font.setStyleHint(QFont.Monospace)
        self.editor.setFont(font)
        
        # 设置换行模式
        self.editor.setLineWrapMode(QTextEdit.WidgetWidth)
        self.editor.setWordWrapMode(QTextOption.WordWrap)
        
        # 设置tab宽度
        self.editor.setTabStopDistance(40)
        
        # 应用语法高亮
        self.highlighter = MarkdownHighlighter(self.editor.document())
        
        # 设置编辑器样式 - Qt兼容版本（移除不支持的CSS属性）
        self.editor.setStyleSheet("""
            QTextEdit {
                background: rgba(20, 20, 40, 0.6);
                border: none;
                border-radius: 20px;
                padding: 25px;
                color: rgba(255, 255, 255, 0.95);
                selection-background-color: rgba(0, 255, 136, 0.3);
                selection-color: white;
                font-size: 14px;
                line-height: 1.6;
            }
            
            QScrollBar:vertical {
                background: rgba(255, 255, 255, 0.03);
                width: 12px;
                border-radius: 6px;
                margin: 4px;
            }
            
            QScrollBar::handle:vertical {
                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 255, 255, 0.3),
                    stop: 1 rgba(255, 0, 255, 0.3));
                border-radius: 6px;
                min-height: 30px;
            }
            
            QScrollBar::handle:vertical:hover {
                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 255, 255, 0.5),
                    stop: 1 rgba(255, 0, 255, 0.5));
            }
            
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                height: 0px;
            }
            
            QScrollBar:horizontal {
                background: rgba(255, 255, 255, 0.03);
                height: 12px;
                border-radius: 6px;
                margin: 4px;
            }
            
            QScrollBar::handle:horizontal {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 255, 0.3),
                    stop: 1 rgba(255, 0, 255, 0.3));
                border-radius: 6px;
                min-width: 30px;
            }
            
            QScrollBar::handle:horizontal:hover {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 255, 0.5),
                    stop: 1 rgba(255, 0, 255, 0.5));
            }
            
            QScrollBar::add-line:horizontal,
            QScrollBar::sub-line:horizontal {
                width: 0px;
            }
        """)
        
        # 设置默认文本
        self.editor.setPlainText("""# 🌸 小红书笔记标题

## 今日分享

大家好呀～今天给大家分享一个超实用的 **Markdown 编辑器**！

### ✨ 主要功能

1. **实时预览** - 左边写，右边看
2. **智能分页** - 自动适配小红书卡片尺寸
3. **一键导出** - 批量生成精美图片

### 📝 使用方法

- 在左侧输入 Markdown 文本
- 右侧实时显示预览效果
- 点击导出按钮保存图片

> 💡 小贴士：支持所有常用的 Markdown 语法哦～

### 代码示例

```python
def hello():
    print("Hello, 小红书!")
    return "❤️"
```

### 表格示例

| 功能 | 描述 | 状态 |
|------|------|------|
| 编辑 | Markdown编辑器 | ✅ |
| 预览 | 实时渲染 | ✅ |
| 导出 | 图片生成 | ✅ |

---

喜欢的话记得 **点赞收藏** 哦～ ❤️

关注我，获取更多实用工具！""")
        
        # 连接信号
        self.editor.textChanged.connect(self.on_text_changed)
        self.editor.verticalScrollBar().valueChanged.connect(self.on_scroll)
        
    def on_text_changed(self):
        """处理文本变化"""
        self.textChanged.emit()
        
    def on_scroll(self):
        """处理滚动事件"""
        scrollbar = self.editor.verticalScrollBar()
        if scrollbar.maximum() > 0:
            percentage = scrollbar.value() / scrollbar.maximum()
            self.scrollChanged.emit(percentage)
            
    def get_text(self):
        """获取编辑器文本"""
        return self.editor.toPlainText()
    
    def set_text(self, text):
        """设置编辑器文本"""
        self.editor.setPlainText(text)
        
    def clear(self):
        """清空编辑器"""
        self.editor.clear()
        
    def setFocus(self):
        """设置焦点到编辑器"""
        self.editor.setFocus()
        
    def insertPlainText(self, text):
        """在光标位置插入文本"""
        self.editor.insertPlainText(text)
        
    def selectAll(self):
        """全选文本"""
        self.editor.selectAll()
        
    def copy(self):
        """复制选中文本"""
        self.editor.copy()
        
    def cut(self):
        """剪切选中文本"""
        self.editor.cut()
        
    def paste(self):
        """粘贴文本"""
        self.editor.paste()
        
    def undo(self):
        """撤销"""
        self.editor.undo()
        
    def redo(self):
        """重做"""
        self.editor.redo()
        
    def setReadOnly(self, readonly):
        """设置只读模式"""
        self.editor.setReadOnly(readonly)
        
    def zoomIn(self):
        """放大字体"""
        self.editor.zoomIn(1)
        
    def zoomOut(self):
        """缩小字体"""
        self.editor.zoomOut(1)
        
    def resetZoom(self):
        """重置字体大小"""
        font = QFont("Cascadia Code, Consolas, Monaco, monospace", 13)
        self.editor.setFont(font) main_window.py->text/plain-># ============================================
# src/ui/main_window.py - 增强版工具栏
# ============================================
from PySide6.QtWidgets import (QMainWindow, QHBoxLayout, QVBoxLayout, 
                               QWidget, QToolBar, QSplitter, QPushButton,
                               QFileDialog, QMessageBox, QStatusBar, QLabel,
                               QGraphicsDropShadowEffect, QComboBox, QFrame,
                               QToolButton, QMenu, QDialog, QTextEdit,
                               QDialogButtonBox, QSpinBox, QGridLayout, QLineEdit)
from PySide6.QtCore import Qt, QTimer, QPropertyAnimation, QEasingCurve, QRect, QSize
from PySide6.QtGui import QAction, QIcon, QColor, QLinearGradient, QPainter, QBrush, QKeySequence, QTextCursor
from src.ui.editor_widget import EditorWidget
from src.ui.preview_widget import PreviewWidget
from src.utils.style_manager import StyleManager
import re

class AuroraBackground(QWidget):
    """极光渐变背景组件"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.gradient_offset = 0
        self.animation_timer = QTimer()
        self.animation_timer.timeout.connect(self.update_gradient)
        self.animation_timer.start(50)  # 20fps动画
        
    def update_gradient(self):
        self.gradient_offset = (self.gradient_offset + 1) % 360
        self.update()
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 创建动态极光渐变
        gradient = QLinearGradient(0, 0, self.width(), self.height())
        
        # 基于时间偏移的动态颜色
        hue1 = (180 + self.gradient_offset) % 360
        hue2 = (280 + self.gradient_offset) % 360
        hue3 = (320 + self.gradient_offset) % 360
        
        color1 = QColor.fromHsv(hue1, 180, 60)
        color2 = QColor.fromHsv(hue2, 200, 80)
        color3 = QColor.fromHsv(hue3, 160, 70)
        
        gradient.setColorAt(0, color1)
        gradient.setColorAt(0.3, color2)
        gradient.setColorAt(0.6, QColor(25, 25, 60))
        gradient.setColorAt(1, color3)
        
        painter.fillRect(self.rect(), gradient)

class TableDialog(QDialog):
    """插入表格对话框"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("📊 插入表格")
        self.setFixedSize(300, 150)
        self.init_ui()
        
    def init_ui(self):
        layout = QGridLayout(self)
        
        # 行数
        layout.addWidget(QLabel("行数:"), 0, 0)
        self.rows_spin = QSpinBox()
        self.rows_spin.setRange(2, 20)
        self.rows_spin.setValue(3)
        layout.addWidget(self.rows_spin, 0, 1)
        
        # 列数
        layout.addWidget(QLabel("列数:"), 1, 0)
        self.cols_spin = QSpinBox()
        self.cols_spin.setRange(2, 10)
        self.cols_spin.setValue(3)
        layout.addWidget(self.cols_spin, 1, 1)
        
        # 按钮
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons, 2, 0, 1, 2)
        
        self.setStyleSheet("""
            QDialog {
                background: rgba(30, 30, 50, 0.95);
            }
            QLabel {
                color: white;
                font-size: 13px;
            }
            QSpinBox {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px;
                border-radius: 5px;
            }
            QPushButton {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px 15px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background: rgba(255, 255, 255, 0.15);
            }
        """)

class LinkDialog(QDialog):
    """插入链接对话框"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("🔗 插入链接")
        self.setFixedSize(400, 180)
        self.init_ui()
        
    def init_ui(self):
        layout = QGridLayout(self)
        
        # 链接文字
        layout.addWidget(QLabel("链接文字:"), 0, 0)
        self.text_edit = QLineEdit()
        self.text_edit.setPlaceholderText("输入显示的文字")
        layout.addWidget(self.text_edit, 0, 1)
        
        # 链接地址
        layout.addWidget(QLabel("链接地址:"), 1, 0)
        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("https://example.com")
        layout.addWidget(self.url_edit, 1, 1)
        
        # 按钮
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons, 2, 0, 1, 2)
        
        self.setStyleSheet("""
            QDialog {
                background: rgba(30, 30, 50, 0.95);
            }
            QLabel {
                color: white;
                font-size: 13px;
            }
            QLineEdit {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px;
                border-radius: 5px;
            }
            QPushButton {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px 15px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background: rgba(255, 255, 255, 0.15);
            }
        """)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # 先创建自动更新计时器
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_preview)
        self.update_timer.setInterval(300)  # 300ms延迟
        
        # 初始化样式管理器
        self.style_manager = StyleManager()
        
        # 然后初始化UI
        self.init_ui()
        self.setup_connections()
        
    def init_ui(self):
        """初始化UI"""
        self.setWindowTitle("✨ 小红书 Markdown 编辑器")
        self.setGeometry(100, 100, 1700, 950)
        self.setMinimumSize(1200, 700)
        
        # 创建主容器
        main_container = QWidget()
        self.setCentralWidget(main_container)
        
        # 创建极光背景
        self.aurora_bg = AuroraBackground(main_container)
        
        # 主布局
        main_layout = QVBoxLayout(main_container)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # 应用全局样式
        self.setStyleSheet(self.get_global_styles_qt_compatible())
        
        # 创建编辑器和预览组件
        self.editor = EditorWidget()
        self.preview = PreviewWidget()
        
        # 创建增强版工具栏
        toolbar_container = self.create_enhanced_toolbar()
        main_layout.addWidget(toolbar_container)
        
        # 创建内容区域
        content_area = QWidget()
        content_area.setObjectName("contentArea")
        content_layout = QHBoxLayout(content_area)
        content_layout.setContentsMargins(20, 20, 20, 20)
        content_layout.setSpacing(20)
        
        # 创建分割器
        splitter = QSplitter(Qt.Horizontal)
        splitter.setObjectName("mainSplitter")
        
        # 为组件添加玻璃容器
        editor_container = self.create_glass_container(self.editor, "📝 Markdown 编辑器")
        preview_container = self.create_glass_container(self.preview, "👀 实时预览")
        
        # 添加到分割器
        splitter.addWidget(editor_container)
        splitter.addWidget(preview_container)
        splitter.setSizes([850, 850])
        
        content_layout.addWidget(splitter)
        main_layout.addWidget(content_area, 1)
        
        # 创建底部状态栏
        self.create_status_bar()
        
        # 初始更新
        self.update_preview()
        self.update_char_count()
        
        # 确保背景在最底层
        self.aurora_bg.lower()
        
    def create_enhanced_toolbar(self):
        """创建增强版单行工具栏"""
        toolbar_container = QFrame()
        toolbar_container.setObjectName("toolbarContainer")
        toolbar_container.setFixedHeight(55)
        
        main_layout = QHBoxLayout(toolbar_container)
        main_layout.setContentsMargins(15, 8, 15, 8)
        main_layout.setSpacing(15)
        
        # 左侧：基础格式化按钮组
        format_group = QFrame()
        format_group.setObjectName("buttonGroup")
        format_layout = QHBoxLayout(format_group)
        format_layout.setContentsMargins(8, 3, 8, 3)
        format_layout.setSpacing(5)
        
        # 基础格式化按钮
        basic_buttons = [
            ("B", "加粗 (Ctrl+B)", self.insert_bold, True, False),
            ("I", "斜体 (Ctrl+I)", self.insert_italic, False, True),
            ("S", "删除线", self.insert_strikethrough, False, False),
            ("`", "行内代码", self.insert_inline_code, False, False),
            ("⟨⟩", "代码块", self.insert_code_block, False, False),
        ]
        
        for text, tooltip, callback, is_bold, is_italic in basic_buttons:
            btn = QToolButton()
            btn.setText(text)
            btn.setToolTip(tooltip)
            btn.clicked.connect(callback)
            btn.setFixedSize(35, 35)
            
            # 设置字体样式
            font = btn.font()
            if is_bold:
                font.setBold(True)
            if is_italic:
                font.setItalic(True)
            btn.setFont(font)
            
            btn.setStyleSheet(self.get_tool_button_style())
            format_layout.addWidget(btn)
        
        main_layout.addWidget(format_group)
        
        # 添加分隔线
        separator1 = self.create_separator()
        main_layout.addWidget(separator1)
        
        # 中间左：标题选择器
        heading_group = QFrame()
        heading_layout = QHBoxLayout(heading_group)
        heading_layout.setContentsMargins(0, 0, 0, 0)
        heading_layout.setSpacing(8)
        
        heading_label = QLabel("标题:")
        heading_label.setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 12px;")
        heading_layout.addWidget(heading_label)
        
        self.heading_selector = QComboBox()
        self.heading_selector.setFixedWidth(100)
        self.heading_selector.addItems([
            "正文",
            "H1 一级标题",
            "H2 二级标题", 
            "H3 三级标题",
            "H4 四级标题",
            "H5 五级标题",
            "H6 六级标题"
        ])
        self.heading_selector.setCurrentIndex(0)
        self.heading_selector.setStyleSheet(self.get_mini_combobox_style())
        heading_layout.addWidget(self.heading_selector)
        
        main_layout.addWidget(heading_group)
        
        # 中间右：列表和链接按钮组
        list_group = QFrame()
        list_group.setObjectName("buttonGroup")
        list_layout = QHBoxLayout(list_group)
        list_layout.setContentsMargins(8, 3, 8, 3)
        list_layout.setSpacing(5)
        
        # 列表和链接按钮
        list_buttons = [
            ("◉", "无序列表", self.insert_unordered_list),
            ("①", "有序列表", self.insert_ordered_list),
            ("🔗", "插入链接", self.insert_link),
            ("🖼", "插入图片", self.insert_image),
            ("📊", "插入表格", self.insert_table),
            (">", "引用", self.insert_quote),
            ("—", "分隔线", self.insert_divider),
        ]
        
        for text, tooltip, callback in list_buttons:
            btn = QToolButton()
            btn.setText(text)
            btn.setToolTip(tooltip)
            btn.clicked.connect(callback)
            btn.setFixedSize(35, 35)
            btn.setStyleSheet(self.get_tool_button_style())
            list_layout.addWidget(btn)
        
        main_layout.addWidget(list_group)
        
        # 添加分隔线
        separator2 = self.create_separator()
        main_layout.addWidget(separator2)
        
        # 操作按钮组
        action_group = QFrame()
        action_group.setObjectName("buttonGroup")
        action_layout = QHBoxLayout(action_group)
        action_layout.setContentsMargins(8, 3, 8, 3)
        action_layout.setSpacing(8)
        
        # 撤销/重做
        undo_btn = QPushButton("↶")
        undo_btn.setToolTip("撤销 (Ctrl+Z)")
        undo_btn.clicked.connect(self.editor.undo)
        undo_btn.setFixedSize(35, 35)
        undo_btn.setStyleSheet(self.get_action_button_style())
        action_layout.addWidget(undo_btn)

        redo_btn = QPushButton("↷")
        redo_btn.setToolTip("重做 (Ctrl+Y)")
        redo_btn.clicked.connect(self.editor.redo)
        redo_btn.setFixedSize(35, 35)
        redo_btn.setStyleSheet(self.get_action_button_style())
        action_layout.addWidget(redo_btn)

        # 清空
        clear_btn = QPushButton("🗑")
        clear_btn.setToolTip("清空所有内容")
        clear_btn.clicked.connect(self.clear_content)
        clear_btn.setFixedSize(35, 35)
        clear_btn.setStyleSheet(self.get_action_button_style())
        action_layout.addWidget(clear_btn)
        
        main_layout.addWidget(action_group)
        
        # 添加弹性空间
        main_layout.addStretch()
        
        # 右侧：主题选择和导出
        right_group = QFrame()
        right_layout = QHBoxLayout(right_group)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(15)
        
        # 主题选择器
        theme_label = QLabel("主题:")
        theme_label.setStyleSheet("color: rgba(255, 255, 255, 0.8); font-size: 13px;")
        right_layout.addWidget(theme_label)
        
        self.theme_selector = QComboBox()
        self.theme_selector.setFixedWidth(130)
        themes = self.style_manager.get_theme_display_names()
        for key, name in themes.items():
            self.theme_selector.addItem(name, key)
        self.theme_selector.setCurrentText("小红书经典")
        self.theme_selector.setStyleSheet(self.get_combobox_style())
        right_layout.addWidget(self.theme_selector)
        
        # 导出按钮
        self.export_btn = QPushButton("📸 导出图片")
        self.export_btn.clicked.connect(self.export_images)
        self.export_btn.setStyleSheet(self.get_export_button_style())
        right_layout.addWidget(self.export_btn)
        
        main_layout.addWidget(right_group)
        
        # 连接标题选择器信号
        self.heading_selector.currentIndexChanged.connect(self.on_heading_changed)
        
        return toolbar_container
    
    def create_separator(self):
        """创建分隔线"""
        separator = QFrame()
        separator.setFrameStyle(QFrame.VLine | QFrame.Sunken)
        separator.setStyleSheet("background: rgba(255, 255, 255, 0.1);")
        separator.setFixedWidth(1)
        return separator
    
    def get_tool_button_style(self):
        """工具按钮样式"""
        return """
            QToolButton {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                padding: 2px;
            }
            QToolButton:hover {
                background: rgba(0, 255, 136, 0.15);
                border-color: rgba(0, 255, 136, 0.4);
                color: #00ff88;
            }
            QToolButton:pressed {
                background: rgba(0, 255, 136, 0.25);
            }
        """
    
    def get_action_button_style(self):
        """操作按钮样式（更小的尺寸）"""
        return """
            QPushButton {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                border-radius: 8px;
                font-size: 16px;
                font-weight: 500;
            }
            QPushButton:hover {
                background: rgba(255, 255, 255, 0.12);
                border-color: rgba(255, 255, 255, 0.3);
            }
            QPushButton:pressed {
                background: rgba(255, 255, 255, 0.18);
            }
        """
    
    def get_mini_combobox_style(self):
        """迷你下拉框样式"""
        return """
            QComboBox {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px 8px;
                border-radius: 6px;
                font-size: 12px;
            }
            QComboBox:hover {
                background: rgba(255, 255, 255, 0.12);
            }
            QComboBox::drop-down {
                border: none;
                width: 16px;
            }
            QComboBox::down-arrow {
                image: none;
                border-style: solid;
                border-width: 3px 3px 0 3px;
                border-color: white transparent transparent transparent;
            }
            QComboBox QAbstractItemView {
                background: rgba(30, 30, 50, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                selection-background-color: rgba(0, 255, 136, 0.3);
                padding: 5px;
            }
        """
    
    def get_export_button_style(self):
        """导出按钮样式"""
        return """
            QPushButton {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 136, 0.3),
                    stop: 1 rgba(0, 255, 200, 0.3));
                border: 2px solid #00ff88;
                color: #00ff88;
                padding: 8px 20px;
                border-radius: 10px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 136, 0.4),
                    stop: 1 rgba(0, 255, 200, 0.4));
            }
            QPushButton:pressed {
                background: rgba(0, 255, 136, 0.5);
            }
        """
    
    def get_combobox_style(self):
        """下拉框样式"""
        return """
            QComboBox {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px 10px;
                border-radius: 8px;
                font-size: 13px;
            }
            QComboBox:hover {
                background: rgba(255, 255, 255, 0.12);
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-style: solid;
                border-width: 4px 4px 0 4px;
                border-color: white transparent transparent transparent;
            }
            QComboBox QAbstractItemView {
                background: rgba(30, 30, 50, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                selection-background-color: rgba(0, 255, 136, 0.3);
                padding: 5px;
            }
        """
    
    # ===== 编辑器操作方法 =====
    
    def on_heading_changed(self, index):
        """处理标题选择改变"""
        cursor = self.editor.editor.textCursor()
        cursor.movePosition(QTextCursor.StartOfLine)
        
        # 获取当前行文本
        cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)
        line_text = cursor.selectedText()
        
        # 移除已有的标题标记
        cleaned_text = line_text.lstrip('#').lstrip()
        
        # 根据选择添加新的标题标记
        if index == 0:  # 正文
            cursor.insertText(cleaned_text)
        else:  # H1-H6
            heading_level = '#' * index
            cursor.insertText(f"{heading_level} {cleaned_text}")
    
    def insert_bold(self):
        """插入粗体标记"""
        cursor = self.editor.editor.textCursor()
        if cursor.hasSelection():
            text = cursor.selectedText()
            cursor.insertText(f"**{text}**")
        else:
            cursor.insertText("****")
            cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 2)
            self.editor.editor.setTextCursor(cursor)
    
    def insert_italic(self):
        """插入斜体标记"""
        cursor = self.editor.editor.textCursor()
        if cursor.hasSelection():
            text = cursor.selectedText()
            cursor.insertText(f"*{text}*")
        else:
            cursor.insertText("**")
            cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)
            self.editor.editor.setTextCursor(cursor)
    
    def insert_strikethrough(self):
        """插入删除线标记"""
        cursor = self.editor.editor.textCursor()
        if cursor.hasSelection():
            text = cursor.selectedText()
            cursor.insertText(f"~~{text}~~")
        else:
            cursor.insertText("~~~~")
            cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 2)
            self.editor.editor.setTextCursor(cursor)
    
    def insert_inline_code(self):
        """插入行内代码标记"""
        cursor = self.editor.editor.textCursor()
        if cursor.hasSelection():
            text = cursor.selectedText()
            cursor.insertText(f"`{text}`")
        else:
            cursor.insertText("``")
            cursor.movePosition(QTextCursor.Left, QTextCursor.MoveAnchor, 1)
            self.editor.editor.setTextCursor(cursor)
    
    def insert_code_block(self):
        """插入代码块"""
        cursor = self.editor.editor.textCursor()
        if cursor.hasSelection():
            text = cursor.selectedText()
            cursor.insertText(f"```\n{text}\n```")
        else:
            cursor.insertText("```python\n\n```")
            cursor.movePosition(QTextCursor.Up, QTextCursor.MoveAnchor, 1)
            self.editor.editor.setTextCursor(cursor)
    
    def insert_unordered_list(self):
        """插入无序列表 - 支持多行转换"""
        cursor = self.editor.editor.textCursor()
        
        # 检查是否有选中文本
        if cursor.hasSelection():
            # 获取选中的文本
            selected_text = cursor.selectedText()
            
            # 将段落分隔符转换为换行符（Qt使用特殊字符表示段落）
            lines = selected_text.replace('\u2029', '\n').split('\n')
            
            # 转换每一行为列表项
            list_lines = []
            for line in lines:
                line = line.strip()
                if line:  # 忽略空行
                    # 检查是否已经是列表项
                    if line.startswith('- '):
                        list_lines.append(line)  # 已经是无序列表
                    elif line.startswith('* ') or line.startswith('+ '):
                        # 其他无序列表标记，统一为 -
                        list_lines.append('- ' + line[2:])
                    elif re.match(r'^\d+\.\s', line):
                        # 有序列表，转换为无序
                        list_lines.append('- ' + re.sub(r'^\d+\.\s+', '', line))
                    elif line.startswith('- [ ] ') or line.startswith('- [x] '):
                        # 任务列表，保留内容但改为普通无序列表
                        content = line[6:] if line.startswith('- [ ] ') else line[6:]
                        list_lines.append('- ' + content)
                    else:
                        # 普通文本，添加列表标记
                        list_lines.append('- ' + line)
            
            # 替换选中的文本
            if list_lines:
                cursor.insertText('\n'.join(list_lines))
        else:
            # 没有选中文本，只在当前行添加列表标记
            cursor.movePosition(QTextCursor.StartOfLine)
            
            # 获取当前行文本
            cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)
            line_text = cursor.selectedText().strip()
            
            # 检查并转换当前行
            if line_text:
                if not line_text.startswith('- '):
                    # 移除其他列表标记
                    if line_text.startswith('* ') or line_text.startswith('+ '):
                        cursor.insertText('- ' + line_text[2:])
                    elif re.match(r'^\d+\.\s', line_text):
                        cursor.insertText('- ' + re.sub(r'^\d+\.\s+', '', line_text))
                    elif line_text.startswith('- [ ] ') or line_text.startswith('- [x] '):
                        content = line_text[6:]
                        cursor.insertText('- ' + content)
                    else:
                        cursor.insertText('- ' + line_text)
                else:
                    # 已经是无序列表，保持不变
                    cursor.insertText(line_text)
            else:
                # 空行，直接添加列表标记
                cursor.insertText('- ')
    
    def insert_ordered_list(self):
        """插入有序列表 - 支持多行转换"""
        cursor = self.editor.editor.textCursor()
        
        # 检查是否有选中文本
        if cursor.hasSelection():
            # 获取选中的文本
            selected_text = cursor.selectedText()
            
            # 将段落分隔符转换为换行符
            lines = selected_text.replace('\u2029', '\n').split('\n')
            
            # 转换每一行为列表项
            list_lines = []
            list_number = 1
            for line in lines:
                line = line.strip()
                if line:  # 忽略空行
                    # 检查是否已经是列表项
                    if re.match(r'^\d+\.\s', line):
                        # 已经是有序列表，重新编号
                        content = re.sub(r'^\d+\.\s+', '', line)
                        list_lines.append(f"{list_number}. {content}")
                        list_number += 1
                    elif line.startswith('- ') or line.startswith('* ') or line.startswith('+ '):
                        # 无序列表，转换为有序
                        list_lines.append(f"{list_number}. {line[2:]}")
                        list_number += 1
                    elif line.startswith('- [ ] ') or line.startswith('- [x] '):
                        # 任务列表，转换为有序列表
                        content = line[6:]
                        list_lines.append(f"{list_number}. {content}")
                        list_number += 1
                    else:
                        # 普通文本，添加列表编号
                        list_lines.append(f"{list_number}. {line}")
                        list_number += 1
            
            # 替换选中的文本
            if list_lines:
                cursor.insertText('\n'.join(list_lines))
        else:
            # 没有选中文本，只在当前行添加列表标记
            cursor.movePosition(QTextCursor.StartOfLine)
            
            # 获取当前行文本
            cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)
            line_text = cursor.selectedText().strip()
            
            # 检查并转换当前行
            if line_text:
                if not re.match(r'^\d+\.\s', line_text):
                    # 移除其他列表标记
                    if line_text.startswith('- ') or line_text.startswith('* ') or line_text.startswith('+ '):
                        cursor.insertText('1. ' + line_text[2:])
                    elif line_text.startswith('- [ ] ') or line_text.startswith('- [x] '):
                        content = line_text[6:]
                        cursor.insertText('1. ' + content)
                    else:
                        cursor.insertText('1. ' + line_text)
                else:
                    # 已经是有序列表，保持不变
                    cursor.insertText(line_text)
            else:
                # 空行，直接添加列表标记
                cursor.insertText('1. ')
    
    def insert_task_list(self):
        """插入任务列表 - 支持多行转换"""
        cursor = self.editor.editor.textCursor()
        
        # 检查是否有选中文本
        if cursor.hasSelection():
            # 获取选中的文本
            selected_text = cursor.selectedText()
            
            # 将段落分隔符转换为换行符
            lines = selected_text.replace('\u2029', '\n').split('\n')
            
            # 转换每一行为任务列表项
            list_lines = []
            for line in lines:
                line = line.strip()
                if line:  # 忽略空行
                    # 检查是否已经是任务列表
                    if line.startswith('- [ ] ') or line.startswith('- [x] ') or line.startswith('- [X] '):
                        list_lines.append(line)  # 已经是任务列表，保持不变
                    elif line.startswith('- ') or line.startswith('* ') or line.startswith('+ '):
                        # 普通无序列表，转换为任务列表
                        list_lines.append('- [ ] ' + line[2:])
                    elif re.match(r'^\d+\.\s', line):
                        # 有序列表，转换为任务列表
                        content = re.sub(r'^\d+\.\s+', '', line)
                        list_lines.append('- [ ] ' + content)
                    else:
                        # 普通文本，添加任务列表标记
                        list_lines.append('- [ ] ' + line)
            
            # 替换选中的文本
            if list_lines:
                cursor.insertText('\n'.join(list_lines))
        else:
            # 没有选中文本，只在当前行添加任务列表标记
            cursor.movePosition(QTextCursor.StartOfLine)
            
            # 获取当前行文本
            cursor.movePosition(QTextCursor.EndOfLine, QTextCursor.KeepAnchor)
            line_text = cursor.selectedText().strip()
            
            # 检查并转换当前行
            if line_text:
                if not (line_text.startswith('- [ ] ') or line_text.startswith('- [x] ')):
                    # 移除其他列表标记
                    if line_text.startswith('- ') or line_text.startswith('* ') or line_text.startswith('+ '):
                        cursor.insertText('- [ ] ' + line_text[2:])
                    elif re.match(r'^\d+\.\s', line_text):
                        content = re.sub(r'^\d+\.\s+', '', line_text)
                        cursor.insertText('- [ ] ' + content)
                    else:
                        cursor.insertText('- [ ] ' + line_text)
                else:
                    # 已经是任务列表，切换选中状态
                    if line_text.startswith('- [ ] '):
                        cursor.insertText('- [x] ' + line_text[6:])
                    else:
                        cursor.insertText('- [ ] ' + line_text[6:])
            else:
                # 空行，直接添加任务列表标记
                cursor.insertText('- [ ] ')
    
    def insert_quote(self):
        """插入引用"""
        cursor = self.editor.editor.textCursor()
        cursor.movePosition(QTextCursor.StartOfLine)
        cursor.insertText("> ")
    
    def insert_divider(self):
        """插入分隔线"""
        self.editor.insertPlainText("\n---\n")
    
    def insert_link(self):
        """插入链接（带对话框）"""
        dialog = LinkDialog(self)
        if dialog.exec():
            text = dialog.text_edit.text() or "链接文字"
            url = dialog.url_edit.text() or "https://example.com"
            self.editor.insertPlainText(f"[{text}]({url})")
    
    def insert_image(self):
        """插入图片"""
        # 弹出文件选择对话框
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "选择图片",
            "",
            "Images (*.png *.jpg *.jpeg *.gif *.bmp *.svg);;All Files (*)"
        )
        
        if file_path:
            # 获取文件名作为替代文本
            import os
            file_name = os.path.basename(file_path)
            
            # 插入图片语法
            cursor = self.editor.editor.textCursor()
            cursor.insertText(f"![{file_name}]({file_path})")
            
            # 提示用户
            self.status_bar.showMessage(f"已插入图片: {file_name}", 3000)
    
    def insert_table(self):
        """插入表格"""
        dialog = TableDialog(self)
        if dialog.exec():
            rows = dialog.rows_spin.value()
            cols = dialog.cols_spin.value()
            
            # 生成表格
            table = []
            
            # 表头
            header = "|"
            for i in range(cols):
                header += f" 列{i+1} |"
            table.append(header)
            
            # 分隔线
            separator = "|"
            for _ in range(cols):
                separator += " --- |"
            table.append(separator)
            
            # 数据行
            for r in range(rows - 1):
                row = "|"
                for c in range(cols):
                    row += f" 数据 |"
                table.append(row)
            
            # 插入表格
            self.editor.insertPlainText("\n" + "\n".join(table) + "\n")
    
    # ===== 其他方法保持不变 =====
    
    def create_glass_container(self, widget, title):
        """创建毛玻璃容器"""
        container = QFrame()
        container.setObjectName("glassContainer")
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 标题栏
        title_bar = QFrame()
        title_bar.setObjectName("glassTitleBar")
        title_bar.setFixedHeight(45)
        
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(20, 0, 20, 0)
        
        title_label = QLabel(title)
        title_label.setObjectName("glassTitle")
        title_layout.addWidget(title_label)
        title_layout.addStretch()
        
        # 添加组件
        layout.addWidget(title_bar)
        layout.addWidget(widget, 1)
        
        # 添加发光效果
        glow = QGraphicsDropShadowEffect()
        glow.setBlurRadius(30)
        glow.setOffset(0, 0)
        glow.setColor(QColor(0, 224, 255, 80))
        widget.setGraphicsEffect(glow)
        
        return container
    
    def create_status_bar(self):
        """创建毛玻璃状态栏"""
        self.status_bar = QStatusBar()
        self.status_bar.setObjectName("glassStatusBar")
        self.status_bar.setFixedHeight(40)
        self.setStatusBar(self.status_bar)
        
        # 字数统计
        self.char_count_label = QLabel("Words: 0")
        self.char_count_label.setObjectName("statusLabel")
        
        # 主题信息
        self.theme_info_label = QLabel("Theme: 小红书经典")
        self.theme_info_label.setObjectName("statusLabel")
        
        self.status_bar.addPermanentWidget(self.theme_info_label)
        self.status_bar.addPermanentWidget(self.char_count_label)
    
    def get_global_styles_qt_compatible(self):
        """获取Qt兼容的全局样式表"""
        return """
        /* 全局字体 */
        * {
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        
        /* 内容区域 */
        #contentArea {
            background: transparent;
        }
        
        /* 毛玻璃容器 */
        #glassContainer {
            background: rgba(30, 30, 50, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
        }
        
        #glassTitleBar {
            background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                stop: 0 rgba(255, 255, 255, 0.1),
                stop: 1 rgba(255, 255, 255, 0.05));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
        }
        
        #glassTitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        /* 工具栏容器 */
        #toolbarContainer {
            background: rgba(20, 20, 40, 0.95);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #buttonGroup {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
        }
        
        /* 分割器 */
        #mainSplitter::handle {
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 rgba(255, 255, 255, 0),
                stop: 0.5 rgba(255, 255, 255, 0.2),
                stop: 1 rgba(255, 255, 255, 0));
            width: 3px;
        }
        
        #mainSplitter::handle:hover {
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 rgba(0, 255, 255, 0),
                stop: 0.5 rgba(0, 255, 255, 0.5),
                stop: 1 rgba(0, 255, 255, 0));
        }
        
        /* 状态栏 */
        #glassStatusBar {
            background: rgba(20, 20, 40, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }
        
        #statusLabel {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 500;
            padding: 5px 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin: 0 5px;
        }
        
        /* 滚动条美化 */
        QScrollBar:vertical {
            background: rgba(255, 255, 255, 0.03);
            width: 12px;
            border-radius: 6px;
            margin: 2px;
        }
        
        QScrollBar::handle:vertical {
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 rgba(0, 255, 255, 0.3),
                stop: 1 rgba(255, 0, 255, 0.3));
            border-radius: 6px;
            min-height: 30px;
        }
        
        QScrollBar::handle:vertical:hover {
            background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0 rgba(0, 255, 255, 0.5),
                stop: 1 rgba(255, 0, 255, 0.5));
        }
        
        QScrollBar::add-line:vertical,
        QScrollBar::sub-line:vertical {
            height: 0px;
        }
        
        /* 工具提示 */
        QToolTip {
            background: rgba(30, 30, 50, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        """
    
    def resizeEvent(self, event):
        """窗口大小改变时调整背景"""
        super().resizeEvent(event)
        if hasattr(self, 'aurora_bg'):
            self.aurora_bg.resize(self.size())
    
    def setup_connections(self):
        """设置信号连接"""
        self.editor.textChanged.connect(self.on_text_changed)
        self.editor.scrollChanged.connect(self.preview.handle_scroll)
        self.preview.pageChanged.connect(self.on_page_changed)
        self.theme_selector.currentIndexChanged.connect(self.on_theme_changed)
        
        if hasattr(self.preview, 'sizeChanged'):
            self.preview.sizeChanged.connect(self.on_size_changed)
    
    def on_text_changed(self):
        """文本改变时启动计时器"""
        self.update_timer.stop()
        self.update_timer.start()
        self.update_char_count()
    
    def update_preview(self):
        """更新预览"""
        self.update_timer.stop()
        markdown_text = self.editor.get_text()
        self.preview.update_content(markdown_text)
    
    def update_char_count(self):
        """更新字数统计"""
        text = self.editor.get_text()
        char_count = len(text.replace(" ", "").replace("\n", ""))
        word_count = len(text.split())
        self.char_count_label.setText(f"字符: {char_count} | 单词: {word_count}")
    
    def on_page_changed(self, current, total):
        """页码改变时更新状态栏"""
        if total > 1:
            self.status_bar.showMessage(f"第 {current}/{total} 页", 2000)
    
    def on_theme_changed(self, index):
        """处理主题改变"""
        theme_key = self.theme_selector.currentData()
        if theme_key:
            self.preview.change_theme(theme_key)
            theme_name = self.theme_selector.currentText()
            self.theme_info_label.setText(f"主题: {theme_name}")
            self.status_bar.showMessage(f"已切换到: {theme_name}", 3000)
    
    def on_size_changed(self, size):
        """处理尺寸改变"""
        size_display = {
            "small": "小 (720×960)",
            "medium": "中 (1080×1440)",
            "large": "大 (1440×1920)"
        }
        display_name = size_display.get(size, size)
        self.status_bar.showMessage(f"尺寸: {display_name}", 3000)
    
    def clear_content(self):
        """清空内容"""
        reply = QMessageBox.question(
            self, "清空内容",
            "确定要清空所有内容吗？\n此操作无法撤销。",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.editor.editor.clear()
            self.status_bar.showMessage("✅ 内容已清空", 2000)
    
    def export_images(self):
        """导出图片"""
        if not self.editor.get_text().strip():
            QMessageBox.warning(
                self, "提示",
                "没有内容可导出。请先输入一些文本。",
                QMessageBox.Ok
            )
            return
        
        folder = QFileDialog.getExistingDirectory(
            self, 
            "选择导出文件夹",
            "",
            QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
        )
        
        if folder:
            try:
                theme_name = self.theme_selector.currentText()
                self.status_bar.showMessage(f"正在导出图片 (主题: {theme_name})...", 0)
                self.preview.export_pages(folder)
                
                QMessageBox.information(
                    self, "导出成功",
                    f"图片已成功导出到:\n{folder}\n\n主题: {theme_name}",
                    QMessageBox.Ok
                )
                
            except Exception as e:
                QMessageBox.critical(
                    self, "导出失败",
                    f"导出过程中出错:\n{str(e)}",
                    QMessageBox.Ok
                )
                self.status_bar.showMessage("❌ 导出失败", 3000) preview_widget.py->text/plain-># ============================================
# src/ui/preview_widget.py - Qt兼容优化版（修复导出后模式问题）
# ============================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QFrame, 
                               QPushButton, QHBoxLayout, QProgressDialog,
                               QMessageBox, QComboBox, QButtonGroup, QRadioButton,
                               QScrollArea)
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtCore import QUrl, QTimer, Signal, Qt, QSize, QEvent
from PySide6.QtGui import QWheelEvent, QFont
from pathlib import Path
from src.core.markdown_processor import MarkdownProcessor
from src.core.html_generator import HTMLGenerator
from src.utils.paginator import SmartPaginator
from src.utils.exporter import ImageExporter

class CustomScrollArea(QScrollArea):
    """自定义滚动区域，处理滚轮事件"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.preview_widget = None  # 将在PreviewWidget中设置
        
    def wheelEvent(self, event: QWheelEvent):
        """重写滚轮事件"""
        if self.preview_widget:
            # 适应窗口模式：滚轮翻页
            if self.preview_widget.preview_mode == "fit":
                if event.angleDelta().y() > 0:
                    self.preview_widget.prev_page()
                else:
                    self.preview_widget.next_page()
                event.accept()
                return
            
            # 实际大小模式：检查是否按住Shift进行横向滚动
            elif self.preview_widget.preview_mode == "actual":
                # 如果按住Shift键，实现横向滚动
                if event.modifiers() == Qt.ShiftModifier:
                    # 获取滚动距离
                    delta = event.angleDelta().y()
                    # 横向滚动
                    h_scrollbar = self.horizontalScrollBar()
                    h_scrollbar.setValue(h_scrollbar.value() - delta)
                    event.accept()
                    return
                else:
                    # 正常的垂直滚动
                    super().wheelEvent(event)
                    return
        
        # 默认处理
        super().wheelEvent(event)

class PreviewWidget(QWidget):
    pageChanged = Signal(int, int)  # 当前页，总页数
    sizeChanged = Signal(str)  # 尺寸改变信号
    
    def __init__(self):
        super().__init__()
        self.current_pages = []  # 存储分页后的HTML内容
        self.current_page = 1
        self.total_pages = 1
        self.markdown_text = ""  # 保存原始markdown文本
        self.current_size = "medium"  # 当前页面尺寸
        self.preview_mode = "fit"  # 预览模式: fit(适应窗口) 或 actual(实际大小)
        self._is_exporting = False  # 添加导出状态标志
        
        # 初始化处理器
        self.markdown_processor = MarkdownProcessor()
        self.html_generator = HTMLGenerator(page_size="medium")
        self.paginator = SmartPaginator(page_size="medium")
        
        # 初始化UI
        self.init_ui()
        
        # 设置导出器
        self.setup_exporter()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 创建容器框架 - 移除重复的标题栏
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: transparent;
                border: none;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        
        # 创建顶部控制栏（包含尺寸和模式选择）
        top_control_bar = self.create_top_control_bar()
        
        # 创建WebView容器
        self.create_web_view_container()
        
        # 创建底部导航控制栏
        bottom_control_bar = self.create_bottom_control_bar()
        
        # 组装布局
        container_layout.addWidget(top_control_bar)
        container_layout.addWidget(self.web_container, 1)
        container_layout.addWidget(bottom_control_bar)
        
        layout.addWidget(container)
        
        # 连接信号
        self.connect_signals()
        
        # 初始化按钮状态
        self.update_buttons()
    
    def create_top_control_bar(self):
        """创建顶部控制栏 - Qt兼容样式"""
        control_bar = QFrame()
        control_bar.setFixedHeight(50)
        control_bar.setStyleSheet("""
            QFrame {
                background: rgba(30, 30, 50, 0.8);
                border-bottom: 1px solid rgba(255, 255, 255, 0.15);
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
            }
        """)
        
        layout = QHBoxLayout(control_bar)
        layout.setContentsMargins(20, 10, 20, 10)
        layout.setSpacing(20)
        
        # 尺寸选择部分
        size_container = QWidget()
        size_layout = QHBoxLayout(size_container)
        size_layout.setContentsMargins(0, 0, 0, 0)
        size_layout.setSpacing(10)
        
        size_label = QLabel("尺寸:")
        size_label.setStyleSheet("""
            QLabel {
                color: rgba(255, 255, 255, 0.8);
                font-size: 13px;
                font-weight: 500;
            }
        """)
        
        self.size_selector = QComboBox()
        self.size_selector.addItems(["Small (720×960)", "Medium (1080×1440)", "Large (1440×1920)"])
        self.size_selector.setCurrentIndex(1)
        self.size_selector.setFixedWidth(160)
        self.size_selector.setStyleSheet(self.get_combobox_style_qt())
        
        size_layout.addWidget(size_label)
        size_layout.addWidget(self.size_selector)
        
        # 预览模式部分
        mode_container = QWidget()
        mode_layout = QHBoxLayout(mode_container)
        mode_layout.setContentsMargins(0, 0, 0, 0)
        mode_layout.setSpacing(10)
        
        mode_label = QLabel("模式:")
        mode_label.setStyleSheet("""
            QLabel {
                color: rgba(255, 255, 255, 0.8);
                font-size: 13px;
                font-weight: 500;
            }
        """)
        
        self.mode_group = QButtonGroup()
        
        self.fit_mode_btn = QRadioButton("适应窗口")
        self.fit_mode_btn.setChecked(True)
        self.fit_mode_btn.setStyleSheet(self.get_radio_style_qt())
        
        self.actual_mode_btn = QRadioButton("实际大小")
        self.actual_mode_btn.setStyleSheet(self.get_radio_style_qt())
        
        self.mode_group.addButton(self.fit_mode_btn, 0)
        self.mode_group.addButton(self.actual_mode_btn, 1)
        
        mode_layout.addWidget(mode_label)
        mode_layout.addWidget(self.fit_mode_btn)
        mode_layout.addWidget(self.actual_mode_btn)
        
        # 组装顶部控制栏
        layout.addWidget(size_container)
        layout.addSpacing(30)
        layout.addWidget(mode_container)
        layout.addStretch()
        
        return control_bar
    
    def create_web_view_container(self):
        """创建WebView容器 - Qt兼容样式"""
        # 使用自定义滚动区域
        self.web_container = CustomScrollArea()
        self.web_container.preview_widget = self  # 设置引用
        
        self.web_container.setStyleSheet("""
            QScrollArea {
                border: none;
                background: rgba(20, 20, 40, 0.4);
            }
            
            QScrollBar:vertical {
                background: rgba(255, 255, 255, 0.03);
                width: 12px;
                border-radius: 6px;
                margin: 4px;
            }
            
            QScrollBar::handle:vertical {
                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 255, 255, 0.3),
                    stop: 1 rgba(255, 0, 255, 0.3));
                border-radius: 6px;
                min-height: 30px;
            }
            
            QScrollBar::handle:vertical:hover {
                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 255, 255, 0.5),
                    stop: 1 rgba(255, 0, 255, 0.5));
            }
            
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                height: 0px;
            }
            
            QScrollBar:horizontal {
                background: rgba(255, 255, 255, 0.03);
                height: 12px;
                border-radius: 6px;
                margin: 4px;
            }
            
            QScrollBar::handle:horizontal {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 255, 0.3),
                    stop: 1 rgba(255, 0, 255, 0.3));
                border-radius: 6px;
                min-width: 30px;
            }
            
            QScrollBar::handle:horizontal:hover {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 255, 0.5),
                    stop: 1 rgba(255, 0, 255, 0.5));
            }
            
            QScrollBar::add-line:horizontal,
            QScrollBar::sub-line:horizontal {
                width: 0px;
            }
        """)
        
        # 创建WebView
        self.web_view = QWebEngineView()
        self.web_view.setStyleSheet("""
            QWebEngineView {
                border: none;
                background: transparent;
            }
        """)
        
        # 禁用WebView自身的滚动条和鼠标交互（在实际大小模式下）
        self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, False)
        self.web_view.setFocusPolicy(Qt.StrongFocus)
        
        # 设置滚动区域
        self.web_container.setWidget(self.web_view)
        self.web_container.setWidgetResizable(True)
        self.web_container.setAlignment(Qt.AlignCenter)
        
        # 默认设置为适应窗口模式
        self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    
    def create_bottom_control_bar(self):
        """创建底部导航控制栏 - Qt兼容样式"""
        control_bar = QFrame()
        control_bar.setFixedHeight(60)
        control_bar.setStyleSheet("""
            QFrame {
                background: rgba(20, 20, 40, 0.8);
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
        """)
        
        control_layout = QHBoxLayout(control_bar)
        control_layout.setContentsMargins(20, 12, 20, 12)
        control_layout.setSpacing(15)
        
        # 创建中心控制区容器
        center_controls = QWidget()
        center_layout = QHBoxLayout(center_controls)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.setSpacing(15)
        
        # 上一页按钮
        self.prev_btn = QPushButton("⬅ Previous")
        self.prev_btn.setFixedSize(110, 36)
        self.prev_btn.setStyleSheet(self.get_button_style_qt())
        
        # 页面信息标签
        self.page_info_label = QLabel("Page 1")
        self.page_info_label.setStyleSheet("""
            QLabel {
                color: #00ff88;
                font-size: 14px;
                font-weight: 600;
                padding: 8px 20px;
                background: rgba(0, 255, 136, 0.1);
                border: 1px solid rgba(0, 255, 136, 0.3);
                border-radius: 18px;
                min-width: 100px;
            }
        """)
        self.page_info_label.setAlignment(Qt.AlignCenter)
        
        # 下一页按钮
        self.next_btn = QPushButton("Next ➡")
        self.next_btn.setFixedSize(110, 36)
        self.next_btn.setStyleSheet(self.get_button_style_qt())
        
        # 组装中心控制区
        center_layout.addWidget(self.prev_btn)
        center_layout.addWidget(self.page_info_label)
        center_layout.addWidget(self.next_btn)
        
        # 快捷提示
        tips_label = QLabel("💡 滚轮：上下导航 • Shift+滚轮：左右滚动")
        tips_label.setStyleSheet("""
            QLabel {
                color: rgba(255, 255, 255, 0.5);
                font-size: 11px;
                font-style: italic;
                background: transparent;
            }
        """)
        tips_label.setFont(QFont("Arial", 10))
        
        # 组装控制栏
        control_layout.addStretch()
        control_layout.addWidget(center_controls)
        control_layout.addStretch()
        control_layout.addWidget(tips_label)
        
        return control_bar
    
    def connect_signals(self):
        """连接信号"""
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.size_selector.currentIndexChanged.connect(self.on_size_changed)
        self.mode_group.buttonClicked.connect(self.on_mode_changed)
    
    def keyPressEvent(self, event):
        """处理键盘事件"""
        if event.key() == Qt.Key_PageUp:
            self.prev_page()
        elif event.key() == Qt.Key_PageDown:
            self.next_page()
        elif event.key() == Qt.Key_Home:
            self.go_to_page(1)
        elif event.key() == Qt.Key_End:
            self.go_to_page(self.total_pages)
        else:
            super().keyPressEvent(event)
    
    def on_mode_changed(self):
        """处理预览模式改变"""
        # 如果正在导出，不允许切换模式
        if self._is_exporting:
            return
            
        if self.fit_mode_btn.isChecked():
            self.preview_mode = "fit"
            # 适应窗口模式：隐藏滚动条，启用自适应
            self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.web_container.setWidgetResizable(True)
            
            # 清除 WebView 的固定尺寸限制
            self.web_view.setMinimumSize(0, 0)
            self.web_view.setMaximumSize(16777215, 16777215)
            
            # 在适应模式下，WebView不需要处理鼠标事件
            self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, False)
            
        else:
            self.preview_mode = "actual"
            # 实际大小模式：显示滚动条
            self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.web_container.setWidgetResizable(False)
            
            # 在实际大小模式下，让WebView透明于鼠标滚轮事件
            # 这样滚轮事件会直接传递给ScrollArea
            self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        
        # 重新渲染当前页面
        self.display_current_page()
    
    def on_size_changed(self, index):
        """处理尺寸改变"""
        size_map = {0: "small", 1: "medium", 2: "large"}
        new_size = size_map.get(index, "medium")
        
        if new_size != self.current_size:
            self.current_size = new_size
            
            # 更新各组件的尺寸设置
            self.html_generator = HTMLGenerator(page_size=new_size)
            self.paginator.set_page_size(new_size)
            
            # 重新处理内容
            if self.markdown_text:
                self.update_content(self.markdown_text)
            
            # 发送尺寸改变信号
            self.sizeChanged.emit(new_size)
    
    def update_content(self, markdown_text: str):
        """更新预览内容"""
        try:
            self.markdown_text = markdown_text
            
            # 处理 Markdown
            html_content = self.markdown_processor.parse(markdown_text)
            
            # 使用智能分页器进行分页
            self.current_pages = self.paginator.paginate(html_content)
            
            # 优化分页结果
            self.current_pages = self.paginator.optimize_pages(self.current_pages)
            
            self.total_pages = len(self.current_pages)
            self.current_page = 1
            
            # 显示第一页
            self.display_current_page()
            
            # 更新按钮和信息
            self.update_buttons()
            self.update_page_info()
            
        except Exception as e:
            self.show_error(f"Preview error: {str(e)}")
    
    def display_current_page(self):
        """显示当前页"""
        # 如果正在导出，不更新显示
        if self._is_exporting:
            return
            
        if not self.current_pages:
            return
            
        if 1 <= self.current_page <= len(self.current_pages):
            page_content = self.current_pages[self.current_page - 1]
            
            # 获取目标尺寸
            size_config = {
                "small": (720, 960),
                "medium": (1080, 1440),
                "large": (1440, 1920)
            }
            target_width, target_height = size_config.get(self.current_size, (1080, 1440))
            
            # 根据预览模式生成不同的HTML
            if self.preview_mode == "fit":
                # 适应窗口模式
                full_html = self.generate_fit_html(page_content, target_width, target_height)
                self.web_view.setMinimumSize(0, 0)
                self.web_view.setMaximumSize(16777215, 16777215)
                self.web_container.setWidgetResizable(True)
                
            else:
                # 实际大小模式：添加禁用内部滚动的CSS
                full_html = self.generate_actual_html(page_content, target_width, target_height)
                # 设置WebView为实际尺寸
                self.web_view.setFixedSize(target_width, target_height)
                self.web_container.setWidgetResizable(False)
            
            # 加载到WebView
            self.web_view.setHtml(full_html, QUrl("file:///"))
    
    def generate_actual_html(self, content: str, target_width: int, target_height: int) -> str:
        """生成实际大小模式的HTML（禁用内部滚动）"""
        base_html = self.html_generator.generate(content)
        
        # 添加禁用滚动的CSS和JavaScript
        disable_scroll = """
        <style>
            /* 禁用所有内部滚动 */
            html, body {
                overflow: hidden !important;
                position: fixed !important;
                width: 100% !important;
                height: 100% !important;
                touch-action: none !important;
                user-select: none !important;
                -webkit-user-select: none !important;
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
            }
            
            html::-webkit-scrollbar,
            body::-webkit-scrollbar {
                display: none !important;
            }
            
            * {
                -ms-overflow-style: none !important;
                scrollbar-width: none !important;
            }
            
            *::-webkit-scrollbar {
                display: none !important;
            }
        </style>
        
        <script>
            // 禁用滚动事件
            document.addEventListener('DOMContentLoaded', function() {
                // 禁用滚轮事件
                document.addEventListener('wheel', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }, { passive: false, capture: true });
                
                // 禁用触摸滚动
                document.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }, { passive: false, capture: true });
                
                // 禁用键盘滚动
                document.addEventListener('keydown', function(e) {
                    const scrollKeys = [32, 33, 34, 35, 36, 37, 38, 39, 40];
                    if (scrollKeys.includes(e.keyCode)) {
                        e.preventDefault();
                        return false;
                    }
                }, false);
                
                // 固定body位置
                document.body.style.position = 'fixed';
                document.body.style.top = '0';
                document.body.style.left = '0';
                document.body.style.width = '100%';
                document.body.style.height = '100%';
                document.body.style.overflow = 'hidden';
            });
        </script>
        """
        
        # 插入到head标签结束前
        full_html = base_html.replace('</head>', disable_scroll + '</head>')
        
        return full_html
    
    def generate_fit_html(self, content: str, target_width: int, target_height: int) -> str:
        """生成适应窗口的HTML"""
        base_html = self.html_generator.generate(content)
        
        scale_script = f"""
        <style>
            * {{
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }}
            
            html, body {{
                width: 100%;
                height: 100%;
                overflow: hidden;
                background: #1a1a2e;
                display: flex;
                justify-content: center;
                align-items: center;
            }}
            
            #viewport-container {{
                position: relative;
                width: 100vw;
                height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: hidden;
            }}
            
            #content-wrapper {{
                position: relative;
                width: {target_width}px;
                height: {target_height}px;
                transform-origin: center center;
                flex-shrink: 0;
            }}
        </style>
        
        <script>
            document.addEventListener('DOMContentLoaded', function() {{
                if (!document.getElementById('viewport-container')) {{
                    const viewportContainer = document.createElement('div');
                    viewportContainer.id = 'viewport-container';
                    
                    const contentWrapper = document.createElement('div');
                    contentWrapper.id = 'content-wrapper';
                    
                    while (document.body.firstChild) {{
                        contentWrapper.appendChild(document.body.firstChild);
                    }}
                    
                    viewportContainer.appendChild(contentWrapper);
                    document.body.appendChild(viewportContainer);
                }}
                
                function adjustScale() {{
                    const wrapper = document.getElementById('content-wrapper');
                    const container = document.getElementById('viewport-container');
                    
                    if (!wrapper || !container) return;
                    
                    const availableWidth = container.clientWidth;
                    const availableHeight = container.clientHeight;
                    
                    const targetWidth = {target_width};
                    const targetHeight = {target_height};
                    
                    const padding = 40;
                    const scaleX = (availableWidth - padding) / targetWidth;
                    const scaleY = (availableHeight - padding) / targetHeight;
                    
                    const scale = Math.min(scaleX, scaleY, 1.0);
                    
                    wrapper.style.transform = `scale(${{scale}})`;
                }}
                
                setTimeout(adjustScale, 100);
                window.addEventListener('resize', adjustScale);
                
                const observer = new ResizeObserver(adjustScale);
                observer.observe(document.getElementById('viewport-container'));
            }});
        </script>
        """
        
        full_html = base_html.replace('</head>', scale_script + '</head>')
        return full_html
    
    def prev_page(self):
        """上一页"""
        if self.current_page > 1:
            self.go_to_page(self.current_page - 1)
    
    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages:
            self.go_to_page(self.current_page + 1)
    
    def go_to_page(self, page_num: int):
        """跳转到指定页"""
        if 1 <= page_num <= self.total_pages:
            self.current_page = page_num
            self.display_current_page()
            self.update_buttons()
            self.update_page_info()
    
    def update_buttons(self):
        """更新按钮状态"""
        self.prev_btn.setEnabled(self.current_page > 1)
        self.next_btn.setEnabled(self.current_page < self.total_pages)
        self.pageChanged.emit(self.current_page, self.total_pages)
    
    def update_page_info(self):
        """更新页面信息显示"""
        if self.total_pages > 1:
            self.page_info_label.setText(f"Page {self.current_page} / {self.total_pages}")
        else:
            self.page_info_label.setText("Page 1")
    
    def get_button_style_qt(self) -> str:
        """获取按钮样式 - Qt兼容版本"""
        return """
            QPushButton {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.25);
                color: rgba(255, 255, 255, 0.95);
                padding: 10px 20px;
                border-radius: 18px;
                font-weight: 600;
                font-size: 13px;
                letter-spacing: 0.5px;
            }
            
            QPushButton:hover {
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(0, 255, 136, 0.5);
                color: #00ff88;
            }
            
            QPushButton:pressed {
                background: rgba(0, 255, 136, 0.2);
            }
            
            QPushButton:disabled {
                background: rgba(255, 255, 255, 0.02);
                border-color: rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.3);
            }
        """
    
    def get_combobox_style_qt(self) -> str:
        """获取下拉框样式 - Qt兼容版本"""
        return """
            QComboBox {
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: rgba(255, 255, 255, 0.95);
                padding: 8px 15px;
                border-radius: 10px;
                font-size: 12px;
                font-weight: 500;
                letter-spacing: 0.3px;
            }
            
            QComboBox:hover {
                background: rgba(255, 255, 255, 0.12);
                border: 1px solid rgba(255, 255, 255, 0.3);
            }
            
            QComboBox::drop-down {
                border: none;
                width: 25px;
            }
            
            QComboBox::down-arrow {
                image: none;
                border-style: solid;
                border-width: 5px 5px 0 5px;
                border-color: rgba(255, 255, 255, 0.7) transparent transparent transparent;
                margin-right: 5px;
            }
            
            QComboBox QAbstractItemView {
                background: rgba(30, 30, 50, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                selection-background-color: rgba(0, 255, 136, 0.3);
                outline: none;
                padding: 5px;
                border-radius: 8px;
            }
            
            QComboBox QAbstractItemView::item {
                min-height: 32px;
                padding: 8px 12px;
                border-radius: 4px;
                margin: 2px 4px;
            }
            
            QComboBox QAbstractItemView::item:hover {
                background: rgba(255, 255, 255, 0.1);
            }
            
            QComboBox QAbstractItemView::item:selected {
                background: rgba(0, 255, 136, 0.3);
                color: white;
            }
        """
    
    def get_radio_style_qt(self) -> str:
        """获取单选按钮样式 - Qt兼容版本"""
        return """
            QRadioButton {
                color: rgba(255, 255, 255, 0.85);
                font-size: 12px;
                spacing: 8px;
                padding: 5px;
            }
            
            QRadioButton::indicator {
                width: 16px;
                height: 16px;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 8px;
                background: rgba(255, 255, 255, 0.05);
            }
            
            QRadioButton::indicator:hover {
                border-color: rgba(0, 255, 136, 0.5);
                background: rgba(0, 255, 136, 0.1);
            }
            
            QRadioButton::indicator:checked {
                background: qradialgradient(
                    cx: 0.5, cy: 0.5, radius: 0.5,
                    fx: 0.5, fy: 0.5,
                    stop: 0 #00ff88,
                    stop: 0.6 #00ff88,
                    stop: 0.7 transparent
                );
                border-color: #00ff88;
            }
            
            QRadioButton:checked {
                color: #00ff88;
            }
        """
    
    def setup_exporter(self):
        """设置导出器"""
        self.exporter = ImageExporter(self.web_view)
        self.exporter.progress.connect(self.on_export_progress)
        self.exporter.finished.connect(self.on_export_finished)
        self.exporter.page_exported.connect(self.on_page_exported)
    
    def export_pages(self, folder: str):
        """导出所有页面为图片"""
        if not self.current_pages:
            QMessageBox.warning(self, "Warning", "No content to export")
            return
        
        # 保存当前状态
        self._is_exporting = True
        self._saved_preview_mode = self.preview_mode
        self._saved_current_page = self.current_page
        
        # 创建进度对话框
        self.progress_dialog = QProgressDialog(
            "Exporting images...", 
            "Cancel", 
            0, 
            self.total_pages, 
            self
        )
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setMinimumDuration(0)
        self.progress_dialog.setAutoClose(False)
        self.progress_dialog.setAutoReset(False)
        
        # 设置进度对话框样式
        self.progress_dialog.setStyleSheet("""
            QProgressDialog {
                background: rgba(30, 30, 50, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                color: white;
            }
            QProgressBar {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 5px;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 255, 136, 0.6),
                    stop: 1 rgba(0, 255, 255, 0.6));
                border-radius: 4px;
            }
            QPushButton {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 5px 15px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background: rgba(255, 255, 255, 0.15);
            }
        """)
        
        self.progress_dialog.canceled.connect(self.on_export_canceled)
        
        # 开始导出（始终以实际大小导出）
        self.exporter.export_pages(
            self.current_pages,
            folder,
            self.html_generator,
            format="PNG",
            quality=100
        )
    
    def on_export_progress(self, current: int, total: int):
        """处理导出进度"""
        if hasattr(self, 'progress_dialog') and self.progress_dialog:
            self.progress_dialog.setValue(current)
            self.progress_dialog.setLabelText(f"Exporting page {current}/{total}...")
    
    def on_export_finished(self, success: bool, message: str):
        """处理导出完成"""
        # 重置导出状态
        self._is_exporting = False
        
        # 关闭进度对话框
        if hasattr(self, 'progress_dialog') and self.progress_dialog:
            try:
                self.progress_dialog.canceled.disconnect()
                self.progress_dialog.close()
                self.progress_dialog.deleteLater()
            except:
                pass
            finally:
                self.progress_dialog = None
        
        # 恢复之前的预览模式
        if hasattr(self, '_saved_preview_mode'):
            if self._saved_preview_mode == "fit":
                self.fit_mode_btn.setChecked(True)
                self.preview_mode = "fit"
                # 恢复适应窗口模式设置
                self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
                self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
                self.web_container.setWidgetResizable(True)
                self.web_view.setMinimumSize(0, 0)
                self.web_view.setMaximumSize(16777215, 16777215)
                self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, False)
            else:
                self.actual_mode_btn.setChecked(True)
                self.preview_mode = "actual"
                # 恢复实际大小模式设置
                self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
                self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
                self.web_container.setWidgetResizable(False)
                self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        
        # 恢复到之前的页面
        if hasattr(self, '_saved_current_page'):
            self.go_to_page(self._saved_current_page)
        
        # 显示结果消息
        if success:
            size_info = f"({self.current_size}: {self.get_actual_size()}px)"
            QMessageBox.information(self, "Export Successful", f"{message}\nSize: {size_info}")
        else:
            QMessageBox.warning(self, "Export Failed", message)
    
    def on_page_exported(self, page_num: int, file_path: str):
        """处理单页导出完成"""
        print(f"Exported page {page_num}: {file_path}")
    
    def on_export_canceled(self):
        """处理导出取消"""
        self.exporter.cancel_export()
        # 重置导出状态
        self._is_exporting = False
        
        # 恢复之前的预览模式
        if hasattr(self, '_saved_preview_mode'):
            if self._saved_preview_mode == "fit":
                self.fit_mode_btn.setChecked(True)
                self.preview_mode = "fit"
                self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
                self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
                self.web_container.setWidgetResizable(True)
                self.web_view.setMinimumSize(0, 0)
                self.web_view.setMaximumSize(16777215, 16777215)
                self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, False)
            else:
                self.actual_mode_btn.setChecked(True)
                self.preview_mode = "actual"
                self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
                self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
                self.web_container.setWidgetResizable(False)
                self.web_view.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        
        # 恢复到之前的页面
        if hasattr(self, '_saved_current_page'):
            self.go_to_page(self._saved_current_page)
    
    def get_actual_size(self) -> str:
        """获取实际尺寸"""
        size_config = {
            "small": "720×960",
            "medium": "1080×1440",
            "large": "1440×1920"
        }
        return size_config.get(self.current_size, "1080×1440")
    
    def handle_scroll(self, percentage: float):
        """处理编辑器滚动同步（保留接口兼容性）"""
        pass
    
    def show_error(self, message: str):
        """显示错误信息"""
        error_html = f"""
        <html>
        <body style="padding: 20px; font-family: sans-serif; background: #1a1a2e; color: #e0e6ed;">
            <h3 style="color: #ff4757;">Error</h3>
            <p style="color: #8a92a6;">{message}</p>
        </body>
        </html>
        """
        self.web_view.setHtml(error_html)
    
    def change_theme(self, theme: str):
        """切换主题"""
        self.html_generator.set_theme(theme)
        if self.current_pages:
            self.display_current_page()
    
    def resizeEvent(self, event):
        """处理窗口大小改变事件"""
        super().resizeEvent(event)
        # 在适应窗口模式下，重新渲染以适应新尺寸
        if self.preview_mode == "fit" and self.current_pages:
            # 延迟执行以避免频繁重绘
            if hasattr(self, 'resize_timer'):
                self.resize_timer.stop()
            else:
                self.resize_timer = QTimer()
                self.resize_timer.timeout.connect(self.on_resize_finished)
                self.resize_timer.setSingleShot(True)
            self.resize_timer.start(300)
    
    def on_resize_finished(self):
        """窗口大小调整完成后的处理"""
        if self.preview_mode == "fit":
            self.display_current_page() html_generator.py->text/plain-># ============================================
# src/core/html_generator.py
# ============================================
from pathlib import Path
from typing import Optional
from src.utils.style_manager import StyleManager

class HTMLGenerator:
    def __init__(self, font_size: int = 18, page_size: str = "medium", theme: str = "xiaohongshu"):
        self.resource_path = Path(__file__).parent.parent / "resources"
        self.base_font_size = font_size  # 基础字体大小，默认18px
        
        # 页面尺寸配置
        self.page_sizes = {
            "small": {"width": 720, "height": 960},
            "medium": {"width": 1080, "height": 1440},
            "large": {"width": 1440, "height": 1920}
        }
        self.current_size = page_size
        self.page_width = self.page_sizes[page_size]["width"]
        self.page_height = self.page_sizes[page_size]["height"]
        
        # 样式管理器
        self.style_manager = StyleManager(theme)
        self.current_theme = theme
        
    def set_page_size(self, size: str):
        """设置页面尺寸"""
        if size in self.page_sizes:
            self.current_size = size
            self.page_width = self.page_sizes[size]["width"]
            self.page_height = self.page_sizes[size]["height"]
    
    def set_theme(self, theme: str):
        """设置主题"""
        self.current_theme = theme
        self.style_manager.set_theme(theme)
    
    def set_font_size(self, size: int):
        """设置基础字体大小"""
        self.base_font_size = size
        
    def generate(self, content: str, page_num: int = 0, total_pages: int = 0) -> str:
        """
        生成完整的 HTML 页面
        
        Args:
            content: HTML内容
            page_num: 当前页码（0表示不显示）
            total_pages: 总页数
        """
        # 生成主题CSS
        theme_css = self.style_manager.generate_css(self.current_theme, self.base_font_size)
        
        # 生成页面特定CSS
        page_css = self.get_page_css()
        
        # 获取JavaScript
        js = self.get_js()
        
        # 生成页码信息（如果需要）
        page_info = ""
        if page_num > 0 and total_pages > 1:
            page_info = f"""
            <div class="page-info">
                <span class="page-number">{page_num}</span>
                <span class="page-separator">/</span>
                <span class="page-total">{total_pages}</span>
            </div>
            """
        
        html = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小红书卡片 - {self.style_manager.get_theme().name}</title>
    <style>
        {theme_css}
        {page_css}
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="content" id="content">
                {content}
            </div>
            {page_info}
        </div>
    </div>
    <script>{js}</script>
</body>
</html>
"""
        return html
    
    def get_page_css(self) -> str:
        """获取页面布局CSS"""
        theme = self.style_manager.get_theme()
        
        # 检查是否为深色主题
        is_dark = self.current_theme in ["dark_mode", "midnight", "douyin"]
        
        return f"""
        /* 页面布局 */
        html, body {{
            width: {self.page_width}px;
            height: {self.page_height}px;
            overflow: hidden !important;
            margin: 0;
            padding: 0;
        }}
        
        .container {{
            width: {self.page_width}px;
            height: {self.page_height}px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
        }}
        
        .card {{
            width: 100%;
            height: 100%;
            background: {'rgba(255, 255, 255, 0.98)' if not is_dark else 'rgba(20, 20, 35, 0.98)'};
            border-radius: 20px;
            box-shadow: 0 20px 60px {self.style_manager.add_alpha(theme.primary_color, 0.15)},
                        0 10px 30px {self.style_manager.add_alpha('#000000', 0.1)};
            overflow: hidden;
            position: relative;
        }}
        
        .content {{
            padding: 50px 45px 70px 45px;
            color: var(--text-color);
            line-height: 1.85;
            height: 100%;
            overflow: hidden !important;
            position: relative;
        }}
        
        /* 页码信息 */
        .page-info {{
            position: absolute;
            bottom: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 16px;
            background: {self.style_manager.add_alpha(theme.primary_color, 0.1)};
            border-radius: 20px;
            border: 1px solid {self.style_manager.add_alpha(theme.primary_color, 0.2)};
        }}
        
        .page-number {{
            font-weight: 700;
            color: var(--primary-color);
            font-size: 14px;
        }}
        
        .page-separator {{
            color: {self.style_manager.add_alpha(theme.text_color, 0.4)};
            font-size: 12px;
        }}
        
        .page-total {{
            color: {self.style_manager.add_alpha(theme.text_color, 0.6)};
            font-size: 14px;
        }}
        
        /* 装饰元素 */
        .card::before {{
            content: "";
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, {self.style_manager.add_alpha(theme.primary_color, 0.1)} 0%, transparent 70%);
            pointer-events: none;
        }}
        
        .card::after {{
            content: "";
            position: absolute;
            bottom: -50%;
            left: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, {self.style_manager.add_alpha(theme.secondary_color, 0.1)} 0%, transparent 70%);
            pointer-events: none;
        }}
        
        /* 响应式图片 */
        img {{
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 8px 24px {self.style_manager.add_alpha('#000000', 0.1)};
        }}
        
        /* 隐藏滚动条 */
        ::-webkit-scrollbar {{
            display: none !important;
        }}
        
        * {{
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }}
        
        /* 打印样式 */
        @media print {{
            body {{
                background: white;
                padding: 0;
            }}
            
            .container {{
                max-width: 100%;
            }}
            
            .card {{
                box-shadow: none;
                border-radius: 0;
                page-break-inside: avoid;
            }}
            
            .card::before,
            .card::after {{
                display: none;
            }}
        }}

        /* 完全隐藏分页标记 */
        .pagebreak-marker {{
            display: none !important;
            height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            visibility: hidden !important;
        }}
        """
    
    def get_js(self) -> str:
        """获取JavaScript代码"""
        return """
        // 页面加载完成后的处理
        document.addEventListener('DOMContentLoaded', function() {
            // 添加淡入动画
            const content = document.getElementById('content');
            if (content) {
                content.style.opacity = '0';
                content.style.transition = 'opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 100);
            }
            
            // 图片延迟加载和动画
            const images = document.querySelectorAll('img');
            images.forEach((img, index) => {
                img.loading = 'lazy';
                img.style.opacity = '0';
                img.style.transform = 'translateY(20px)';
                img.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                
                // 图片加载完成后显示
                if (img.complete) {
                    setTimeout(() => {
                        img.style.opacity = '1';
                        img.style.transform = 'translateY(0)';
                    }, 100 * (index + 1));
                } else {
                    img.addEventListener('load', () => {
                        setTimeout(() => {
                            img.style.opacity = '1';
                            img.style.transform = 'translateY(0)';
                        }, 100);
                    });
                }
            });
            
            // 代码块增强
            const codeBlocks = document.querySelectorAll('pre');
            codeBlocks.forEach(block => {
                // 添加语言标识
                const code = block.querySelector('code');
                if (code && code.className) {
                    const lang = code.className.replace('language-', '');
                    if (lang) {
                        block.setAttribute('data-language', lang.toUpperCase());
                    }
                }
            });
            
            // 表格增强
            const tables = document.querySelectorAll('table');
            tables.forEach(table => {
                // 添加响应式包装
                const wrapper = document.createElement('div');
                wrapper.style.overflowX = 'auto';
                wrapper.style.marginBottom = '20px';
                table.parentNode.insertBefore(wrapper, table);
                wrapper.appendChild(table);
            });
            
            // 确保内容不超出
            function ensureContentFit() {
                const card = document.querySelector('.card');
                const content = document.querySelector('.content');
                if (card && content) {
                    content.style.maxHeight = '100%';
                    content.style.overflow = 'hidden';
                }
            }
            
            ensureContentFit();
            window.addEventListener('resize', ensureContentFit);
        });
        
        // 禁用所有滚动
        window.addEventListener('scroll', function(e) {
            e.preventDefault();
            window.scrollTo(0, 0);
        }, { passive: false });
        
        window.addEventListener('wheel', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        window.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
        """ markdown_processor.py->text/plain-># ============================================
# src/core/markdown_processor.py
# ============================================
import markdown
from markdown.extensions import fenced_code, tables
import re
import uuid

class TaskListExtension(markdown.Extension):
    """自定义任务列表扩展"""
    
    def extendMarkdown(self, md):
        # 提高优先级到 100，确保在列表处理之前执行
        md.preprocessors.register(TaskListPreprocessor(md), 'tasklist', 100)
        md.postprocessors.register(TaskListPostprocessor(md), 'tasklist', 25)

class TaskListPreprocessor(markdown.preprocessors.Preprocessor):
    """预处理器：标记任务列表项"""
    
    TASK_PATTERN = re.compile(r'^(\s*)([-\*\+])\s+\[([ xX])\]\s+(.*)$')
    
    def run(self, lines):
        new_lines = []
        for line in lines:
            match = self.TASK_PATTERN.match(line)
            if match:
                indent, marker, checked, text = match.groups()
                # 将任务列表转换为特殊标记，避免被普通列表处理干扰
                checked_mark = 'checked' if checked.lower() == 'x' else 'unchecked'
                # 使用特殊的HTML注释包裹，确保Markdown解析器不会破坏它
                new_line = f"{indent}{marker} <!--tasklist-{checked_mark}--> {text}"
                new_lines.append(new_line)
            else:
                new_lines.append(line)
        return new_lines

class TaskListPostprocessor(markdown.postprocessors.Postprocessor):
    """后处理器：将标记转换为HTML复选框"""
    
    def run(self, text):
        # 替换已选中的任务
        text = re.sub(
            r'<li><!--tasklist-checked-->\s*(.*?)</li>',
            r'<li class="task-list-item"><input type="checkbox" class="task-list-checkbox" checked disabled> \1</li>',
            text,
            flags=re.DOTALL
        )
        
        # 替换未选中的任务
        text = re.sub(
            r'<li><!--tasklist-unchecked-->\s*(.*?)</li>',
            r'<li class="task-list-item"><input type="checkbox" class="task-list-checkbox" disabled> \1</li>',
            text,
            flags=re.DOTALL
        )
        
        # 为包含任务列表的ul/ol添加class
        text = re.sub(
            r'<(ul|ol)>(\s*<li class="task-list-item">)',
            r'<\1 class="task-list">\2',
            text
        )
        
        return text

class MarkdownProcessor:
    def __init__(self):
        # 使用必要且稳定的扩展
        self.extensions = [
            TaskListExtension(),                # 放到最前面，优先处理任务列表
            'markdown.extensions.fenced_code',
            'markdown.extensions.tables',
            'markdown.extensions.nl2br',
            'markdown.extensions.attr_list',
            'markdown.extensions.def_list',
            'markdown.extensions.footnotes',
            'markdown.extensions.toc',
            'markdown.extensions.sane_lists',   # 放到任务列表扩展之后
            'markdown.extensions.smarty',
        ]
        
        # 配置扩展
        self.extension_configs = {}
        
    def parse(self, text: str) -> str:
        """解析 Markdown 文本为 HTML"""
        try:
            # 1. 首先处理分页标记，将其转换为特殊的 HTML 标记
            text = self._process_pagebreaks_before_markdown(text)
            
            # 2. 创建新的 Markdown 实例（避免状态污染）
            md = markdown.Markdown(
                extensions=self.extensions,
                extension_configs=self.extension_configs
            )
            
            # 3. 转换 Markdown 为 HTML
            html = md.convert(text)
            
            # 4. 后处理：添加小红书特色 emoji 支持
            html = self._process_emojis(html)
            
            # 5. 添加任务列表的样式支持
            html = self._add_tasklist_styles(html)
            
            return html
            
        except Exception as e:
            print(f"Markdown 解析错误: {e}")
            return f"<p style='color: red;'>解析错误: {str(e)}</p>"
    
    def _process_pagebreaks_before_markdown(self, text: str) -> str:
        """
        在 Markdown 解析之前处理分页标记
        直接将 <!-- pagebreak --> 替换为特殊的 HTML div
        """
        # 匹配 HTML 注释形式的分页标记（支持大小写和空格变化）
        pattern = r'<!--\s*pagebreak\s*-->'
        
        # 直接替换为 HTML div（这个 div 不会被 Markdown 解析器改变）
        replacement = '\n\n<div class="pagebreak-marker" data-pagebreak="true"></div>\n\n'
        
        # 执行替换
        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)
        
        return text
    
    def _process_emojis(self, html: str) -> str:
        """处理 emoji 表情"""
        # 保持 emoji 原样显示
        return html
    
    def _add_tasklist_styles(self, html: str) -> str:
        """添加任务列表的内联样式"""
        # 如果HTML中包含任务列表，添加样式
        if 'task-list' in html:
            style = """
            <style>
                .task-list {
                    list-style-type: none;
                    padding-left: 0;
                }
                
                .task-list-item {
                    list-style-type: none;
                    margin-left: 0;
                    padding-left: 0;
                    position: relative;
                }
                
                .task-list-checkbox {
                    margin-right: 8px;
                    margin-left: 0;
                    vertical-align: middle;
                    position: relative;
                    top: -1px;
                    cursor: default;
                    width: 16px;
                    height: 16px;
                    accent-color: var(--primary-color, #FF2442);
                }
                
                .task-list-item + .task-list-item {
                    margin-top: 8px;
                }
                
                /* 美化复选框样式 */
                .task-list-checkbox:checked::before {
                    content: '✓';
                    position: absolute;
                    color: var(--primary-color, #FF2442);
                    font-weight: bold;
                    font-size: 12px;
                    left: 2px;
                    top: -2px;
                }
            </style>
            """
            # 将样式插入到HTML开头
            html = style + html
        
        return html style_manager.py->text/plain->
### 系统:
看了您的代码，我发现 `markdown_processor.py` 确实存在一些问题：

## 主要问题分析

1. **任务列表扩展过于复杂**：使用预处理器+后处理器容易与其他扩展冲突
2. **分页标记处理不够健壮**：可能被 Markdown 解析器破坏
3. **扩展加载顺序问题**：可能导致解析冲突
4. **缺少对特殊情况的处理**：如嵌套结构、混合内容等

## 解决方案

由于改动较大，我提供完整的优化版本。主要改进：
- 使用 `mistune` 替代 `python-markdown`（更快更稳定）
- 简化任务列表处理
- 改进分页标记保护机制
- 增强错误处理

### 完整的 `markdown_processor.py` 优化版本：

```python
# ============================================
# src/core/markdown_processor.py - 优化版
# ============================================
import re
import html
from typing import Optional, Dict, Any
import mistune
from mistune import HTMLRenderer, BlockParser, InlineParser, Markdown
from mistune.plugins import plugin_task_lists, plugin_table, plugin_footnotes, plugin_strikethrough
from mistune.plugins import plugin_def_list, plugin_abbr, plugin_mark, plugin_insert, plugin_superscript
from mistune.plugins import plugin_subscript, plugin_math, plugin_spoiler
import uuid

class XiaohongshuRenderer(HTMLRenderer):
    """小红书风格的 HTML 渲染器"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.pagebreak_markers = []  # 存储分页标记位置
        
    def heading(self, text: str, level: int, **attrs) -> str:
        """自定义标题渲染"""
        # 添加锚点支持
        anchor_id = re.sub(r'[^\w\u4e00-\u9fff-]', '-', text.lower())
        
        # 根据级别添加不同的类
        level_class = f"heading-{level}"
        
        # 对一级标题添加特殊装饰
        if level == 1:
            return f'<h{level} id="{anchor_id}" class="{level_class} heading-decorated">{text}</h{level}>\n'
        
        return f'<h{level} id="{anchor_id}" class="{level_class}">{text}</h{level}>\n'
    
    def list(self, text: str, ordered: bool, **attrs) -> str:
        """自定义列表渲染"""
        tag = 'ol' if ordered else 'ul'
        
        # 检查是否包含任务列表项
        if 'task-list-item' in text:
            return f'<{tag} class="task-list">\n{text}</{tag}>\n'
        
        # 普通列表添加样式类
        list_class = 'ordered-list' if ordered else 'unordered-list'
        return f'<{tag} class="{list_class}">\n{text}</{tag}>\n'
    
    def list_item(self, text: str, **attrs) -> str:
        """自定义列表项渲染"""
        # 任务列表项处理（由插件处理）
        if text.startswith('<input class="task-list-item-checkbox"'):
            return f'<li class="task-list-item">{text}</li>\n'
        
        return f'<li>{text}</li>\n'
    
    def block_code(self, code: str, info: Optional[str] = None) -> str:
        """自定义代码块渲染"""
        code = html.escape(code)
        
        # 提取语言信息
        lang = ''
        if info:
            info = info.strip()
            if info:
                lang = info.split()[0]
        
        # 添加语言标识和行号支持
        if lang:
            # 添加行号
            lines = code.split('\n')
            if len(lines) > 1:
                code_with_lines = self._add_line_numbers(code)
                return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code_with_lines}</code></pre>\n'
            else:
                return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code}</code></pre>\n'
        
        return f'<pre class="code-block"><code>{code}</code></pre>\n'
    
    def _add_line_numbers(self, code: str) -> str:
        """为代码添加行号"""
        lines = code.split('\n')
        # 只对超过3行的代码块添加行号
        if len(lines) <= 3:
            return code
            
        result = []
        for i, line in enumerate(lines, 1):
            # 使用 span 包装每一行，方便 CSS 处理
            result.append(f'<span class="code-line" data-line-number="{i}">{line}</span>')
        return '\n'.join(result)
    
    def link(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义链接渲染"""
        # 检查是否为外部链接
        is_external = url.startswith(('http://', 'https://', '//'))
        
        # 构建属性
        attrs = []
        if title:
            attrs.append(f'title="{html.escape(title)}"')
        
        if is_external:
            attrs.append('target="_blank"')
            attrs.append('rel="noopener noreferrer"')
            attrs.append('class="external-link"')
        else:
            attrs.append('class="internal-link"')
        
        attrs_str = ' '.join(attrs)
        if attrs_str:
            return f'<a href="{url}" {attrs_str}>{text}</a>'
        
        return f'<a href="{url}">{text}</a>'
    
    def image(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义图片渲染"""
        # 构建图片标签
        alt_text = html.escape(text or '')
        
        # 添加懒加载和响应式支持
        img_attrs = [
            f'src="{url}"',
            f'alt="{alt_text}"',
            'loading="lazy"',
            'class="content-image"'
        ]
        
        if title:
            img_attrs.append(f'title="{html.escape(title)}"')
        
        img_tag = f'<img {" ".join(img_attrs)} />'
        
        # 包装在 figure 中，支持图片说明
        if text:
            return f'''<figure class="image-container">
                {img_tag}
                <figcaption>{text}</figcaption>
            </figure>\n'''
        
        return f'<figure class="image-container">{img_tag}</figure>\n'
    
    def table(self, text: str) -> str:
        """自定义表格渲染"""
        # 添加响应式包装
        return f'''<div class="table-container">
            <table class="content-table">
                {text}
            </table>
        </div>\n'''
    
    def block_quote(self, text: str) -> str:
        """自定义引用块渲染"""
        return f'<blockquote class="quote-block">{text}</blockquote>\n'
    
    def block_html(self, html: str) -> str:
        """处理原始 HTML"""
        # 保护分页标记
        if 'pagebreak-marker' in html or 'data-pagebreak' in html:
            # 生成唯一ID并保存
            marker_id = f"PAGEBREAK_{uuid.uuid4().hex}"
            self.pagebreak_markers.append((marker_id, html))
            return f"<!--{marker_id}-->"
        
        return html
    
    def inline_html(self, html: str) -> str:
        """处理内联 HTML"""
        # 允许某些安全的内联 HTML
        allowed_tags = ['span', 'em', 'strong', 'mark', 'del', 'ins', 'sub', 'sup']
        
        # 简单的标签检查
        tag_match = re.match(r'<(/?)(\w+)(?:\s[^>]*)?>.*?(?:</\2>)?', html)
        if tag_match:
            tag_name = tag_match.group(2).lower()
            if tag_name in allowed_tags:
                return html
        
        # 其他 HTML 转义
        return html.escape(html)

class PagebreakPlugin:
    """分页标记插件"""
    
    @staticmethod
    def plugin_pagebreak(md: Markdown):
        """注册分页标记处理"""
        
        def parse_pagebreak(block, m, state):
            """解析分页标记"""
            return {'type': 'pagebreak'}
        
        def render_pagebreak(renderer, text=None):
            """渲染分页标记"""
            return '<div class="pagebreak-marker" data-pagebreak="true"></div>\n'
        
        # 注册块级规则
        md.block.register(
            'pagebreak',
            r'^<!--\s*pagebreak\s*-->\s*$',
            parse_pagebreak,
            before='paragraph'
        )
        
        # 注册渲染器
        if md.renderer:
            md.renderer.register('pagebreak', render_pagebreak)

class MarkdownProcessor:
    """优化的 Markdown 处理器"""
    
    def __init__(self):
        """初始化 Markdown 处理器"""
        # 创建自定义渲染器
        self.renderer = XiaohongshuRenderer(escape=False)
        
        # 创建 Markdown 实例并加载插件
        self.markdown = mistune.create_markdown(
            renderer=self.renderer,
            plugins=[
                plugin_task_lists,      # 任务列表
                plugin_table,           # 表格
                plugin_footnotes,       # 脚注
                plugin_strikethrough,   # 删除线
                plugin_def_list,        # 定义列表
                plugin_mark,            # 高亮标记
                plugin_insert,          # 插入文本
                plugin_superscript,     # 上标
                plugin_subscript,       # 下标
                PagebreakPlugin.plugin_pagebreak,  # 分页标记
                'url',                  # URL 自动链接
                'abbr',                 # 缩写
            ]
        )
        
        # 预编译的正则表达式
        self._emoji_pattern = re.compile(r':(\w+):')
        self._mention_pattern = re.compile(r'@(\w+)')
        self._hashtag_pattern = re.compile(r'#(\w+)')
        
    def parse(self, text: str) -> str:
        """
        解析 Markdown 文本为 HTML
        
        Args:
            text: Markdown 文本
            
        Returns:
            HTML 字符串
        """
        try:
            # 1. 预处理：保护特殊内容
            text = self._preprocess(text)
            
            # 2. 解析 Markdown
            html = self.markdown(text)
            
            # 3. 后处理：恢复分页标记，添加小红书特色
            html = self._postprocess(html)
            
            # 4. 添加必要的样式
            html = self._add_styles(html)
            
            return html
            
        except Exception as e:
            # 详细的错误信息
            import traceback
            error_details = traceback.format_exc()
            print(f"Markdown 解析错误:\n{error_details}")
            
            # 返回错误提示
            return f'''
            <div class="parse-error">
                <h3>⚠️ 解析错误</h3>
                <p>Markdown 解析过程中出现错误：</p>
                <pre>{html.escape(str(e))}</pre>
                <details>
                    <summary>详细信息</summary>
                    <pre>{html.escape(error_details)}</pre>
                </details>
            </div>
            '''
    
    def _preprocess(self, text: str) -> str:
        """预处理文本"""
        # 1. 规范化换行符
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        
        # 2. 保护代码块中的特殊字符
        text = self._protect_code_blocks(text)
        
        # 3. 处理小红书特色语法（如 @提及、#话题）
        # 暂时注释掉，避免与 Markdown 语法冲突
        # text = self._process_xiaohongshu_syntax(text)
        
        return text
    
    def _protect_code_blocks(self, text: str) -> str:
        """保护代码块中的内容"""
        # 使用更健壮的代码块匹配
        code_blocks = []
        
        # 匹配围栏代码块
        fence_pattern = re.compile(r'^```[\s\S]*?^```', re.MULTILINE)
        
        def replace_fence(match):
            code_blocks.append(match.group(0))
            return f"<!--CODE_BLOCK_{len(code_blocks)-1}-->"
        
        text = fence_pattern.sub(replace_fence, text)
        
        # 匹配缩进代码块
        indent_pattern = re.compile(r'^(?: {4}|\t).*$', re.MULTILINE)
        
        # 恢复代码块
        for i, code in enumerate(code_blocks):
            text = text.replace(f"<!--CODE_BLOCK_{i}-->", code)
        
        return text
    
    def _postprocess(self, html: str) -> str:
        """后处理 HTML"""
        # 1. 恢复分页标记
        if hasattr(self.renderer, 'pagebreak_markers'):
            for marker_id, marker_html in self.renderer.pagebreak_markers:
                html = html.replace(f"<!--{marker_id}-->", marker_html)
        
        # 2. 处理 emoji（将 :emoji: 转换为实际 emoji）
        html = self._process_emojis(html)
        
        # 3. 增强链接（添加图标等）
        html = self._enhance_links(html)
        
        # 4. 优化图片（添加加载动画等）
        html = self._enhance_images(html)
        
        return html
    
    def _process_emojis(self, html: str) -> str:
        """处理 emoji 表情"""
        # 常用 emoji 映射
        emoji_map = {
            'smile': '😊',
            'heart': '❤️',
            'star': '⭐',
            'fire': '🔥',
            'thumbs_up': '👍',
            'celebration': '🎉',
            'rocket': '🚀',
            'check': '✅',
            'cross': '❌',
            'warning': '⚠️',
            'info': 'ℹ️',
            'question': '❓',
            'bulb': '💡',
            'book': '📚',
            'code': '💻',
            'bug': '🐛',
            'gift': '🎁',
            'coffee': '☕',
            'pizza': '🍕',
            'beer': '🍺',
        }
        
        def replace_emoji(match):
            emoji_name = match.group(1)
            return emoji_map.get(emoji_name, match.group(0))
        
        # 只在非 HTML 标签内替换
        parts = re.split(r'(<[^>]+>)', html)
        for i, part in enumerate(parts):
            if not part.startswith('<'):
                parts[i] = self._emoji_pattern.sub(replace_emoji, part)
        
        return ''.join(parts)
    
    def _enhance_links(self, html: str) -> str:
        """增强链接显示"""
        # 为外部链接添加图标
        html = re.sub(
            r'<a ([^>]*class="external-link"[^>]*)>',
            r'<a \1><span class="link-icon">🔗</span> ',
            html
        )
        
        return html
    
    def _enhance_images(self, html: str) -> str:
        """增强图片显示"""
        # 为图片添加占位符和加载状态
        def enhance_img(match):
            img_tag = match.group(0)
            # 添加 data 属性用于延迟加载
            if 'data-src' not in img_tag:
                img_tag = img_tag.replace('src=', 'data-src=')
                img_tag = img_tag.replace('<img ', '<img src="data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 1080 1440\'%3E%3Crect fill=\'%23f0f0f0\'/%3E%3C/svg%3E" ')
            
            return img_tag
        
        # 暂时禁用，避免影响正常显示
        # html = re.sub(r'<img [^>]+>', enhance_img, html)
        
        return html
    
    def _add_styles(self, html: str) -> str:
        """添加必要的内联样式"""
        # 检查是否包含特定元素，添加对应样式
        styles = []
        
        if 'task-list' in html:
            styles.append(self._get_tasklist_styles())
        
        if 'code-block' in html:
            styles.append(self._get_codeblock_styles())
        
        if 'content-table' in html:
            styles.append(self._get_table_styles())
        
        if styles:
            style_tag = f"<style>\n{' '.join(styles)}\n</style>\n"
            html = style_tag + html
        
        return html
    
    def _get_tasklist_styles(self) -> str:
        """获取任务列表样式"""
        return """
        /* 任务列表样式 */
        .task-list {
            list-style: none;
            padding-left: 0;
        }
        
        .task-list-item {
            position: relative;
            padding-left: 28px;
            margin-bottom: 8px;
        }
        
        .task-list-item-checkbox {
            position: absolute;
            left: 0;
            top: 4px;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-color, #FF2442);
            border-radius: 4px;
            background: white;
            cursor: not-allowed;
        }
        
        .task-list-item-checkbox:checked {
            background: var(--primary-color, #FF2442);
            border-color: var(--primary-color, #FF2442);
        }
        
        .task-list-item-checkbox:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            left: 2px;
            top: -2px;
        }
        """
    
    def _get_codeblock_styles(self) -> str:
        """获取代码块样式"""
        return """
        /* 代码块样式 */
        .code-block {
            position: relative;
            background: #1e1e1e;
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .code-line {
            display: block;
            position: relative;
            padding-left: 40px;
        }
        
        .code-line::before {
            content: attr(data-line-number);
            position: absolute;
            left: 8px;
            color: #666;
            font-size: 12px;
            user-select: none;
        }
        """
    
    def _get_table_styles(self) -> str:
        """获取表格样式"""
        return """
        /* 表格样式 */
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        
        .content-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .content-table th {
            background: linear-gradient(135deg, var(--primary-color, #FF2442), var(--secondary-color, #FF6B6B));
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .content-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        
        .content-table tr:hover {
            background: rgba(255, 36, 66, 0.05);
        }
        """
    
    def validate(self, text: str) -> tuple[bool, list[str]]:
        """
        验证 Markdown 文本
        
        Returns:
            (是否有效, 错误列表)
        """
        errors = []
        
        # 检查未闭合的代码块
        fence_count = text.count('```')
        if fence_count % 2 != 0:
            errors.append("存在未闭合的代码块")
        
        # 检查未闭合的链接
        link_open = text.count('[')
        link_close = text.count(']')
        if link_open != link_close:
            errors.append("存在未闭合的链接语法")
        
        # 检查过长的行
        lines = text.split('\n')
        for i, line in enumerate(lines, 1):
            if len(line) > 1000:
                errors.append(f"第 {i} 行过长（超过1000字符）")
        
        return len(errors) == 0, errors

# 创建全局实例
markdown_processor = MarkdownProcessor()
```

## 同时需要安装新依赖

在 `requirements.txt` 中添加：
```
mistune>=3.0.0
```

## 主要改进点

1. **更稳定的解析器**：使用 `mistune` 替代 `python-markdown`
2. **简化的任务列表**：直接使用 mistune 内置插件
3. **更好的分页标记保护**：使用 UUID 标记替换机制
4. **增强的错误处理**：详细的错误信息和验证功能
5. **小红书特色支持**：emoji、外链图标等
6. **代码块增强**：行号、语言标识
7. **性能优化**：预编译正则表达式

这个优化版本应该能解决大部分 Markdown 解析问题，提供更稳定可靠的渲染效果。
### 用户:
为何报错：
(card) PS E:\wayForward\projects\RedBookCards> python main.py
Traceback (most recent call last):
  File "E:\wayForward\projects\RedBookCards\main.py", line 5, in <module>
    from src.ui.main_window import MainWindow
  File "E:\wayForward\projects\RedBookCards\src\ui\main_window.py", line 13, in <module>
    from src.ui.preview_widget import PreviewWidget
  File "E:\wayForward\projects\RedBookCards\src\ui\preview_widget.py", line 12, in <module>
    from src.core.markdown_processor import MarkdownProcessor
  File "E:\wayForward\projects\RedBookCards\src\core\markdown_processor.py", line 9, in <module>
    from mistune.plugins import plugin_task_lists, plugin_table, plugin_footnotes, plugin_strikethrough
ImportError: cannot import name 'plugin_task_lists' from 'mistune.plugins' (D:\Anaconda3\envs\card\lib\site-packages\mistune\plugins\__init__.py)
paste.txt->txt-># ============================================
# src/core/markdown_processor.py - 优化版
# ============================================
import re
import html
from typing import Optional, Dict, Any
import mistune
from mistune import HTMLRenderer, BlockParser, InlineParser, Markdown
from mistune.plugins import plugin_task_lists, plugin_table, plugin_footnotes, plugin_strikethrough
from mistune.plugins import plugin_def_list, plugin_abbr, plugin_mark, plugin_insert, plugin_superscript
from mistune.plugins import plugin_subscript, plugin_math, plugin_spoiler
import uuid

class XiaohongshuRenderer(HTMLRenderer):
    """小红书风格的 HTML 渲染器"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.pagebreak_markers = []  # 存储分页标记位置
        
    def heading(self, text: str, level: int, **attrs) -> str:
        """自定义标题渲染"""
        # 添加锚点支持
        anchor_id = re.sub(r'[^\w\u4e00-\u9fff-]', '-', text.lower())
        
        # 根据级别添加不同的类
        level_class = f"heading-{level}"
        
        # 对一级标题添加特殊装饰
        if level == 1:
            return f'<h{level} id="{anchor_id}" class="{level_class} heading-decorated">{text}</h{level}>\n'
        
        return f'<h{level} id="{anchor_id}" class="{level_class}">{text}</h{level}>\n'
    
    def list(self, text: str, ordered: bool, **attrs) -> str:
        """自定义列表渲染"""
        tag = 'ol' if ordered else 'ul'
        
        # 检查是否包含任务列表项
        if 'task-list-item' in text:
            return f'<{tag} class="task-list">\n{text}</{tag}>\n'
        
        # 普通列表添加样式类
        list_class = 'ordered-list' if ordered else 'unordered-list'
        return f'<{tag} class="{list_class}">\n{text}</{tag}>\n'
    
    def list_item(self, text: str, **attrs) -> str:
        """自定义列表项渲染"""
        # 任务列表项处理（由插件处理）
        if text.startswith('<input class="task-list-item-checkbox"'):
            return f'<li class="task-list-item">{text}</li>\n'
        
        return f'<li>{text}</li>\n'
    
    def block_code(self, code: str, info: Optional[str] = None) -> str:
        """自定义代码块渲染"""
        code = html.escape(code)
        
        # 提取语言信息
        lang = ''
        if info:
            info = info.strip()
            if info:
                lang = info.split()[0]
        
        # 添加语言标识和行号支持
        if lang:
            # 添加行号
            lines = code.split('\n')
            if len(lines) > 1:
                code_with_lines = self._add_line_numbers(code)
                return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code_with_lines}</code></pre>\n'
            else:
                return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code}</code></pre>\n'
        
        return f'<pre class="code-block"><code>{code}</code></pre>\n'
    
    def _add_line_numbers(self, code: str) -> str:
        """为代码添加行号"""
        lines = code.split('\n')
        # 只对超过3行的代码块添加行号
        if len(lines) <= 3:
            return code
            
        result = []
        for i, line in enumerate(lines, 1):
            # 使用 span 包装每一行，方便 CSS 处理
            result.append(f'<span class="code-line" data-line-number="{i}">{line}</span>')
        return '\n'.join(result)
    
    def link(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义链接渲染"""
        # 检查是否为外部链接
        is_external = url.startswith(('http://', 'https://', '//'))
        
        # 构建属性
        attrs = []
        if title:
            attrs.append(f'title="{html.escape(title)}"')
        
        if is_external:
            attrs.append('target="_blank"')
            attrs.append('rel="noopener noreferrer"')
            attrs.append('class="external-link"')
        else:
            attrs.append('class="internal-link"')
        
        attrs_str = ' '.join(attrs)
        if attrs_str:
            return f'<a href="{url}" {attrs_str}>{text}</a>'
        
        return f'<a href="{url}">{text}</a>'
    
    def image(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义图片渲染"""
        # 构建图片标签
        alt_text = html.escape(text or '')
        
        # 添加懒加载和响应式支持
        img_attrs = [
            f'src="{url}"',
            f'alt="{alt_text}"',
            'loading="lazy"',
            'class="content-image"'
        ]
        
        if title:
            img_attrs.append(f'title="{html.escape(title)}"')
        
        img_tag = f'<img {" ".join(img_attrs)} />'
        
        # 包装在 figure 中，支持图片说明
        if text:
            return f'''<figure class="image-container">
                {img_tag}
                <figcaption>{text}</figcaption>
            </figure>\n'''
        
        return f'<figure class="image-container">{img_tag}</figure>\n'
    
    def table(self, text: str) -> str:
        """自定义表格渲染"""
        # 添加响应式包装
        return f'''<div class="table-container">
            <table class="content-table">
                {text}
            </table>
        </div>\n'''
    
    def block_quote(self, text: str) -> str:
        """自定义引用块渲染"""
        return f'<blockquote class="quote-block">{text}</blockquote>\n'
    
    def block_html(self, html: str) -> str:
        """处理原始 HTML"""
        # 保护分页标记
        if 'pagebreak-marker' in html or 'data-pagebreak' in html:
            # 生成唯一ID并保存
            marker_id = f"PAGEBREAK_{uuid.uuid4().hex}"
            self.pagebreak_markers.append((marker_id, html))
            return f"<!--{marker_id}-->"
        
        return html
    
    def inline_html(self, html: str) -> str:
        """处理内联 HTML"""
        # 允许某些安全的内联 HTML
        allowed_tags = ['span', 'em', 'strong', 'mark', 'del', 'ins', 'sub', 'sup']
        
        # 简单的标签检查
        tag_match = re.match(r'<(/?)(\w+)(?:\s[^>]*)?>.*?(?:</\2>)?', html)
        if tag_match:
            tag_name = tag_match.group(2).lower()
            if tag_name in allowed_tags:
                return html
        
        # 其他 HTML 转义
        return html.escape(html)

class PagebreakPlugin:
    """分页标记插件"""
    
    @staticmethod
    def plugin_pagebreak(md: Markdown):
        """注册分页标记处理"""
        
        def parse_pagebreak(block, m, state):
            """解析分页标记"""
            return {'type': 'pagebreak'}
        
        def render_pagebreak(renderer, text=None):
            """渲染分页标记"""
            return '<div class="pagebreak-marker" data-pagebreak="true"></div>\n'
        
        # 注册块级规则
        md.block.register(
            'pagebreak',
            r'^<!--\s*pagebreak\s*-->\s*$',
            parse_pagebreak,
            before='paragraph'
        )
        
        # 注册渲染器
        if md.renderer:
            md.renderer.register('pagebreak', render_pagebreak)

class MarkdownProcessor:
    """优化的 Markdown 处理器"""
    
    def __init__(self):
        """初始化 Markdown 处理器"""
        # 创建自定义渲染器
        self.renderer = XiaohongshuRenderer(escape=False)
        
        # 创建 Markdown 实例并加载插件
        self.markdown = mistune.create_markdown(
            renderer=self.renderer,
            plugins=[
                plugin_task_lists,      # 任务列表
                plugin_table,           # 表格
                plugin_footnotes,       # 脚注
                plugin_strikethrough,   # 删除线
                plugin_def_list,        # 定义列表
                plugin_mark,            # 高亮标记
                plugin_insert,          # 插入文本
                plugin_superscript,     # 上标
                plugin_subscript,       # 下标
                PagebreakPlugin.plugin_pagebreak,  # 分页标记
                'url',                  # URL 自动链接
                'abbr',                 # 缩写
            ]
        )
        
        # 预编译的正则表达式
        self._emoji_pattern = re.compile(r':(\w+):')
        self._mention_pattern = re.compile(r'@(\w+)')
        self._hashtag_pattern = re.compile(r'#(\w+)')
        
    def parse(self, text: str) -> str:
        """
        解析 Markdown 文本为 HTML
        
        Args:
            text: Markdown 文本
            
        Returns:
            HTML 字符串
        """
        try:
            # 1. 预处理：保护特殊内容
            text = self._preprocess(text)
            
            # 2. 解析 Markdown
            html = self.markdown(text)
            
            # 3. 后处理：恢复分页标记，添加小红书特色
            html = self._postprocess(html)
            
            # 4. 添加必要的样式
            html = self._add_styles(html)
            
            return html
            
        except Exception as e:
            # 详细的错误信息
            import traceback
            error_details = traceback.format_exc()
            print(f"Markdown 解析错误:\n{error_details}")
            
            # 返回错误提示
            return f'''
            <div class="parse-error">
                <h3>⚠️ 解析错误</h3>
                <p>Markdown 解析过程中出现错误：</p>
                <pre>{html.escape(str(e))}</pre>
                <details>
                    <summary>详细信息</summary>
                    <pre>{html.escape(error_details)}</pre>
                </details>
            </div>
            '''
    
    def _preprocess(self, text: str) -> str:
        """预处理文本"""
        # 1. 规范化换行符
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        
        # 2. 保护代码块中的特殊字符
        text = self._protect_code_blocks(text)
        
        # 3. 处理小红书特色语法（如 @提及、#话题）
        # 暂时注释掉，避免与 Markdown 语法冲突
        # text = self._process_xiaohongshu_syntax(text)
        
        return text
    
    def _protect_code_blocks(self, text: str) -> str:
        """保护代码块中的内容"""
        # 使用更健壮的代码块匹配
        code_blocks = []
        
        # 匹配围栏代码块
        fence_pattern = re.compile(r'^```[\s\S]*?^```', re.MULTILINE)
        
        def replace_fence(match):
            code_blocks.append(match.group(0))
            return f"<!--CODE_BLOCK_{len(code_blocks)-1}-->"
        
        text = fence_pattern.sub(replace_fence, text)
        
        # 匹配缩进代码块
        indent_pattern = re.compile(r'^(?: {4}|\t).*$', re.MULTILINE)
        
        # 恢复代码块
        for i, code in enumerate(code_blocks):
            text = text.replace(f"<!--CODE_BLOCK_{i}-->", code)
        
        return text
    
    def _postprocess(self, html: str) -> str:
        """后处理 HTML"""
        # 1. 恢复分页标记
        if hasattr(self.renderer, 'pagebreak_markers'):
            for marker_id, marker_html in self.renderer.pagebreak_markers:
                html = html.replace(f"<!--{marker_id}-->", marker_html)
        
        # 2. 处理 emoji（将 :emoji: 转换为实际 emoji）
        html = self._process_emojis(html)
        
        # 3. 增强链接（添加图标等）
        html = self._enhance_links(html)
        
        # 4. 优化图片（添加加载动画等）
        html = self._enhance_images(html)
        
        return html
    
    def _process_emojis(self, html: str) -> str:
        """处理 emoji 表情"""
        # 常用 emoji 映射
        emoji_map = {
            'smile': '😊',
            'heart': '❤️',
            'star': '⭐',
            'fire': '🔥',
            'thumbs_up': '👍',
            'celebration': '🎉',
            'rocket': '🚀',
            'check': '✅',
            'cross': '❌',
            'warning': '⚠️',
            'info': 'ℹ️',
            'question': '❓',
            'bulb': '💡',
            'book': '📚',
            'code': '💻',
            'bug': '🐛',
            'gift': '🎁',
            'coffee': '☕',
            'pizza': '🍕',
            'beer': '🍺',
        }
        
        def replace_emoji(match):
            emoji_name = match.group(1)
            return emoji_map.get(emoji_name, match.group(0))
        
        # 只在非 HTML 标签内替换
        parts = re.split(r'(<[^>]+>)', html)
        for i, part in enumerate(parts):
            if not part.startswith('<'):
                parts[i] = self._emoji_pattern.sub(replace_emoji, part)
        
        return ''.join(parts)
    
    def _enhance_links(self, html: str) -> str:
        """增强链接显示"""
        # 为外部链接添加图标
        html = re.sub(
            r'<a ([^>]*class="external-link"[^>]*)>',
            r'<a \1><span class="link-icon">🔗</span> ',
            html
        )
        
        return html
    
    def _enhance_images(self, html: str) -> str:
        """增强图片显示"""
        # 为图片添加占位符和加载状态
        def enhance_img(match):
            img_tag = match.group(0)
            # 添加 data 属性用于延迟加载
            if 'data-src' not in img_tag:
                img_tag = img_tag.replace('src=', 'data-src=')
                img_tag = img_tag.replace('<img ', '<img src="data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 1080 1440\'%3E%3Crect fill=\'%23f0f0f0\'/%3E%3C/svg%3E" ')
            
            return img_tag
        
        # 暂时禁用，避免影响正常显示
        # html = re.sub(r'<img [^>]+>', enhance_img, html)
        
        return html
    
    def _add_styles(self, html: str) -> str:
        """添加必要的内联样式"""
        # 检查是否包含特定元素，添加对应样式
        styles = []
        
        if 'task-list' in html:
            styles.append(self._get_tasklist_styles())
        
        if 'code-block' in html:
            styles.append(self._get_codeblock_styles())
        
        if 'content-table' in html:
            styles.append(self._get_table_styles())
        
        if styles:
            style_tag = f"<style>\n{' '.join(styles)}\n</style>\n"
            html = style_tag + html
        
        return html
    
    def _get_tasklist_styles(self) -> str:
        """获取任务列表样式"""
        return """
        /* 任务列表样式 */
        .task-list {
            list-style: none;
            padding-left: 0;
        }
        
        .task-list-item {
            position: relative;
            padding-left: 28px;
            margin-bottom: 8px;
        }
        
        .task-list-item-checkbox {
            position: absolute;
            left: 0;
            top: 4px;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-color, #FF2442);
            border-radius: 4px;
            background: white;
            cursor: not-allowed;
        }
        
        .task-list-item-checkbox:checked {
            background: var(--primary-color, #FF2442);
            border-color: var(--primary-color, #FF2442);
        }
        
        .task-list-item-checkbox:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            left: 2px;
            top: -2px;
        }
        """
    
    def _get_codeblock_styles(self) -> str:
        """获取代码块样式"""
        return """
        /* 代码块样式 */
        .code-block {
            position: relative;
            background: #1e1e1e;
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .code-line {
            display: block;
            position: relative;
            padding-left: 40px;
        }
        
        .code-line::before {
            content: attr(data-line-number);
            position: absolute;
            left: 8px;
            color: #666;
            font-size: 12px;
            user-select: none;
        }
        """
    
    def _get_table_styles(self) -> str:
        """获取表格样式"""
        return """
        /* 表格样式 */
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        
        .content-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .content-table th {
            background: linear-gradient(135deg, var(--primary-color, #FF2442), var(--secondary-color, #FF6B6B));
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .content-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        
        .content-table tr:hover {
            background: rgba(255, 36, 66, 0.05);
        }
        """
    
    def validate(self, text: str) -> tuple[bool, list[str]]:
        """
        验证 Markdown 文本
        
        Returns:
            (是否有效, 错误列表)
        """
        errors = []
        
        # 检查未闭合的代码块
        fence_count = text.count('```')
        if fence_count % 2 != 0:
            errors.append("存在未闭合的代码块")
        
        # 检查未闭合的链接
        link_open = text.count('[')
        link_close = text.count(']')
        if link_open != link_close:
            errors.append("存在未闭合的链接语法")
        
        # 检查过长的行
        lines = text.split('\n')
        for i, line in enumerate(lines, 1):
            if len(line) > 1000:
                errors.append(f"第 {i} 行过长（超过1000字符）")
        
        return len(errors) == 0, errors

# 创建全局实例
markdown_processor = MarkdownProcessor()
### 系统:
这是 `mistune` 3.x 版本的导入问题。插件的导入方式有所改变。让我提供修正后的代码：

## 修正后的 `markdown_processor.py`

```python
# ============================================
# src/core/markdown_processor.py - 修正版
# ============================================
import re
import html
from typing import Optional, Dict, Any, Tuple
import mistune
from mistune import HTMLRenderer, Markdown
import uuid

# 正确的插件导入方式
from mistune.plugins.task_lists import plugin as task_lists_plugin
from mistune.plugins.table import plugin as table_plugin
from mistune.plugins.footnotes import plugin as footnotes_plugin
from mistune.plugins.strikethrough import plugin as strikethrough_plugin
from mistune.plugins.def_list import plugin as def_list_plugin
from mistune.plugins.abbr import plugin as abbr_plugin
from mistune.plugins.mark import plugin as mark_plugin
from mistune.plugins.insert import plugin as insert_plugin
from mistune.plugins.superscript import plugin as superscript_plugin
from mistune.plugins.subscript import plugin as subscript_plugin
from mistune.plugins.url import plugin as url_plugin

class XiaohongshuRenderer(HTMLRenderer):
    """小红书风格的 HTML 渲染器"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.pagebreak_markers = []  # 存储分页标记位置
        
    def heading(self, text: str, level: int, **attrs) -> str:
        """自定义标题渲染"""
        # 添加锚点支持
        anchor_id = re.sub(r'[^\w\u4e00-\u9fff-]', '-', text.lower())
        
        # 根据级别添加不同的类
        level_class = f"heading-{level}"
        
        # 对一级标题添加特殊装饰
        if level == 1:
            return f'<h{level} id="{anchor_id}" class="{level_class} heading-decorated">{text}</h{level}>\n'
        
        return f'<h{level} id="{anchor_id}" class="{level_class}">{text}</h{level}>\n'
    
    def list(self, text: str, ordered: bool, **attrs) -> str:
        """自定义列表渲染"""
        tag = 'ol' if ordered else 'ul'
        
        # 检查是否包含任务列表项
        if 'task-list-item' in text:
            return f'<{tag} class="task-list">\n{text}</{tag}>\n'
        
        # 普通列表添加样式类
        list_class = 'ordered-list' if ordered else 'unordered-list'
        return f'<{tag} class="{list_class}">\n{text}</{tag}>\n'
    
    def list_item(self, text: str, **attrs) -> str:
        """自定义列表项渲染"""
        # 任务列表项处理（由插件处理）
        if 'task-list-item-checkbox' in text:
            return f'<li class="task-list-item">{text}</li>\n'
        
        return f'<li>{text}</li>\n'
    
    def block_code(self, code: str, info: Optional[str] = None) -> str:
        """自定义代码块渲染"""
        code = html.escape(code)
        
        # 提取语言信息
        lang = ''
        if info:
            info = info.strip()
            if info:
                lang = info.split()[0]
        
        # 添加语言标识和行号支持
        if lang:
            # 添加行号
            lines = code.split('\n')
            if len(lines) > 1:
                code_with_lines = self._add_line_numbers(code)
                return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code_with_lines}</code></pre>\n'
            else:
                return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code}</code></pre>\n'
        
        return f'<pre class="code-block"><code>{code}</code></pre>\n'
    
    def _add_line_numbers(self, code: str) -> str:
        """为代码添加行号"""
        lines = code.split('\n')
        # 只对超过3行的代码块添加行号
        if len(lines) <= 3:
            return code
            
        result = []
        for i, line in enumerate(lines, 1):
            # 使用 span 包装每一行，方便 CSS 处理
            result.append(f'<span class="code-line" data-line-number="{i}">{line}</span>')
        return '\n'.join(result)
    
    def link(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义链接渲染"""
        # 检查是否为外部链接
        is_external = url.startswith(('http://', 'https://', '//'))
        
        # 构建属性
        attrs = []
        if title:
            attrs.append(f'title="{html.escape(title)}"')
        
        if is_external:
            attrs.append('target="_blank"')
            attrs.append('rel="noopener noreferrer"')
            attrs.append('class="external-link"')
        else:
            attrs.append('class="internal-link"')
        
        attrs_str = ' '.join(attrs)
        if attrs_str:
            return f'<a href="{url}" {attrs_str}>{text}</a>'
        
        return f'<a href="{url}">{text}</a>'
    
    def image(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义图片渲染"""
        # 构建图片标签
        alt_text = html.escape(text or '')
        
        # 添加懒加载和响应式支持
        img_attrs = [
            f'src="{url}"',
            f'alt="{alt_text}"',
            'loading="lazy"',
            'class="content-image"'
        ]
        
        if title:
            img_attrs.append(f'title="{html.escape(title)}"')
        
        img_tag = f'<img {" ".join(img_attrs)} />'
        
        # 包装在 figure 中，支持图片说明
        if text:
            return f'''<figure class="image-container">
                {img_tag}
                <figcaption>{text}</figcaption>
            </figure>\n'''
        
        return f'<figure class="image-container">{img_tag}</figure>\n'
    
    def table(self, text: str) -> str:
        """自定义表格渲染"""
        # 添加响应式包装
        return f'''<div class="table-container">
            <table class="content-table">
                {text}
            </table>
        </div>\n'''
    
    def block_quote(self, text: str) -> str:
        """自定义引用块渲染"""
        return f'<blockquote class="quote-block">{text}</blockquote>\n'
    
    def block_html(self, html_content: str) -> str:
        """处理原始 HTML"""
        # 保护分页标记
        if 'pagebreak-marker' in html_content or 'data-pagebreak' in html_content:
            # 生成唯一ID并保存
            marker_id = f"PAGEBREAK_{uuid.uuid4().hex}"
            self.pagebreak_markers.append((marker_id, html_content))
            return f"<!--{marker_id}-->"
        
        return html_content
    
    def inline_html(self, html_content: str) -> str:
        """处理内联 HTML"""
        # 允许某些安全的内联 HTML
        allowed_tags = ['span', 'em', 'strong', 'mark', 'del', 'ins', 'sub', 'sup']
        
        # 简单的标签检查
        tag_match = re.match(r'<(/?)(\w+)(?:\s[^>]*)?>.*?(?:</\2>)?', html_content)
        if tag_match:
            tag_name = tag_match.group(2).lower()
            if tag_name in allowed_tags:
                return html_content
        
        # 其他 HTML 转义
        return html.escape(html_content)

def plugin_pagebreak(md: Markdown):
    """分页标记插件"""
    
    def parse_pagebreak(block, m, state):
        """解析分页标记"""
        return {'type': 'pagebreak'}
    
    def render_pagebreak(text=None):
        """渲染分页标记"""
        return '<div class="pagebreak-marker" data-pagebreak="true"></div>\n'
    
    # 注册块级规则
    md.block.register(
        'pagebreak',
        r'^<!--\s*pagebreak\s*-->\s*$',
        parse_pagebreak,
        before='paragraph'
    )
    
    # 注册渲染器
    if md.renderer:
        md.renderer.register('pagebreak', render_pagebreak)

class MarkdownProcessor:
    """优化的 Markdown 处理器"""
    
    def __init__(self):
        """初始化 Markdown 处理器"""
        # 创建自定义渲染器
        self.renderer = XiaohongshuRenderer(escape=False)
        
        # 创建 Markdown 实例并加载插件
        self.markdown = mistune.create_markdown(
            renderer=self.renderer,
            plugins=[
                task_lists_plugin,      # 任务列表
                table_plugin,           # 表格
                footnotes_plugin,       # 脚注
                strikethrough_plugin,   # 删除线
                def_list_plugin,        # 定义列表
                mark_plugin,            # 高亮标记
                insert_plugin,          # 插入文本
                superscript_plugin,     # 上标
                subscript_plugin,       # 下标
                plugin_pagebreak,       # 分页标记
                url_plugin,             # URL 自动链接
                abbr_plugin,            # 缩写
            ]
        )
        
        # 预编译的正则表达式
        self._emoji_pattern = re.compile(r':(\w+):')
        self._mention_pattern = re.compile(r'@(\w+)')
        self._hashtag_pattern = re.compile(r'#(\w+)')
        
    def parse(self, text: str) -> str:
        """
        解析 Markdown 文本为 HTML
        
        Args:
            text: Markdown 文本
            
        Returns:
            HTML 字符串
        """
        try:
            # 1. 预处理：保护特殊内容
            text = self._preprocess(text)
            
            # 2. 解析 Markdown
            html_output = self.markdown(text)
            
            # 3. 后处理：恢复分页标记，添加小红书特色
            html_output = self._postprocess(html_output)
            
            # 4. 添加必要的样式
            html_output = self._add_styles(html_output)
            
            return html_output
            
        except Exception as e:
            # 详细的错误信息
            import traceback
            error_details = traceback.format_exc()
            print(f"Markdown 解析错误:\n{error_details}")
            
            # 返回错误提示
            return f'''
            <div class="parse-error">
                <h3>⚠️ 解析错误</h3>
                <p>Markdown 解析过程中出现错误：</p>
                <pre>{html.escape(str(e))}</pre>
                <details>
                    <summary>详细信息</summary>
                    <pre>{html.escape(error_details)}</pre>
                </details>
            </div>
            '''
    
    def _preprocess(self, text: str) -> str:
        """预处理文本"""
        # 1. 规范化换行符
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        
        # 2. 保护代码块中的特殊字符
        text = self._protect_code_blocks(text)
        
        # 3. 处理小红书特色语法（如 @提及、#话题）
        # 暂时注释掉，避免与 Markdown 语法冲突
        # text = self._process_xiaohongshu_syntax(text)
        
        return text
    
    def _protect_code_blocks(self, text: str) -> str:
        """保护代码块中的内容"""
        # 使用更健壮的代码块匹配
        code_blocks = []
        
        # 匹配围栏代码块
        fence_pattern = re.compile(r'^```[\s\S]*?^```', re.MULTILINE)
        
        def replace_fence(match):
            code_blocks.append(match.group(0))
            return f"<!--CODE_BLOCK_{len(code_blocks)-1}-->"
        
        text = fence_pattern.sub(replace_fence, text)
        
        # 恢复代码块
        for i, code in enumerate(code_blocks):
            text = text.replace(f"<!--CODE_BLOCK_{i}-->", code)
        
        return text
    
    def _postprocess(self, html_output: str) -> str:
        """后处理 HTML"""
        # 1. 恢复分页标记
        if hasattr(self.renderer, 'pagebreak_markers'):
            for marker_id, marker_html in self.renderer.pagebreak_markers:
                html_output = html_output.replace(f"<!--{marker_id}-->", marker_html)
        
        # 2. 处理 emoji（将 :emoji: 转换为实际 emoji）
        html_output = self._process_emojis(html_output)
        
        # 3. 增强链接（添加图标等）
        html_output = self._enhance_links(html_output)
        
        # 4. 优化图片（添加加载动画等）
        html_output = self._enhance_images(html_output)
        
        return html_output
    
    def _process_emojis(self, html_output: str) -> str:
        """处理 emoji 表情"""
        # 常用 emoji 映射
        emoji_map = {
            'smile': '😊',
            'heart': '❤️',
            'star': '⭐',
            'fire': '🔥',
            'thumbs_up': '👍',
            'celebration': '🎉',
            'rocket': '🚀',
            'check': '✅',
            'cross': '❌',
            'warning': '⚠️',
            'info': 'ℹ️',
            'question': '❓',
            'bulb': '💡',
            'book': '📚',
            'code': '💻',
            'bug': '🐛',
            'gift': '🎁',
            'coffee': '☕',
            'pizza': '🍕',
            'beer': '🍺',
        }
        
        def replace_emoji(match):
            emoji_name = match.group(1)
            return emoji_map.get(emoji_name, match.group(0))
        
        # 只在非 HTML 标签内替换
        parts = re.split(r'(<[^>]+>)', html_output)
        for i, part in enumerate(parts):
            if not part.startswith('<'):
                parts[i] = self._emoji_pattern.sub(replace_emoji, part)
        
        return ''.join(parts)
    
    def _enhance_links(self, html_output: str) -> str:
        """增强链接显示"""
        # 为外部链接添加图标
        html_output = re.sub(
            r'<a ([^>]*class="external-link"[^>]*)>',
            r'<a \1><span class="link-icon">🔗</span> ',
            html_output
        )
        
        return html_output
    
    def _enhance_images(self, html_output: str) -> str:
        """增强图片显示"""
        # 暂时保持简单，避免影响正常显示
        return html_output
    
    def _add_styles(self, html_output: str) -> str:
        """添加必要的内联样式"""
        # 检查是否包含特定元素，添加对应样式
        styles = []
        
        if 'task-list' in html_output:
            styles.append(self._get_tasklist_styles())
        
        if 'code-block' in html_output:
            styles.append(self._get_codeblock_styles())
        
        if 'content-table' in html_output:
            styles.append(self._get_table_styles())
        
        if styles:
            style_tag = f"<style>\n{' '.join(styles)}\n</style>\n"
            html_output = style_tag + html_output
        
        return html_output
    
    def _get_tasklist_styles(self) -> str:
        """获取任务列表样式"""
        return """
        /* 任务列表样式 */
        .task-list {
            list-style: none;
            padding-left: 0;
        }
        
        .task-list-item {
            position: relative;
            padding-left: 28px;
            margin-bottom: 8px;
        }
        
        .task-list-item-checkbox {
            position: absolute;
            left: 0;
            top: 4px;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-color, #FF2442);
            border-radius: 4px;
            background: white;
            cursor: not-allowed;
        }
        
        .task-list-item-checkbox:checked {
            background: var(--primary-color, #FF2442);
            border-color: var(--primary-color, #FF2442);
        }
        
        .task-list-item-checkbox:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            left: 2px;
            top: -2px;
        }
        """
    
    def _get_codeblock_styles(self) -> str:
        """获取代码块样式"""
        return """
        /* 代码块样式 */
        .code-block {
            position: relative;
            background: #1e1e1e;
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            overflow-x: auto;
        }
        
        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .code-line {
            display: block;
            position: relative;
            padding-left: 40px;
        }
        
        .code-line::before {
            content: attr(data-line-number);
            position: absolute;
            left: 8px;
            color: #666;
            font-size: 12px;
            user-select: none;
        }
        """
    
    def _get_table_styles(self) -> str:
        """获取表格样式"""
        return """
        /* 表格样式 */
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        
        .content-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .content-table th {
            background: linear-gradient(135deg, var(--primary-color, #FF2442), var(--secondary-color, #FF6B6B));
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .content-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        
        .content-table tr:hover {
            background: rgba(255, 36, 66, 0.05);
        }
        """
    
    def validate(self, text: str) -> Tuple[bool, list]:
        """
        验证 Markdown 文本
        
        Returns:
            (是否有效, 错误列表)
        """
        errors = []
        
        # 检查未闭合的代码块
        fence_count = text.count('```')
        if fence_count % 2 != 0:
            errors.append("存在未闭合的代码块")
        
        # 检查未闭合的链接
        link_open = text.count('[')
        link_close = text.count(']')
        if link_open != link_close:
            errors.append("存在未闭合的链接语法")
        
        # 检查过长的行
        lines = text.split('\n')
        for i, line in enumerate(lines, 1):
            if len(line) > 1000:
                errors.append(f"第 {i} 行过长（超过1000字符）")
        
        return len(errors) == 0, errors
```

## 主要修改

1. **修正插件导入方式**：
   - 从 `mistune.plugins.xxx import plugin as xxx_plugin`
   - 避免命名冲突

2. **简化分页插件**：
   - 直接定义为函数而不是类

3. **修正类型注解**：
   - 使用 `Tuple` 而不是 `tuple`

4. **修正变量名**：
   - 避免与内置的 `html` 模块冲突

现在应该可以正常运行了。
### 用户:
from mistune.plugins.mark import plugin as mark_plugin
from mistune.plugins.insert import plugin as insert_plugin
from mistune.plugins.superscript import plugin as superscript_plugin
from mistune.plugins.subscript import plugin as subscript_plugin
from mistune.plugins.strikethrough import plugin as strikethrough_plugin
这几句标黄了，似乎是无法导入，
### 系统:
看来这些插件在 `mistune` 3.x 中不存在或名称不同。让我提供一个更精简、稳定的版本，只使用 `mistune` 确定支持的核心插件：

## 精简版 `markdown_processor.py`

```python
# ============================================
# src/core/markdown_processor.py - 精简稳定版
# ============================================
import re
import html
from typing import Optional, Dict, Any, Tuple
import mistune
from mistune import HTMLRenderer, Markdown
import uuid

# 只导入确定存在的核心插件
try:
    from mistune.plugins.task_lists import plugin as task_lists_plugin
except ImportError:
    task_lists_plugin = None

try:
    from mistune.plugins.table import plugin as table_plugin
except ImportError:
    table_plugin = None

try:
    from mistune.plugins.footnotes import plugin as footnotes_plugin
except ImportError:
    footnotes_plugin = None

try:
    from mistune.plugins.def_list import plugin as def_list_plugin
except ImportError:
    def_list_plugin = None

try:
    from mistune.plugins.abbr import plugin as abbr_plugin
except ImportError:
    abbr_plugin = None

try:
    from mistune.plugins.url import plugin as url_plugin
except ImportError:
    url_plugin = None

class XiaohongshuRenderer(HTMLRenderer):
    """小红书风格的 HTML 渲染器"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.pagebreak_markers = []  # 存储分页标记位置
        
    def heading(self, text: str, level: int, **attrs) -> str:
        """自定义标题渲染"""
        # 添加锚点支持
        anchor_id = re.sub(r'[^\w\u4e00-\u9fff-]', '-', text.lower())
        
        # 根据级别添加不同的类
        level_class = f"heading-{level}"
        
        # 对一级标题添加特殊装饰
        if level == 1:
            return f'<h{level} id="{anchor_id}" class="{level_class} heading-decorated">{text}</h{level}>\n'
        
        return f'<h{level} id="{anchor_id}" class="{level_class}">{text}</h{level}>\n'
    
    def list(self, text: str, ordered: bool, **attrs) -> str:
        """自定义列表渲染"""
        tag = 'ol' if ordered else 'ul'
        
        # 检查是否包含任务列表项
        if 'task-list-item' in text:
            return f'<{tag} class="task-list">\n{text}</{tag}>\n'
        
        # 普通列表添加样式类
        list_class = 'ordered-list' if ordered else 'unordered-list'
        return f'<{tag} class="{list_class}">\n{text}</{tag}>\n'
    
    def list_item(self, text: str, **attrs) -> str:
        """自定义列表项渲染"""
        # 任务列表项处理
        if 'task-list-item-checkbox' in text or '<input type="checkbox"' in text:
            return f'<li class="task-list-item">{text}</li>\n'
        
        return f'<li>{text}</li>\n'
    
    def block_code(self, code: str, info: Optional[str] = None) -> str:
        """自定义代码块渲染"""
        code = html.escape(code)
        
        # 提取语言信息
        lang = ''
        if info:
            info = info.strip()
            if info:
                lang = info.split()[0]
        
        # 添加语言标识
        if lang:
            return f'<pre class="code-block" data-lang="{lang}"><code class="language-{lang}">{code}</code></pre>\n'
        
        return f'<pre class="code-block"><code>{code}</code></pre>\n'
    
    def link(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义链接渲染"""
        # 检查是否为外部链接
        is_external = url.startswith(('http://', 'https://', '//'))
        
        # 构建属性
        attrs = []
        if title:
            attrs.append(f'title="{html.escape(title)}"')
        
        if is_external:
            attrs.append('target="_blank"')
            attrs.append('rel="noopener noreferrer"')
            attrs.append('class="external-link"')
        else:
            attrs.append('class="internal-link"')
        
        attrs_str = ' '.join(attrs)
        if attrs_str:
            return f'<a href="{url}" {attrs_str}>{text}</a>'
        
        return f'<a href="{url}">{text}</a>'
    
    def image(self, text: str, url: str, title: Optional[str] = None) -> str:
        """自定义图片渲染"""
        # 构建图片标签
        alt_text = html.escape(text or '')
        
        # 添加懒加载和响应式支持
        img_attrs = [
            f'src="{url}"',
            f'alt="{alt_text}"',
            'loading="lazy"',
            'class="content-image"'
        ]
        
        if title:
            img_attrs.append(f'title="{html.escape(title)}"')
        
        img_tag = f'<img {" ".join(img_attrs)} />'
        
        # 包装在 figure 中，支持图片说明
        if text:
            return f'''<figure class="image-container">
                {img_tag}
                <figcaption>{text}</figcaption>
            </figure>\n'''
        
        return f'<figure class="image-container">{img_tag}</figure>\n'
    
    def table(self, text: str) -> str:
        """自定义表格渲染"""
        # 添加响应式包装
        return f'''<div class="table-container">
            <table class="content-table">
                {text}
            </table>
        </div>\n'''
    
    def block_quote(self, text: str) -> str:
        """自定义引用块渲染"""
        return f'<blockquote class="quote-block">{text}</blockquote>\n'
    
    def block_html(self, html_content: str) -> str:
        """处理原始 HTML"""
        # 保护分页标记
        if 'pagebreak-marker' in html_content or 'data-pagebreak' in html_content:
            # 生成唯一ID并保存
            marker_id = f"PAGEBREAK_{uuid.uuid4().hex}"
            self.pagebreak_markers.append((marker_id, html_content))
            return f"<!--{marker_id}-->"
        
        return html_content
    
    def inline_html(self, html_content: str) -> str:
        """处理内联 HTML"""
        # 允许某些安全的内联 HTML
        allowed_tags = ['span', 'em', 'strong', 'mark', 'del', 'ins', 'sub', 'sup', 's', 'u']
        
        # 简单的标签检查
        tag_match = re.match(r'<(/?)(\w+)(?:\s[^>]*)?>.*?(?:</\2>)?', html_content)
        if tag_match:
            tag_name = tag_match.group(2).lower()
            if tag_name in allowed_tags:
                return html_content
        
        # 其他 HTML 转义
        return html.escape(html_content)
    
    def strikethrough(self, text: str) -> str:
        """处理删除线"""
        return f'<del>{text}</del>'
    
    def emphasis(self, text: str) -> str:
        """处理斜体"""
        return f'<em>{text}</em>'
    
    def strong(self, text: str) -> str:
        """处理粗体"""
        return f'<strong>{text}</strong>'

def plugin_strikethrough_simple(md: Markdown):
    """简单的删除线插件"""
    def parse_strikethrough(inline, m, state):
        text = m.group(1)
        return 'strikethrough', text
    
    def render_strikethrough(text):
        return f'<del>{text}</del>'
    
    # 注册内联规则
    md.inline.register(
        'strikethrough',
        r'~~([^~]+)~~',
        parse_strikethrough
    )
    
    # 注册渲染器
    if md.renderer and hasattr(md.renderer, 'register'):
        md.renderer.register('strikethrough', render_strikethrough)

def plugin_pagebreak(md: Markdown):
    """分页标记插件"""
    
    def parse_pagebreak(block, m, state):
        """解析分页标记"""
        return {'type': 'pagebreak'}
    
    def render_pagebreak(text=None):
        """渲染分页标记"""
        return '<div class="pagebreak-marker" data-pagebreak="true"></div>\n'
    
    # 注册块级规则
    md.block.register(
        'pagebreak',
        r'^<!--\s*pagebreak\s*-->\s*$',
        parse_pagebreak,
        before='paragraph'
    )
    
    # 注册渲染器
    if md.renderer:
        md.renderer.register('pagebreak', render_pagebreak)

class MarkdownProcessor:
    """优化的 Markdown 处理器"""
    
    def __init__(self):
        """初始化 Markdown 处理器"""
        # 创建自定义渲染器
        self.renderer = XiaohongshuRenderer(escape=False)
        
        # 收集可用插件
        available_plugins = []
        
        # 添加确定存在的插件
        if task_lists_plugin:
            available_plugins.append(task_lists_plugin)
        if table_plugin:
            available_plugins.append(table_plugin)
        if footnotes_plugin:
            available_plugins.append(footnotes_plugin)
        if def_list_plugin:
            available_plugins.append(def_list_plugin)
        if url_plugin:
            available_plugins.append(url_plugin)
        if abbr_plugin:
            available_plugins.append(abbr_plugin)
        
        # 添加自定义插件
        available_plugins.append(plugin_strikethrough_simple)
        available_plugins.append(plugin_pagebreak)
        
        # 创建 Markdown 实例并加载插件
        self.markdown = mistune.create_markdown(
            renderer=self.renderer,
            plugins=available_plugins
        )
        
        # 预编译的正则表达式
        self._emoji_pattern = re.compile(r':(\w+):')
        self._mention_pattern = re.compile(r'@(\w+)')
        self._hashtag_pattern = re.compile(r'#(\w+)')
        
        # 手动处理的特殊语法
        self._special_patterns = [
            (r'\*\*([^\*]+)\*\*', r'<strong>\1</strong>'),  # 粗体
            (r'\*([^\*]+)\*', r'<em>\1</em>'),              # 斜体
            (r'~~([^~]+)~~', r'<del>\1</del>'),             # 删除线
            (r'==([^=]+)==', r'<mark>\1</mark>'),           # 高亮
            (r'\^\^([^\^]+)\^\^', r'<sup>\1</sup>'),        # 上标
            (r'~([^~]+)~', r'<sub>\1</sub>'),               # 下标
        ]
        
    def parse(self, text: str) -> str:
        """
        解析 Markdown 文本为 HTML
        
        Args:
            text: Markdown 文本
            
        Returns:
            HTML 字符串
        """
        try:
            # 1. 预处理：保护特殊内容
            text = self._preprocess(text)
            
            # 2. 处理自定义语法（在 Markdown 解析前）
            text = self._process_custom_syntax(text)
            
            # 3. 解析 Markdown
            html_output = self.markdown(text)
            
            # 4. 后处理：恢复分页标记，添加小红书特色
            html_output = self._postprocess(html_output)
            
            # 5. 添加必要的样式
            html_output = self._add_styles(html_output)
            
            return html_output
            
        except Exception as e:
            # 详细的错误信息
            import traceback
            error_details = traceback.format_exc()
            print(f"Markdown 解析错误:\n{error_details}")
            
            # 返回错误提示
            return f'''
            <div class="parse-error">
                <h3>⚠️ 解析错误</h3>
                <p>Markdown 解析过程中出现错误：</p>
                <pre>{html.escape(str(e))}</pre>
                <details>
                    <summary>详细信息</summary>
                    <pre>{html.escape(error_details)}</pre>
                </details>
            </div>
            '''
    
    def _preprocess(self, text: str) -> str:
        """预处理文本"""
        # 1. 规范化换行符
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        
        # 2. 保护代码块中的特殊字符
        text = self._protect_code_blocks(text)
        
        return text
    
    def _process_custom_syntax(self, text: str) -> str:
        """处理自定义语法"""
        # 保护代码块
        code_blocks = []
        
        # 匹配代码块并临时替换
        fence_pattern = re.compile(r'^```[\s\S]*?^```', re.MULTILINE)
        inline_code_pattern = re.compile(r'`[^`]+`')
        
        def save_code(match):
            code_blocks.append(match.group(0))
            return f"__CODE_BLOCK_{len(code_blocks)-1}__"
        
        text = fence_pattern.sub(save_code, text)
        text = inline_code_pattern.sub(save_code, text)
        
        # 应用自定义语法规则（仅在非代码块区域）
        # 这里暂时跳过，因为 mistune 应该能处理基本的 markdown 语法
        
        # 恢复代码块
        for i, code in enumerate(code_blocks):
            text = text.replace(f"__CODE_BLOCK_{i}__", code)
        
        return text
    
    def _protect_code_blocks(self, text: str) -> str:
        """保护代码块中的内容"""
        # 使用更健壮的代码块匹配
        code_blocks = []
        
        # 匹配围栏代码块
        fence_pattern = re.compile(r'^```[\s\S]*?^```', re.MULTILINE)
        
        def replace_fence(match):
            code_blocks.append(match.group(0))
            return f"<!--CODE_BLOCK_{len(code_blocks)-1}-->"
        
        text = fence_pattern.sub(replace_fence, text)
        
        # 恢复代码块
        for i, code in enumerate(code_blocks):
            text = text.replace(f"<!--CODE_BLOCK_{i}-->", code)
        
        return text
    
    def _postprocess(self, html_output: str) -> str:
        """后处理 HTML"""
        # 1. 恢复分页标记
        if hasattr(self.renderer, 'pagebreak_markers'):
            for marker_id, marker_html in self.renderer.pagebreak_markers:
                html_output = html_output.replace(f"<!--{marker_id}-->", marker_html)
        
        # 2. 处理 emoji
        html_output = self._process_emojis(html_output)
        
        # 3. 增强链接
        html_output = self._enhance_links(html_output)
        
        return html_output
    
    def _process_emojis(self, html_output: str) -> str:
        """处理 emoji 表情"""
        # 常用 emoji 映射
        emoji_map = {
            'smile': '😊',
            'heart': '❤️',
            'star': '⭐',
            'fire': '🔥',
            'thumbs_up': '👍',
            'thumbsup': '👍',
            'celebration': '🎉',
            'rocket': '🚀',
            'check': '✅',
            'cross': '❌',
            'warning': '⚠️',
            'info': 'ℹ️',
            'question': '❓',
            'bulb': '💡',
            'book': '📚',
            'code': '💻',
            'bug': '🐛',
            'gift': '🎁',
            'coffee': '☕',
            'pizza': '🍕',
            'beer': '🍺',
            '100': '💯',
            'ok': '👌',
        }
        
        def replace_emoji(match):
            emoji_name = match.group(1)
            return emoji_map.get(emoji_name, match.group(0))
        
        # 只在非 HTML 标签内替换
        parts = re.split(r'(<[^>]+>)', html_output)
        for i, part in enumerate(parts):
            if not part.startswith('<'):
                parts[i] = self._emoji_pattern.sub(replace_emoji, part)
        
        return ''.join(parts)
    
    def _enhance_links(self, html_output: str) -> str:
        """增强链接显示"""
        # 为外部链接添加图标（可选）
        # 暂时保持简单
        return html_output
    
    def _add_styles(self, html_output: str) -> str:
        """添加必要的内联样式"""
        # 检查是否包含特定元素，添加对应样式
        styles = []
        
        if 'task-list' in html_output or 'checkbox' in html_output:
            styles.append(self._get_tasklist_styles())
        
        if 'code-block' in html_output or '<pre>' in html_output:
            styles.append(self._get_codeblock_styles())
        
        if 'content-table' in html_output or '<table>' in html_output:
            styles.append(self._get_table_styles())
        
        if styles:
            style_tag = f"<style>\n{''.join(styles)}\n</style>\n"
            html_output = style_tag + html_output
        
        return html_output
    
    def _get_tasklist_styles(self) -> str:
        """获取任务列表样式"""
        return """
        /* 任务列表样式 */
        .task-list {
            list-style: none;
            padding-left: 0;
        }
        
        .task-list-item {
            position: relative;
            padding-left: 28px;
            margin-bottom: 8px;
            list-style: none;
        }
        
        .task-list-item input[type="checkbox"] {
            position: absolute;
            left: 0;
            top: 4px;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-color, #FF2442);
            border-radius: 4px;
            background: white;
            cursor: not-allowed;
        }
        
        .task-list-item input[type="checkbox"]:checked {
            background: var(--primary-color, #FF2442);
            border-color: var(--primary-color, #FF2442);
        }
        
        .task-list-item input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            left: 2px;
            top: -2px;
        }
        """
    
    def _get_codeblock_styles(self) -> str:
        """获取代码块样式"""
        return """
        /* 代码块样式 */
        .code-block, pre {
            position: relative;
            background: #1e1e1e;
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
            overflow-x: auto;
            color: #d4d4d4;
        }
        
        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        code {
            font-family: 'Cascadia Code', 'JetBrains Mono', 'Consolas', monospace;
        }
        """
    
    def _get_table_styles(self) -> str:
        """获取表格样式"""
        return """
        /* 表格样式 */
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        
        .content-table, table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .content-table th, table th {
            background: linear-gradient(135deg, var(--primary-color, #FF2442), var(--secondary-color, #FF6B6B));
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .content-table td, table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        
        .content-table tr:hover, table tr:hover {
            background: rgba(255, 36, 66, 0.05);
        }
        """
    
    def validate(self, text: str) -> Tuple[bool, list]:
        """
        验证 Markdown 文本
        
        Returns:
            (是否有效, 错误列表)
        """
        errors = []
        
        # 检查未闭合的代码块
        fence_count = text.count('```')
        if fence_count % 2 != 0:
            errors.append("存在未闭合的代码块")
        
        # 检查未闭合的链接
        link_open = text.count('[')
        link_close = text.count(']')
        if link_open != link_close:
            errors.append("存在未闭合的链接语法")
        
        # 检查过长的行
        lines = text.split('\n')
        for i, line in enumerate(lines, 1):
            if len(line) > 1000:
                errors.append(f"第 {i} 行过长（超过1000字符）")
        
        return len(errors) == 0, errors
```

这个精简版：

1. **只使用确定存在的插件**：通过 try-except 安全导入
2. **手动实现删除线**：添加简单的删除线插件
3. **保留核心功能**：标题、列表、表格、代码块、链接、图片等
4. **移除不确定的插件**：mark、insert、superscript、subscript 等

这个版本更稳定，应该能正常运行。如果还有问题，可以进一步简化。
### 用户:
似乎，在进入页面的时候的默认markdown语句，最开始会莫名其妙出现/* 代码块样式 */ .code-block, pre { position: relative; background: #1e1e1e; border-radius: 8px; padding: 16px; margin: 20px 0; overflow-x: auto; color: #d4d4d4; } .code-block::before { content: attr(data-lang); position: absolute; top: 8px; right: 12px; font-size: 12px; color: #888; text-transform: uppercase; font-weight: 600; } code { font-family: 'Cascadia Code', 'JetBrains Mono', 'Consolas', monospace; }
这个内容，而且表格无法正常渲染
