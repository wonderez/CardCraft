### 用户:
项目背景
我正在开发一个 Windows 桌面应用「CardCraft」，核心目标是：
- 用户输入 Markdown 文本
- 自动渲染成小红书风格的精美卡片
- 智能分页（3:4 比例，1080×1440px）
- 批量导出高质量图片
 
# 技术栈
- 框架：PySide6 (Qt for Python)
- 渲染：QWebEngineView (基于 Chromium)
- Markdown解析：python-markdown + 扩展
- 样式：HTML + CSS (小红书风格)
- 分页：JavaScript (在 WebEngine 中执行)
 
# 核心架构设计
┌─────────────────────────────────────────┐
│           主窗口 (MainWindow)           │
├─────────────┬──────────────┬────────────┤
│  编辑器组件  │   预览组件    │  工具栏   │
│ (QTextEdit) │(QWebEngineView)│ (QToolBar)│
└─────────────┴──────────────┴────────────┘
↓
┌──────────────┐
│ Markdown解析  │
└──────────────┘
↓
┌──────────────┐
│  HTML生成    │
└──────────────┘
↓
┌──────────────┐
│  智能分页    │
└──────────────┘
↓
┌──────────────┐
│  样式渲染    │
└──────────────┘
↓
┌──────────────┐
│  图片导出    │
└──────────────┘
 
# 项目结构
cardcraft/
├── main.py                     # 启动程序，创建 Qt 应用
├── requirements.txt            # 依赖包列表：PySide6、markdown 等
│
src/
├── ui/
│   ├── main_window.py         # 主窗口：左右分栏布局，导出按钮，300ms延迟更新
│   ├── editor_widget.py       # 左侧编辑器：QTextEdit，含示例文本
│   ├── preview_widget.py      # 右侧预览：QWebEngineView，集成分页和导出功能
│   
├── core/
│   ├── markdown_processor.py  # Markdown 转 HTML：使用 python-markdown 库
│   ├── html_generator.py      # 生成完整网页：支持页码、多主题CSS样式
│   
├── utils/
│   ├── paginator.py           # ✅ 智能分页器：HTML元素解析、高度估算、分页优化
│   ├── exporter.py            # ✅ 图片导出器：批量导出、进度追踪、水印添加
│   ├── style_manager.py       # ✅ 样式管理器：多主题支持（小红书/Instagram/微信/知乎/深色）
│   
├── resources/
│   ├── styles/                # �� 预留：未来可存放独立CSS文件
│   └── templates/             # �� 预留：未来可存放HTML模板文件# 核心功能需求
 
## 1. 智能分页算法
- 每页固定尺寸：1080×1440px (3:4比例)
- 分页原则：
  * 段落完整性：不在段落中间分页
  * 标题关联：标题与其后续内容保持同页
  * 列表连续：列表项尽量不分离
  * 代码完整：代码块不跨页
  * 视觉平衡：避免页面过空或过满
 
## 2. 样式系统
- 预设主题：小红书、Instagram、微信、知乎等
- 样式要素：
  * 字体：中文用苹方/微软雅黑，西文用 Helvetica
  * 颜色：主色 #FF2442，文字 #333333
  * 间距：段落间距 20px，行高 1.8
  * 特效：卡片阴影、圆角、渐变背景
 
## 3. 渲染流程
```python
# 伪代码示例
markdown_text → parse_markdown() → generate_html() → apply_styles() → paginate() → render_preview() → export_images()
4. 导出功能
 
格式：PNG/JPEG
质量：支持 1x/2x/3x 分辨率
命名：自动编号，如 card_01.png, card_02.png
批量：一次导出所有分页
 
代码规范
 
使用类型注解 (typing)
遵循 PEP 8
中文注释说明关键逻辑
错误处理要完善
 
性能要求
 
实时预览延迟 < 300ms
支持 10000 字的文档
导出速度：每张卡片 < 1秒
 
问题描述
这个预览页面存在很多问题，我一一列举：
1. 右上角和左下角，都有页数，重复了。
2. 左下角的上下页和页数，最好居中显示
3. 没有滚动栏，实际大小模式时卡片无法完全展示
4. 适应窗口时，卡片不居中
5. 或者更准确地说，我发现不管是适应窗口模式还是实际大小模式，整个窗口右边似乎有一块空白区域没有用到
期望输出
修改问题的代码；若修改小则直接告诉我位置，我个人进行修改；若变动大，则给我这个文件的完整代码
preview_widget.py->text/plain-># ============================================
# src/ui/preview_widget.py - 优化版本
# ============================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QFrame, 
                               QPushButton, QHBoxLayout, QProgressDialog,
                               QMessageBox, QComboBox, QButtonGroup, QRadioButton)
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtCore import QUrl, QTimer, Signal, Qt, QSize, QEvent
from PySide6.QtGui import QWheelEvent
from pathlib import Path
from src.core.markdown_processor import MarkdownProcessor
from src.core.html_generator import HTMLGenerator
from src.utils.paginator import SmartPaginator
from src.utils.exporter import ImageExporter

class PreviewWidget(QWidget):
    pageChanged = Signal(int, int)  # 当前页，总页数
    sizeChanged = Signal(str)  # 尺寸改变信号
    
    def __init__(self):
        super().__init__()
        self.current_pages = []  # 存储分页后的HTML内容
        self.current_page = 1
        self.total_pages = 1
        self.markdown_text = ""  # 保存原始markdown文本
        self.current_size = "medium"  # 当前页面尺寸
        self.preview_mode = "fit"  # 预览模式: fit(适应窗口) 或 actual(实际大小)
        
        # 初始化处理器
        self.markdown_processor = MarkdownProcessor()
        self.html_generator = HTMLGenerator(page_size="medium")
        self.paginator = SmartPaginator(page_size="medium")
        
        # 初始化UI
        self.init_ui()
        
        # 设置导出器
        self.setup_exporter()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 创建容器框架
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: rgba(25, 25, 40, 0.95);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 16px;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        
        # 创建标题栏
        title_bar = self.create_title_bar()
        
        # 创建WebView（直接嵌入，不使用滚动区域）
        self.create_web_view()
        
        # 创建控制栏
        control_bar = self.create_control_bar()
        
        # 组装布局
        container_layout.addWidget(title_bar)
        container_layout.addWidget(self.web_view, 1)
        container_layout.addWidget(control_bar)
        
        layout.addWidget(container)
        
        # 连接信号
        self.connect_signals()
        
        # 初始化按钮状态
        self.update_buttons()
        
        # 安装事件过滤器以处理滚轮事件
        self.web_view.installEventFilter(self)
    
    def create_title_bar(self):
        """创建标题栏"""
        title_bar = QFrame()
        title_bar.setFixedHeight(50)
        title_bar.setStyleSheet("""
            QFrame {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.1),
                    stop: 0.5 rgba(0, 150, 255, 0.15),
                    stop: 1 rgba(0, 224, 255, 0.1)
                );
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-bottom: 1px solid rgba(0, 224, 255, 0.2);
            }
        """)
        
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(20, 5, 20, 5)
        title_layout.setSpacing(15)
        
        # 标题
        title = QLabel("👀 实时预览")
        title.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-size: 16px;
                font-weight: 600;
                letter-spacing: 0.5px;
                background: transparent;
            }
        """)
        
        # 尺寸选择标签
        size_label = QLabel("尺寸:")
        size_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                background: transparent;
            }
        """)
        
        # 尺寸选择下拉框
        self.size_selector = QComboBox()
        self.size_selector.addItems(["小尺寸 (720×960)", "中尺寸 (1080×1440)", "大尺寸 (1440×1920)"])
        self.size_selector.setCurrentIndex(1)
        self.size_selector.setFixedWidth(150)
        self.size_selector.setStyleSheet(self.get_combobox_style())
        
        # 预览模式选择
        mode_label = QLabel("模式:")
        mode_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                background: transparent;
            }
        """)
        
        # 预览模式按钮组
        self.mode_group = QButtonGroup()
        
        self.fit_mode_btn = QRadioButton("适应窗口")
        self.fit_mode_btn.setChecked(True)
        self.fit_mode_btn.setStyleSheet(self.get_radio_style())
        
        self.actual_mode_btn = QRadioButton("实际大小")
        self.actual_mode_btn.setStyleSheet(self.get_radio_style())
        
        self.mode_group.addButton(self.fit_mode_btn, 0)
        self.mode_group.addButton(self.actual_mode_btn, 1)
        
        # 页面信息标签
        self.page_info_label = QLabel("")
        self.page_info_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                padding: 5px 15px;
                background: rgba(0, 224, 255, 0.05);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 12px;
            }
        """)
        
        # 组装标题栏
        title_layout.addWidget(title)
        title_layout.addSpacing(20)
        title_layout.addWidget(size_label)
        title_layout.addWidget(self.size_selector)
        title_layout.addSpacing(15)
        title_layout.addWidget(mode_label)
        title_layout.addWidget(self.fit_mode_btn)
        title_layout.addWidget(self.actual_mode_btn)
        title_layout.addStretch()
        title_layout.addWidget(self.page_info_label)
        
        return title_bar
    
    def create_web_view(self):
        """创建WebView"""
        self.web_view = QWebEngineView()
        self.web_view.setStyleSheet("""
            QWebEngineView {
                border: none;
                background: #1a1a2e;
            }
        """)
        
        # 启用滚动条（实际大小模式需要）
        self.web_view.page().settings().setAttribute(
            self.web_view.page().settings().WebAttribute.ShowScrollBars, True
        )
    
    def create_control_bar(self):
        """创建控制栏"""
        control_bar = QFrame()
        control_bar.setFixedHeight(60)
        control_bar.setStyleSheet("""
            QFrame {
                background: rgba(20, 20, 35, 0.8);
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
                border-top: 1px solid rgba(0, 224, 255, 0.1);
            }
        """)
        
        control_layout = QHBoxLayout(control_bar)
        control_layout.setContentsMargins(20, 12, 20, 12)
        control_layout.setSpacing(15)
        
        # 上一页按钮
        self.prev_btn = QPushButton("⬅ 上一页")
        self.prev_btn.setFixedSize(100, 36)
        self.prev_btn.setStyleSheet(self.get_button_style())
        
        # 页码快速跳转
        self.page_jump_label = QLabel("跳转:")
        self.page_jump_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 13px;
                background: transparent;
            }
        """)
        
        self.page_selector = QComboBox()
        self.page_selector.setFixedWidth(80)
        self.page_selector.setStyleSheet(self.get_combobox_style())
        
        # 下一页按钮
        self.next_btn = QPushButton("下一页 ➡")
        self.next_btn.setFixedSize(100, 36)
        self.next_btn.setStyleSheet(self.get_button_style())
        
        # 快捷提示
        tips_label = QLabel("💡 提示: 使用鼠标滚轮或 ↑↓ 键翻页")
        tips_label.setStyleSheet("""
            QLabel {
                color: #6a7a8a;
                font-size: 11px;
                font-style: italic;
                background: transparent;
            }
        """)
        
        # 组装控制栏
        control_layout.addWidget(self.prev_btn)
        control_layout.addWidget(self.page_jump_label)
        control_layout.addWidget(self.page_selector)
        control_layout.addWidget(self.next_btn)
        control_layout.addStretch()
        control_layout.addWidget(tips_label)
        
        return control_bar
    
    def connect_signals(self):
        """连接信号"""
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.size_selector.currentIndexChanged.connect(self.on_size_changed)
        self.mode_group.buttonClicked.connect(self.on_mode_changed)
        self.page_selector.currentIndexChanged.connect(self.on_page_jump)
    
    def eventFilter(self, obj, event):
        """事件过滤器 - 处理滚轮事件实现翻页"""
        if obj == self.web_view and event.type() == QEvent.Wheel:
            wheel_event = event
            
            # 检查是否在实际大小模式下，且页面有滚动条
            if self.preview_mode == "actual":
                # 获取当前页面的滚动位置
                def check_scroll_and_page():
                    self.web_view.page().runJavaScript("""
                        ({
                            scrollTop: window.pageYOffset || document.documentElement.scrollTop,
                            scrollHeight: document.documentElement.scrollHeight,
                            clientHeight: window.innerHeight,
                            canScrollDown: (window.pageYOffset + window.innerHeight) < document.documentElement.scrollHeight - 10,
                            canScrollUp: window.pageYOffset > 10
                        })
                    """, lambda result: self.handle_scroll_result(result, wheel_event))
                
                check_scroll_and_page()
                return False  # 先不阻止默认行为
            else:
                # 适应窗口模式，直接翻页
                if wheel_event.angleDelta().y() > 0:
                    self.prev_page()
                else:
                    self.next_page()
                return True  # 阻止默认滚动行为
        
        return super().eventFilter(obj, event)
    
    def handle_scroll_result(self, result, wheel_event):
        """处理滚动检测结果"""
        if result:
            # 向下滚动且已到底部，切换到下一页
            if wheel_event.angleDelta().y() < 0 and not result['canScrollDown']:
                if self.current_page < self.total_pages:
                    self.next_page()
                    # 滚动到页面顶部
                    QTimer.singleShot(100, lambda: self.web_view.page().runJavaScript(
                        "window.scrollTo(0, 0);"
                    ))
            
            # 向上滚动且已到顶部，切换到上一页
            elif wheel_event.angleDelta().y() > 0 and not result['canScrollUp']:
                if self.current_page > 1:
                    self.prev_page()
                    # 滚动到页面底部
                    QTimer.singleShot(100, lambda: self.web_view.page().runJavaScript(
                        "window.scrollTo(0, document.documentElement.scrollHeight);"
                    ))
    
    def keyPressEvent(self, event):
        """处理键盘事件"""
        if event.key() == Qt.Key_Up or event.key() == Qt.Key_PageUp:
            self.prev_page()
        elif event.key() == Qt.Key_Down or event.key() == Qt.Key_PageDown:
            self.next_page()
        elif event.key() == Qt.Key_Home:
            self.go_to_page(1)
        elif event.key() == Qt.Key_End:
            self.go_to_page(self.total_pages)
        else:
            super().keyPressEvent(event)
    
    def on_mode_changed(self):
        """处理预览模式改变"""
        if self.fit_mode_btn.isChecked():
            self.preview_mode = "fit"
        else:
            self.preview_mode = "actual"
        
        # 重新渲染当前页面
        self.display_current_page()
    
    def on_size_changed(self, index):
        """处理尺寸改变"""
        size_map = {0: "small", 1: "medium", 2: "large"}
        new_size = size_map.get(index, "medium")
        
        if new_size != self.current_size:
            self.current_size = new_size
            
            # 更新各组件的尺寸设置
            self.html_generator = HTMLGenerator(page_size=new_size)
            self.paginator.set_page_size(new_size)
            
            # 重新处理内容
            if self.markdown_text:
                self.update_content(self.markdown_text)
            
            # 发送尺寸改变信号
            self.sizeChanged.emit(new_size)
    
    def on_page_jump(self, index):
        """处理页码跳转"""
        if index >= 0:
            self.go_to_page(index + 1)
    
    def update_content(self, markdown_text: str):
        """更新预览内容"""
        try:
            self.markdown_text = markdown_text
            
            # 处理 Markdown
            html_content = self.markdown_processor.parse(markdown_text)
            
            # 使用智能分页器进行分页
            self.current_pages = self.paginator.paginate(html_content)
            
            # 优化分页结果
            self.current_pages = self.paginator.optimize_pages(self.current_pages)
            
            self.total_pages = len(self.current_pages)
            self.current_page = 1
            
            # 更新页码选择器
            self.update_page_selector()
            
            # 显示第一页
            self.display_current_page()
            
            # 更新按钮和信息
            self.update_buttons()
            self.update_page_info()
            
        except Exception as e:
            self.show_error(f"预览错误: {str(e)}")
    
    def update_page_selector(self):
        """更新页码选择器"""
        self.page_selector.blockSignals(True)
        self.page_selector.clear()
        for i in range(1, self.total_pages + 1):
            self.page_selector.addItem(f"第 {i} 页")
        self.page_selector.setCurrentIndex(0)
        self.page_selector.blockSignals(False)
        
        # 如果只有一页，隐藏跳转控件
        has_multiple_pages = self.total_pages > 1
        self.page_jump_label.setVisible(has_multiple_pages)
        self.page_selector.setVisible(has_multiple_pages)
    
    def display_current_page(self):
        """显示当前页"""
        if not self.current_pages:
            return
            
        if 1 <= self.current_page <= len(self.current_pages):
            page_content = self.current_pages[self.current_page - 1]
            
            # 根据预览模式生成不同的HTML
            if self.preview_mode == "fit":
                # 适应窗口模式：使用缩放使内容适应视窗
                full_html = self.generate_fit_html(page_content)
            else:
                # 实际大小模式：显示真实尺寸
                full_html = self.html_generator.generate(page_content)
            
            # 加载到WebView
            self.web_view.setHtml(full_html, QUrl("file:///"))
    
    def generate_fit_html(self, content: str) -> str:
        """生成适应窗口的HTML"""
        # 获取当前窗口大小
        view_width = self.web_view.width()
        view_height = self.web_view.height()
        
        # 获取目标尺寸
        size_config = {
            "small": (720, 960),
            "medium": (1080, 1440),
            "large": (1440, 1920)
        }
        target_width, target_height = size_config.get(self.current_size, (1080, 1440))
        
        # 计算缩放比例（保持比例，适应窗口）
        scale_x = (view_width - 40) / target_width  # 减去边距
        scale_y = (view_height - 40) / target_height
        scale = min(scale_x, scale_y, 1.0)  # 不超过原始大小
        
        # 生成带缩放的HTML
        html = self.html_generator.generate(content)
        
        # 注入缩放样式
        scale_style = f"""
        <style>
            body {{
                zoom: {scale};
                -moz-transform: scale({scale});
                -moz-transform-origin: 0 0;
                width: {target_width}px !important;
                margin: 0 auto;
            }}
            .page-container {{
                box-shadow: 0 4px 20px rgba(0, 224, 255, 0.15);
            }}
        </style>
        """
        
        # 插入缩放样式
        html = html.replace('</head>', scale_style + '</head>')
        
        return html
    
    def prev_page(self):
        """上一页"""
        if self.current_page > 1:
            self.go_to_page(self.current_page - 1)
    
    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages:
            self.go_to_page(self.current_page + 1)
    
    def go_to_page(self, page_num: int):
        """跳转到指定页"""
        if 1 <= page_num <= self.total_pages:
            self.current_page = page_num
            self.display_current_page()
            self.update_buttons()
            self.update_page_info()
            
            # 更新页码选择器
            self.page_selector.blockSignals(True)
            self.page_selector.setCurrentIndex(page_num - 1)
            self.page_selector.blockSignals(False)
    
    def update_buttons(self):
        """更新按钮状态"""
        self.prev_btn.setEnabled(self.current_page > 1)
        self.next_btn.setEnabled(self.current_page < self.total_pages)
        
        # 发送页面改变信号
        self.pageChanged.emit(self.current_page, self.total_pages)
    
    def update_page_info(self):
        """更新页面信息显示"""
        if self.total_pages > 1:
            self.page_info_label.setText(f"第 {self.current_page}/{self.total_pages} 页")
        else:
            self.page_info_label.setText("第 1 页")
    
    def get_button_style(self) -> str:
        """获取按钮样式"""
        return """
            QPushButton {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.15),
                    stop: 1 rgba(0, 150, 255, 0.1)
                );
                border: 1px solid rgba(0, 224, 255, 0.4);
                color: #00e0ff;
                padding: 8px 16px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 13px;
            }
            QPushButton:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.25),
                    stop: 1 rgba(0, 150, 255, 0.2)
                );
                border: 1px solid rgba(0, 224, 255, 0.6);
            }
            QPushButton:pressed {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.35),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
            }
            QPushButton:disabled {
                background: rgba(30, 30, 45, 0.5);
                border-color: rgba(100, 100, 120, 0.3);
                color: rgba(100, 100, 120, 0.5);
            }
        """
    
    def get_combobox_style(self) -> str:
        """获取下拉框样式"""
        return """
            QComboBox {
                background: rgba(0, 224, 255, 0.1);
                border: 1px solid rgba(0, 224, 255, 0.3);
                color: #00e0ff;
                padding: 5px 10px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 500;
            }
            QComboBox:hover {
                background: rgba(0, 224, 255, 0.15);
                border: 1px solid rgba(0, 224, 255, 0.5);
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 5px solid #00e0ff;
                margin-right: 5px;
            }
            QComboBox QAbstractItemView {
                background: rgba(25, 25, 40, 0.98);
                border: 1px solid rgba(0, 224, 255, 0.3);
                color: #00e0ff;
                selection-background-color: rgba(0, 224, 255, 0.2);
                outline: none;
            }
        """
    
    def get_radio_style(self) -> str:
        """获取单选按钮样式"""
        return """
            QRadioButton {
                color: #8a92a6;
                font-size: 12px;
                spacing: 5px;
            }
            QRadioButton::indicator {
                width: 14px;
                height: 14px;
                border: 2px solid rgba(0, 224, 255, 0.4);
                border-radius: 7px;
                background: transparent;
            }
            QRadioButton::indicator:checked {
                background: qradialgradient(
                    cx: 0.5, cy: 0.5, radius: 0.5,
                    fx: 0.5, fy: 0.5,
                    stop: 0 #00e0ff,
                    stop: 0.6 #00e0ff,
                    stop: 0.7 transparent
                );
                border-color: #00e0ff;
            }
            QRadioButton:checked {
                color: #00e0ff;
            }
        """
    
    def setup_exporter(self):
        """设置导出器"""
        self.exporter = ImageExporter(self.web_view)
        self.exporter.progress.connect(self.on_export_progress)
        self.exporter.finished.connect(self.on_export_finished)
        self.exporter.page_exported.connect(self.on_page_exported)
    
    def export_pages(self, folder: str):
        """导出所有页面为图片"""
        if not self.current_pages:
            QMessageBox.warning(self, "提示", "没有可导出的内容")
            return
        
        # 创建进度对话框
        self.progress_dialog = QProgressDialog(
            "正在导出图片...", 
            "取消", 
            0, 
            self.total_pages, 
            self
        )
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setMinimumDuration(0)
        self.progress_dialog.setAutoClose(False)
        self.progress_dialog.setAutoReset(False)
        self.progress_dialog.canceled.connect(self.on_export_canceled)
        
        # 开始导出（始终以实际大小导出）
        self.exporter.export_pages(
            self.current_pages,
            folder,
            self.html_generator,
            format="PNG",
            quality=100
        )
    
    def on_export_progress(self, current: int, total: int):
        """处理导出进度"""
        if hasattr(self, 'progress_dialog') and self.progress_dialog:
            self.progress_dialog.setValue(current)
            self.progress_dialog.setLabelText(f"正在导出第 {current}/{total} 页...")
    
    def on_export_finished(self, success: bool, message: str):
        """处理导出完成"""
        if hasattr(self, 'progress_dialog') and self.progress_dialog:
            try:
                self.progress_dialog.canceled.disconnect()
                self.progress_dialog.close()
                self.progress_dialog.deleteLater()
            except:
                pass
            finally:
                self.progress_dialog = None
        
        if success:
            size_info = f"({self.current_size}: {self.get_actual_size()}px)"
            QMessageBox.information(self, "导出成功", f"{message}\n尺寸: {size_info}")
        else:
            QMessageBox.warning(self, "导出失败", message)
    
    def on_page_exported(self, page_num: int, file_path: str):
        """处理单页导出完成"""
        print(f"已导出第 {page_num} 页: {file_path}")
    
    def on_export_canceled(self):
        """处理导出取消"""
        self.exporter.cancel_export()
    
    def get_actual_size(self) -> str:
        """获取实际尺寸"""
        size_config = {
            "small": "720×960",
            "medium": "1080×1440",
            "large": "1440×1920"
        }
        return size_config.get(self.current_size, "1080×1440")
    
    def handle_scroll(self, percentage: float):
        """处理编辑器滚动同步（保留接口兼容性）"""
        pass
    
    def show_error(self, message: str):
        """显示错误信息"""
        error_html = f"""
        <html>
        <body style="padding: 20px; font-family: sans-serif; background: #1a1a2e; color: #e0e6ed;">
            <h3 style="color: #ff4757;">错误</h3>
            <p style="color: #8a92a6;">{message}</p>
        </body>
        </html>
        """
        self.web_view.setHtml(error_html)
    
    def change_theme(self, theme: str):
        """切换主题"""
        self.html_generator.set_theme(theme)
        if self.current_pages:
            self.display_current_page()
### 系统:
我来帮你分析和修复这些问题。这些问题主要涉及布局和显示逻辑，需要对 `preview_widget.py` 进行一些调整。

## 问题分析和解决方案：

### 1. **页数重复显示问题**
右上角标题栏的 `page_info_label` 和左下角控制栏的页码跳转都显示了页数，确实重复了。

### 2. **控制栏居中问题**
控制栏的按钮和页码选择器应该居中显示。

### 3. **实际大小模式滚动条问题**
WebView 需要正确配置以支持滚动。

### 4. **适应窗口模式居中问题**
需要调整缩放后的居中逻辑。

### 5. **右侧空白区域问题**
可能是容器边距或WebView尺寸设置的问题。

由于改动较大，我提供完整的修复后的代码： 代码
```python
# ============================================
# src/ui/preview_widget.py - 修复版本
# ============================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QFrame, 
                               QPushButton, QHBoxLayout, QProgressDialog,
                               QMessageBox, QComboBox, QButtonGroup, QRadioButton,
                               QScrollArea)
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtCore import QUrl, QTimer, Signal, Qt, QSize, QEvent
from PySide6.QtGui import QWheelEvent
from pathlib import Path
from src.core.markdown_processor import MarkdownProcessor
from src.core.html_generator import HTMLGenerator
from src.utils.paginator import SmartPaginator
from src.utils.exporter import ImageExporter

class PreviewWidget(QWidget):
    pageChanged = Signal(int, int)  # 当前页，总页数
    sizeChanged = Signal(str)  # 尺寸改变信号
    
    def __init__(self):
        super().__init__()
        self.current_pages = []  # 存储分页后的HTML内容
        self.current_page = 1
        self.total_pages = 1
        self.markdown_text = ""  # 保存原始markdown文本
        self.current_size = "medium"  # 当前页面尺寸
        self.preview_mode = "fit"  # 预览模式: fit(适应窗口) 或 actual(实际大小)
        
        # 初始化处理器
        self.markdown_processor = MarkdownProcessor()
        self.html_generator = HTMLGenerator(page_size="medium")
        self.paginator = SmartPaginator(page_size="medium")
        
        # 初始化UI
        self.init_ui()
        
        # 设置导出器
        self.setup_exporter()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 创建容器框架
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: rgba(25, 25, 40, 0.95);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 16px;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        
        # 创建标题栏
        title_bar = self.create_title_bar()
        
        # 创建WebView容器（用于实际大小模式的滚动）
        self.create_web_view_container()
        
        # 创建控制栏
        control_bar = self.create_control_bar()
        
        # 组装布局
        container_layout.addWidget(title_bar)
        container_layout.addWidget(self.web_container, 1)
        container_layout.addWidget(control_bar)
        
        layout.addWidget(container)
        
        # 连接信号
        self.connect_signals()
        
        # 初始化按钮状态
        self.update_buttons()
        
        # 安装事件过滤器以处理滚轮事件
        self.web_view.installEventFilter(self)
    
    def create_title_bar(self):
        """创建标题栏"""
        title_bar = QFrame()
        title_bar.setFixedHeight(50)
        title_bar.setStyleSheet("""
            QFrame {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.1),
                    stop: 0.5 rgba(0, 150, 255, 0.15),
                    stop: 1 rgba(0, 224, 255, 0.1)
                );
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-bottom: 1px solid rgba(0, 224, 255, 0.2);
            }
        """)
        
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(20, 5, 20, 5)
        title_layout.setSpacing(15)
        
        # 标题
        title = QLabel("👀 实时预览")
        title.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-size: 16px;
                font-weight: 600;
                letter-spacing: 0.5px;
                background: transparent;
            }
        """)
        
        # 尺寸选择标签
        size_label = QLabel("尺寸:")
        size_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                background: transparent;
            }
        """)
        
        # 尺寸选择下拉框
        self.size_selector = QComboBox()
        self.size_selector.addItems(["小尺寸 (720×960)", "中尺寸 (1080×1440)", "大尺寸 (1440×1920)"])
        self.size_selector.setCurrentIndex(1)
        self.size_selector.setFixedWidth(150)
        self.size_selector.setStyleSheet(self.get_combobox_style())
        
        # 预览模式选择
        mode_label = QLabel("模式:")
        mode_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                background: transparent;
            }
        """)
        
        # 预览模式按钮组
        self.mode_group = QButtonGroup()
        
        self.fit_mode_btn = QRadioButton("适应窗口")
        self.fit_mode_btn.setChecked(True)
        self.fit_mode_btn.setStyleSheet(self.get_radio_style())
        
        self.actual_mode_btn = QRadioButton("实际大小")
        self.actual_mode_btn.setStyleSheet(self.get_radio_style())
        
        self.mode_group.addButton(self.fit_mode_btn, 0)
        self.mode_group.addButton(self.actual_mode_btn, 1)
        
        # 组装标题栏（移除了页面信息标签）
        title_layout.addWidget(title)
        title_layout.addSpacing(20)
        title_layout.addWidget(size_label)
        title_layout.addWidget(self.size_selector)
        title_layout.addSpacing(15)
        title_layout.addWidget(mode_label)
        title_layout.addWidget(self.fit_mode_btn)
        title_layout.addWidget(self.actual_mode_btn)
        title_layout.addStretch()
        
        return title_bar
    
    def create_web_view_container(self):
        """创建WebView容器（支持滚动）"""
        # 创建滚动区域容器
        self.web_container = QScrollArea()
        self.web_container.setStyleSheet("""
            QScrollArea {
                border: none;
                background: #1a1a2e;
            }
            QScrollBar:vertical {
                background: rgba(30, 30, 45, 0.5);
                width: 12px;
                border-radius: 6px;
                margin: 2px;
            }
            QScrollBar::handle:vertical {
                background: rgba(0, 224, 255, 0.3);
                border-radius: 6px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background: rgba(0, 224, 255, 0.5);
            }
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar:horizontal {
                background: rgba(30, 30, 45, 0.5);
                height: 12px;
                border-radius: 6px;
                margin: 2px;
            }
            QScrollBar::handle:horizontal {
                background: rgba(0, 224, 255, 0.3);
                border-radius: 6px;
                min-width: 30px;
            }
            QScrollBar::handle:horizontal:hover {
                background: rgba(0, 224, 255, 0.5);
            }
            QScrollBar::add-line:horizontal,
            QScrollBar::sub-line:horizontal {
                width: 0px;
            }
        """)
        
        # 创建WebView
        self.web_view = QWebEngineView()
        self.web_view.setStyleSheet("""
            QWebEngineView {
                border: none;
                background: #1a1a2e;
            }
        """)
        
        # 设置滚动区域
        self.web_container.setWidget(self.web_view)
        self.web_container.setWidgetResizable(False)  # 实际大小模式需要
        self.web_container.setAlignment(Qt.AlignCenter)  # 居中显示
        
        # 默认设置为适应窗口模式（不显示滚动条）
        self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    
    def create_control_bar(self):
        """创建控制栏"""
        control_bar = QFrame()
        control_bar.setFixedHeight(60)
        control_bar.setStyleSheet("""
            QFrame {
                background: rgba(20, 20, 35, 0.8);
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
                border-top: 1px solid rgba(0, 224, 255, 0.1);
            }
        """)
        
        control_layout = QHBoxLayout(control_bar)
        control_layout.setContentsMargins(20, 12, 20, 12)
        control_layout.setSpacing(15)
        
        # 创建中心控制区容器
        center_controls = QWidget()
        center_layout = QHBoxLayout(center_controls)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.setSpacing(15)
        
        # 上一页按钮
        self.prev_btn = QPushButton("⬅ 上一页")
        self.prev_btn.setFixedSize(100, 36)
        self.prev_btn.setStyleSheet(self.get_button_style())
        
        # 页面信息标签
        self.page_info_label = QLabel("")
        self.page_info_label.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-size: 14px;
                font-weight: 600;
                padding: 5px 15px;
                background: rgba(0, 224, 255, 0.05);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 12px;
                min-width: 100px;
                text-align: center;
            }
        """)
        self.page_info_label.setAlignment(Qt.AlignCenter)
        
        # 下一页按钮
        self.next_btn = QPushButton("下一页 ➡")
        self.next_btn.setFixedSize(100, 36)
        self.next_btn.setStyleSheet(self.get_button_style())
        
        # 组装中心控制区
        center_layout.addWidget(self.prev_btn)
        center_layout.addWidget(self.page_info_label)
        center_layout.addWidget(self.next_btn)
        
        # 快捷提示
        tips_label = QLabel("💡 提示: 使用鼠标滚轮或 ↑↓ 键翻页")
        tips_label.setStyleSheet("""
            QLabel {
                color: #6a7a8a;
                font-size: 11px;
                font-style: italic;
                background: transparent;
            }
        """)
        
        # 组装控制栏（居中显示控制按钮）
        control_layout.addStretch()
        control_layout.addWidget(center_controls)
        control_layout.addStretch()
        control_layout.addWidget(tips_label)
        
        return control_bar
    
    def connect_signals(self):
        """连接信号"""
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.size_selector.currentIndexChanged.connect(self.on_size_changed)
        self.mode_group.buttonClicked.connect(self.on_mode_changed)
    
    def eventFilter(self, obj, event):
        """事件过滤器 - 处理滚轮事件实现翻页"""
        if obj == self.web_view and event.type() == QEvent.Wheel:
            wheel_event = event
            
            # 在适应窗口模式下，滚轮直接翻页
            if self.preview_mode == "fit":
                if wheel_event.angleDelta().y() > 0:
                    self.prev_page()
                else:
                    self.next_page()
                return True  # 阻止默认滚动行为
            
            # 实际大小模式下，让滚动正常工作
            return False
        
        return super().eventFilter(obj, event)
    
    def keyPressEvent(self, event):
        """处理键盘事件"""
        if event.key() == Qt.Key_Up or event.key() == Qt.Key_PageUp:
            self.prev_page()
        elif event.key() == Qt.Key_Down or event.key() == Qt.Key_PageDown:
            self.next_page()
        elif event.key() == Qt.Key_Home:
            self.go_to_page(1)
        elif event.key() == Qt.Key_End:
            self.go_to_page(self.total_pages)
        else:
            super().keyPressEvent(event)
    
    def on_mode_changed(self):
        """处理预览模式改变"""
        if self.fit_mode_btn.isChecked():
            self.preview_mode = "fit"
            # 适应窗口模式：隐藏滚动条
            self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.web_container.setWidgetResizable(False)
        else:
            self.preview_mode = "actual"
            # 实际大小模式：显示滚动条
            self.web_container.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.web_container.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
            self.web_container.setWidgetResizable(False)
        
        # 重新渲染当前页面
        self.display_current_page()
    
    def on_size_changed(self, index):
        """处理尺寸改变"""
        size_map = {0: "small", 1: "medium", 2: "large"}
        new_size = size_map.get(index, "medium")
        
        if new_size != self.current_size:
            self.current_size = new_size
            
            # 更新各组件的尺寸设置
            self.html_generator = HTMLGenerator(page_size=new_size)
            self.paginator.set_page_size(new_size)
            
            # 重新处理内容
            if self.markdown_text:
                self.update_content(self.markdown_text)
            
            # 发送尺寸改变信号
            self.sizeChanged.emit(new_size)
    
    def update_content(self, markdown_text: str):
        """更新预览内容"""
        try:
            self.markdown_text = markdown_text
            
            # 处理 Markdown
            html_content = self.markdown_processor.parse(markdown_text)
            
            # 使用智能分页器进行分页
            self.current_pages = self.paginator.paginate(html_content)
            
            # 优化分页结果
            self.current_pages = self.paginator.optimize_pages(self.current_pages)
            
            self.total_pages = len(self.current_pages)
            self.current_page = 1
            
            # 显示第一页
            self.display_current_page()
            
            # 更新按钮和信息
            self.update_buttons()
            self.update_page_info()
            
        except Exception as e:
            self.show_error(f"预览错误: {str(e)}")
    
    def display_current_page(self):
        """显示当前页"""
        if not self.current_pages:
            return
            
        if 1 <= self.current_page <= len(self.current_pages):
            page_content = self.current_pages[self.current_page - 1]
            
            # 获取目标尺寸
            size_config = {
                "small": (720, 960),
                "medium": (1080, 1440),
                "large": (1440, 1920)
            }
            target_width, target_height = size_config.get(self.current_size, (1080, 1440))
            
            # 根据预览模式生成不同的HTML
            if self.preview_mode == "fit":
                # 适应窗口模式：使用缩放使内容适应视窗
                full_html = self.generate_fit_html(page_content)
                
                # 设置WebView尺寸为容器大小
                container_size = self.web_container.size()
                self.web_view.resize(container_size)
            else:
                # 实际大小模式：显示真实尺寸
                full_html = self.html_generator.generate(page_content)
                
                # 设置WebView为实际尺寸
                self.web_view.setFixedSize(target_width, target_height)
            
            # 加载到WebView
            self.web_view.setHtml(full_html, QUrl("file:///"))
    
    def generate_fit_html(self, content: str) -> str:
        """生成适应窗口的HTML"""
        # 获取容器尺寸
        container_width = self.web_container.width()
        container_height = self.web_container.height()
        
        # 获取目标尺寸
        size_config = {
            "small": (720, 960),
            "medium": (1080, 1440),
            "large": (1440, 1920)
        }
        target_width, target_height = size_config.get(self.current_size, (1080, 1440))
        
        # 计算缩放比例（保持比例，适应窗口）
        scale_x = (container_width - 40) / target_width  # 减去边距
        scale_y = (container_height - 40) / target_height
        scale = min(scale_x, scale_y, 1.0)  # 不超过原始大小
        
        # 生成带缩放的HTML
        html = self.html_generator.generate(content)
        
        # 注入缩放和居中样式
        scale_style = f"""
        <style>
            html, body {{
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                background: #1a1a2e;
            }}
            .scaled-container {{
                transform: scale({scale});
                transform-origin: center center;
                width: {target_width}px;
                height: {target_height}px;
            }}
            .page-container {{
                box-shadow: 0 4px 20px rgba(0, 224, 255, 0.15);
                width: {target_width}px !important;
                height: {target_height}px !important;
            }}
        </style>
        <script>
            // 包装页面内容
            window.onload = function() {{
                const pageContainer = document.querySelector('.page-container');
                if (pageContainer && !pageContainer.parentElement.classList.contains('scaled-container')) {{
                    const wrapper = document.createElement('div');
                    wrapper.className = 'scaled-container';
                    pageContainer.parentNode.insertBefore(wrapper, pageContainer);
                    wrapper.appendChild(pageContainer);
                }}
            }};
        </script>
        """
        
        # 插入缩放样式
        html = html.replace('</head>', scale_style + '</head>')
        
        return html
    
    def prev_page(self):
        """上一页"""
        if self.current_page > 1:
            self.go_to_page(self.current_page - 1)
    
    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages:
            self.go_to_page(self.current_page + 1)
    
    def go_to_page(self, page_num: int):
        """跳转到指定页"""
        if 1 <= page_num <= self.total_pages:
            self.current_page = page_num
            self.display_current_page()
            self.update_buttons()
            self.update_page_info()
    
    def update_buttons(self):
        """更新按钮状态"""
        self.prev_btn.setEnabled(self.current_page > 1)
        self.next_btn.setEnabled(self.current_page < self.total_pages)
        
        # 发送页面改变信号
        self.pageChanged.emit(self.current_page, self.total_pages)
    
    def update_page_info(self):
        """更新页面信息显示"""
        if self.total_pages > 1:
            self.page_info_label.setText(f"第 {self.current_page} / {self.total_pages} 页")
        else:
            self.page_info_label.setText("第 1 页")
    
    def get_button_style(self) -> str:
        """获取按钮样式"""
        return """
            QPushButton {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.15),
                    stop: 1 rgba(0, 150, 255, 0.1)
                );
                border: 1px solid rgba(0, 224, 255, 0.4);
                color: #00e0ff;
                padding: 8px 16px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 13px;
            }
            QPushButton:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.25),
                    stop: 1 rgba(0, 150, 255, 0.2)
                );
                border: 1px solid rgba(0, 224, 255, 0.6);
            }
            QPushButton:pressed {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.35),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
            }
            QPushButton:disabled {
                background: rgba(30, 30, 45, 0.5);
                border-color: rgba(100, 100, 120, 0.3);
                color: rgba(100, 100, 120, 0.5);
            }
        """
    
    def get_combobox_style(self) -> str:
        """获取下拉框样式"""
        return """
            QComboBox {
                background: rgba(0, 224, 255, 0.1);
                border: 1px solid rgba(0, 224, 255, 0.3);
                color: #00e0ff;
                padding: 5px 10px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 500;
            }
            QComboBox:hover {
                background: rgba(0, 224, 255, 0.15);
                border: 1px solid rgba(0, 224, 255, 0.5);
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 5px solid #00e0ff;
                margin-right: 5px;
            }
            QComboBox QAbstractItemView {
                background: rgba(25, 25, 40, 0.98);
                border: 1px solid rgba(0, 224, 255, 0.3);
                color: #00e0ff;
                selection-background-color: rgba(0, 224, 255, 0.2);
                outline: none;
            }
        """
    
    def get_radio_style(self) -> str:
        """获取单选按钮样式"""
        return """
            QRadioButton {
                color: #8a92a6;
                font-size: 12px;
                spacing: 5px;
            }
            QRadioButton::indicator {
                width: 14px;
                height: 14px;
                border: 2px solid rgba(0, 224, 255, 0.4);
                border-radius: 7px;
                background: transparent;
            }
            QRadioButton::indicator:checked {
                background: qradialgradient(
                    cx: 0.5, cy: 0.5, radius: 0.5,
                    fx: 0.5, fy: 0.5,
                    stop: 0 #00e0ff,
                    stop: 0.6 #00e0ff,
                    stop: 0.7 transparent
                );
                border-color: #00e0ff;
            }
            QRadioButton:checked {
                color: #00e0ff;
            }
        """
    
    def setup_exporter(self):
        """设置导出器"""
        self.exporter = ImageExporter(self.web_view)
        self.exporter.progress.connect(self.on_export_progress)
        self.exporter.finished.connect(self.on_export_finished)
        self.exporter.page_exported.connect(self.on_page_exported)
    
    def export_pages(self, folder: str):
        """导出所有页面为图片"""
        if not self.current_pages:
            QMessageBox.warning(self, "提示", "没有可导出的内容")
            return
        
        # 创建进度对话框
        self.progress_dialog = QProgressDialog(
            "正在导出图片...", 
            "取消", 
            0, 
            self.total_pages, 
            self
        )
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setMinimumDuration(0)
        self.progress_dialog.setAutoClose(False)
        self.progress_dialog.setAutoReset(False)
        self.progress_dialog.canceled.connect(self.on_export_canceled)
        
        # 开始导出（始终以实际大小导出）
        self.exporter.export_pages(
            self.current_pages,
            folder,
            self.html_generator,
            format="PNG",
            quality=100
        )
    
    def on_export_progress(self, current: int, total: int):
        """处理导出进度"""
        if hasattr(self, 'progress_dialog') and self.progress_dialog:
            self.progress_dialog.setValue(current)
            self.progress_dialog.setLabelText(f"正在导出第 {current}/{total} 页...")
    
    def on_export_finished(self, success: bool, message: str):
        """处理导出完成"""
        if hasattr(self, 'progress_dialog')
```

