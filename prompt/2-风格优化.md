### 用户:
项目背景 我正在开发一个 Windows 桌面应用「CardCraft」，核心目标是： - 用户输入 Markdown 文本 - 自动渲染成小红书风格的精美卡片 - 智能分页（3:4 比例，1080×1440px） - 批量导出高质量图片   # 技术栈 - 框架：PySide6 (Qt for Python) - 渲染：QWebEngineView (基于 Chromium) - Markdown解析：python-markdown + 扩展 - 样式：HTML + CSS (小红书风格) - 分页：JavaScript (在 WebEngine 中执行)   # 核心架构设计 ┌─────────────────────────────────────────┐ │           主窗口 (MainWindow)           │ ├─────────────┬──────────────┬────────────┤ │  编辑器组件  │   预览组件    │  工具栏   │ │ (QTextEdit) │(QWebEngineView)│ (QToolBar)│ └─────────────┴──────────────┴────────────┘ ↓ ┌──────────────┐ │ Markdown解析  │ └──────────────┘ ↓ ┌──────────────┐ │  HTML生成    │ └──────────────┘ ↓ ┌──────────────┐ │  智能分页    │ └──────────────┘ ↓ ┌──────────────┐ │  样式渲染    │ └──────────────┘ ↓ ┌──────────────┐ │  图片导出    │ └──────────────┘   # 项目结构
cardcraft/ ├── main.py                     # 启动程序，创建 Qt 应用 ├── requirements.txt            # 依赖包列表：PySide6、markdown 等 │ src/ ├── ui/ │   ├── main_window.py         # 主窗口：左右分栏布局，导出按钮，300ms延迟更新 │   ├── editor_widget.py       # 左侧编辑器：QTextEdit，含示例文本 │   ├── preview_widget.py      # 右侧预览：QWebEngineView，集成分页和导出功能 │    ├── core/ │   ├── markdown_processor.py  # Markdown 转 HTML：使用 python-markdown 库 │   ├── html_generator.py      # 生成完整网页：支持页码、多主题CSS样式 │    ├── utils/ │   ├── paginator.py           # ✅ 智能分页器：HTML元素解析、高度估算、分页优化 │   ├── exporter.py            # ✅ 图片导出器：批量导出、进度追踪、水印添加 │   ├── style_manager.py       # ✅ 样式管理器：多主题支持（小红书/Instagram/微信/知乎/深色） │    ├── resources/ │   ├── styles/                # �� 预留：未来可存放独立CSS文件 │   └── templates/             # �� 预留：未来可存放HTML模板文件# 核心功能需求   ## 1. 智能分页算法 - 每页固定尺寸：1080×1440px (3:4比例) - 分页原则：   * 段落完整性：不在段落中间分页   * 标题关联：标题与其后续内容保持同页   * 列表连续：列表项尽量不分离   * 代码完整：代码块不跨页   * 视觉平衡：避免页面过空或过满   ## 2. 样式系统 - 预设主题：小红书、Instagram、微信、知乎等 - 样式要素：   * 字体：中文用苹方/微软雅黑，西文用 Helvetica   * 颜色：主色 `#FF2442`，文字 `#333333`   * 间距：段落间距 20px，行高 1.8   * 特效：卡片阴影、圆角、渐变背景   ## 3. 渲染流程 ```python # 伪代码示例 markdown_text → parse_markdown() → generate_html() → apply_styles() → paginate() → render_preview() → export_images() 4. 导出功能   格式：PNG/JPEG 质量：支持 1x/2x/3x 分辨率 命名：自动编号，如 card_01.png, card_02.png 批量：一次导出所有分页   代码规范   使用类型注解 (typing) 遵循 PEP 8 中文注释说明关键逻辑 错误处理要完善   性能要求   实时预览延迟 < 300ms 支持 10000 字的文档 导出速度：每张卡片 < 1秒   问题描述 目前屏幕太固定了，我希望有相同比例的 小-中-大三个尺寸（字体不变，我想要的思路是，就是大的页面可以放更多的内容，小的放的少，信息量的区别），然后多几种配色样式风格 期望输出 ：首先分析多步步骤，并一步一步完成，先完成第一步。修改问题的代码；若修改小则直接告诉我位置，我个人进行修改；若变动大，则给我这个文件的完整代码
html_generator.py->text/plain-># ============================================
# src/core/html_generator.py
# ============================================
from pathlib import Path
from typing import Optional

class HTMLGenerator:
    def __init__(self, font_size: int = 18):
        self.resource_path = Path(__file__).parent.parent / "resources"
        self.base_font_size = font_size  # 基础字体大小，默认18px
        
    def generate(self, content: str) -> str:
        """
        生成完整的 HTML 页面（无水印和页码）
        
        Args:
            content: HTML内容
        """
        css = self.get_css()
        js = self.get_js()
        
        html = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小红书卡片</title>
    <style>{css}</style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="content" id="content">
                {content}
            </div>
        </div>
    </div>
    <script>{js}</script>
</body>
</html>
"""
        return html
        
    def set_font_size(self, size: int):
        """设置基础字体大小"""
        self.base_font_size = size
        
    def get_css(self) -> str:
        """获取优化后的CSS样式（更大字体，无水印）"""
        # 动态计算字体大小
        base = self.base_font_size
        
        return f"""
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        /* 固定HTML和body尺寸，禁用滚动 */
        html, body {{
            width: 1080px;
            height: 1440px;
            overflow: hidden !important;
        }}
        
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", 
                        "Helvetica Neue", "Hiragino Sans GB", "Microsoft YaHei UI",
                        "Microsoft YaHei", Arial, sans-serif;
            background: linear-gradient(135deg, #ffeef8 0%, #ffe0f0 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            font-size: {base}px;  /* 基础字体从16px增加到18px */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }}
        
        .container {{
            width: 1080px;
            height: 1440px;
            position: relative;
        }}
        
        .card {{
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(255, 36, 66, 0.08),
                        0 2px 10px rgba(0, 0, 0, 0.06);
            overflow: hidden;
            position: relative;
        }}
        
        .content {{
            padding: 50px 45px 50px 45px;  /* 稍微增加内边距 */
            color: #2c3e50;
            line-height: 1.85;  /* 稍微增加行高 */
            height: 100%;
            overflow: hidden !important;
            position: relative;
        }}
        
        /* 标题样式 - 相应放大 */
        h1 {{
            color: #FF2442;
            font-size: {base + 16}px;  /* 34px */
            margin-bottom: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
            border-bottom: 3px solid #FFE4E4;
            padding-bottom: 16px;
        }}
        
        h2 {{
            color: #FF2442;
            font-size: {base + 10}px;  /* 28px */
            margin-top: 38px;
            margin-bottom: 22px;
            font-weight: 600;
            position: relative;
            padding-left: 20px;
        }}
        
        h2::before {{
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 24px;
            background: linear-gradient(180deg, #FF2442, #FF6B6B);
            border-radius: 3px;
        }}
        
        h3 {{
            color: #34495e;
            font-size: {base + 5}px;  /* 23px */
            margin-top: 30px;
            margin-bottom: 18px;
            font-weight: 600;
        }}
        
        h4 {{
            color: #34495e;
            font-size: {base + 2}px;  /* 20px */
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
        }}
        
        /* 段落样式 */
        p {{
            margin-bottom: 22px;
            font-size: {base}px;  /* 18px */
            color: #4a5568;
            text-align: justify;
            line-height: 1.85;
        }}
        
        /* 强调样式 */
        strong {{
            color: #FF2442;
            font-weight: 600;
            background: linear-gradient(180deg, transparent 70%, #FFE4E4 70%);
            padding: 0 4px;
        }}
        
        em {{
            font-style: italic;
            color: #718096;
        }}
        
        /* 列表样式 */
        ul, ol {{
            margin: 24px 0;
            padding-left: 38px;
        }}
        
        li {{
            margin-bottom: 16px;
            font-size: {base}px;  /* 18px */
            color: #4a5568;
            line-height: 1.85;
        }}
        
        ul li::marker {{
            color: #FF2442;
            font-size: {base + 2}px;  /* 20px */
        }}
        
        ol li::marker {{
            color: #FF2442;
            font-weight: 600;
        }}
        
        /* 引用样式 */
        blockquote {{
            border-left: 4px solid #FF2442;
            margin: 28px 0;
            padding: 20px 28px;
            background: linear-gradient(90deg, #FFF8F8 0%, #FFFFFF 100%);
            border-radius: 10px;
            position: relative;
        }}
        
        blockquote::before {{
            content: '"';
            position: absolute;
            top: -10px;
            left: 24px;
            font-size: 48px;
            color: #FFE4E4;
            font-family: Georgia, serif;
        }}
        
        blockquote p {{
            color: #6b7280;
            font-style: italic;
            margin-bottom: 0;
            font-size: {base - 1}px;  /* 17px */
        }}
        
        /* 行内代码 */
        code {{
            background: #FFF5F5;
            padding: 4px 10px;
            border-radius: 6px;
            font-family: "JetBrains Mono", "Cascadia Code", "Consolas", "Monaco", monospace;
            font-size: {base - 2}px;  /* 16px */
            color: #e53e3e;
            font-weight: 500;
        }}
        
        /* 代码块 */
        pre {{
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 26px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 28px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            position: relative;
            max-width: 100%;
        }}
        
        pre::before {{
            content: "CODE";
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 11px;
            color: #6b7280;
            font-weight: 600;
            letter-spacing: 1px;
            opacity: 0.5;
        }}
        
        pre code {{
            background: none;
            color: #d4d4d4;
            padding: 0;
            font-size: {base - 3}px;  /* 15px */
            line-height: 1.7;
        }}
        
        /* 表格样式 */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 28px 0;
            font-size: {base - 1}px;  /* 17px */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.04);
            border-radius: 10px;
            overflow: hidden;
        }}
        
        th {{
            background: linear-gradient(135deg, #FF2442, #FF6B6B);
            color: white;
            padding: 15px 20px;
            text-align: left;
            font-weight: 600;
            font-size: {base - 1}px;  /* 17px */
        }}
        
        td {{
            padding: 15px 20px;
            border-bottom: 1px solid #f0f0f0;
            color: #4a5568;
        }}
        
        tr:nth-child(even) {{
            background: #FAFAFA;
        }}
        
        tr:hover {{
            background: #FFF5F5;
        }}
        
        tr:last-child td {{
            border-bottom: none;
        }}
        
        /* 分隔线 */
        hr {{
            border: none;
            height: 1px;
            background: linear-gradient(90deg, transparent, #FFE4E4 20%, #FFE4E4 80%, transparent);
            margin: 38px 0;
        }}
        
        /* 链接样式 */
        a {{
            color: #FF2442;
            text-decoration: none;
            border-bottom: 1px solid #FFD0D7;
            transition: all 0.3s ease;
            padding-bottom: 1px;
        }}
        
        a:hover {{
            color: #FF6B6B;
            border-bottom-color: #FF6B6B;
            background: #FFF5F5;
            padding: 0 4px;
            margin: 0 -4px;
            border-radius: 3px;
        }}
        
        /* 隐藏所有滚动条 */
        ::-webkit-scrollbar {{
            display: none !important;
        }}
        
        * {{
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }}
        
        /* 打印样式 */
        @media print {{
            body {{
                background: white;
                padding: 0;
            }}
            
            .container {{
                max-width: 100%;
            }}
            
            .card {{
                box-shadow: none;
                border-radius: 0;
                page-break-inside: avoid;
            }}
        }}
        
        /* 动画效果 */
        @keyframes fadeIn {{
            from {{
                opacity: 0;
                transform: translateY(10px);
            }}
            to {{
                opacity: 1;
                transform: translateY(0);
            }}
        }}
        
        .content > * {{
            animation: fadeIn 0.5s ease-out;
        }}
        """
    
    def get_js(self) -> str:
        """获取JavaScript代码（简化版）"""
        return """
        // 页面加载完成后的处理
        document.addEventListener('DOMContentLoaded', function() {
            // 添加淡入动画
            const content = document.getElementById('content');
            if (content) {
                content.style.opacity = '0';
                content.style.transition = 'opacity 0.5s ease-in';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 100);
            }
            
            // 图片自适应
            const images = document.querySelectorAll('img');
            images.forEach(img => {
                img.loading = 'lazy';
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                img.style.borderRadius = '8px';
                img.style.margin = '16px 0';
            });
            
            // 确保内容不超出
            function ensureContentFit() {
                const card = document.querySelector('.card');
                const content = document.querySelector('.content');
                if (card && content) {
                    content.style.maxHeight = '100%';
                    content.style.overflow = 'hidden';
                }
            }
            
            ensureContentFit();
            window.addEventListener('resize', ensureContentFit);
        });
        
        // 禁用所有滚动
        window.addEventListener('scroll', function(e) {
            e.preventDefault();
            window.scrollTo(0, 0);
        }, { passive: false });
        
        window.addEventListener('wheel', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        window.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
        """ markdown_processor.py->text/plain-># ============================================
# src/core/markdown_processor.py
# ============================================
import markdown
from markdown.extensions import fenced_code, tables

class MarkdownProcessor:
    def __init__(self):
        # 只使用必要且稳定的扩展
        self.extensions = [
            'markdown.extensions.fenced_code',  # 代码块
            'markdown.extensions.tables',       # 表格
            'markdown.extensions.nl2br',        # 换行转<br>
            'markdown.extensions.attr_list',    # 属性列表
            'markdown.extensions.def_list',     # 定义列表
            'markdown.extensions.footnotes',    # 脚注
            'markdown.extensions.toc',          # 目录
            'markdown.extensions.sane_lists',   # 改进的列表
            'markdown.extensions.smarty',       # 智能标点
        ]
        
        # 配置扩展（移除不支持的 css_class 参数）
        self.extension_configs = {}
        
    def parse(self, text: str) -> str:
        """解析 Markdown 文本为 HTML"""
        try:
            # 创建新的 Markdown 实例（避免状态污染）
            md = markdown.Markdown(
                extensions=self.extensions,
                extension_configs=self.extension_configs
            )
            
            # 转换 Markdown 为 HTML
            html = md.convert(text)
            
            # 后处理：添加小红书特色 emoji 支持
            html = self._process_emojis(html)
            
            return html
            
        except Exception as e:
            print(f"Markdown 解析错误: {e}")
            return f"<p style='color: red;'>解析错误: {str(e)}</p>"
    
    def _process_emojis(self, html: str) -> str:
        """处理 emoji 表情"""
        # 保持 emoji 原样显示
        return html style_manager.py->text/plain-> editor_widget.py->text/plain-># ============================================
# src/ui/editor_widget.py
# ============================================
from PySide6.QtWidgets import QTextEdit, QVBoxLayout, QWidget, QLabel, QFrame
from PySide6.QtGui import QFont, QTextOption, QPalette, QColor
from PySide6.QtCore import Signal, Qt

class EditorWidget(QWidget):
    textChanged = Signal()
    scrollChanged = Signal(float)  # 发送滚动百分比
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 创建容器框架
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: rgba(25, 25, 40, 0.95);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 16px;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        
        # 标题栏
        title_bar = QFrame()
        title_bar.setFixedHeight(50)
        title_bar.setStyleSheet("""
            QFrame {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.1),
                    stop: 0.5 rgba(0, 150, 255, 0.15),
                    stop: 1 rgba(0, 224, 255, 0.1)
                );
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-bottom: 1px solid rgba(0, 224, 255, 0.2);
                padding: 12px 20px;
            }
        """)
        title_layout = QVBoxLayout(title_bar)
        
        title = QLabel("✍️ Markdown 编辑器")
        title.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-size: 16px;
                font-weight: 600;
                letter-spacing: 0.5px;
            }
        """)
        title_layout.addWidget(title)
        
        # 编辑器
        self.editor = QTextEdit()
        self.editor.setFont(QFont("Cascadia Code, Consolas, Monaco", 12))
        self.editor.setLineWrapMode(QTextEdit.WidgetWidth)
        self.editor.setWordWrapMode(QTextOption.WordWrap)
        
        # 设置编辑器样式
        self.editor.setStyleSheet("""
            QTextEdit {
                border: none;
                padding: 25px;
                background-color: rgba(15, 15, 25, 0.6);
                color: #e0e6ed;
                selection-background-color: rgba(0, 224, 255, 0.3);
                selection-color: #ffffff;
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
                font-size: 14px;
                line-height: 1.6;
            }
            QScrollBar:vertical {
                background: rgba(20, 20, 35, 0.5);
                width: 12px;
                border-radius: 6px;
                margin: 5px;
            }
            QScrollBar::handle:vertical {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border-radius: 6px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 150, 255, 0.5)
                );
            }
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                border: none;
                background: none;
                height: 0;
            }
            QScrollBar:horizontal {
                background: rgba(20, 20, 35, 0.5);
                height: 12px;
                border-radius: 6px;
                margin: 5px;
            }
            QScrollBar::handle:horizontal {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border-radius: 6px;
                min-width: 30px;
            }
            QScrollBar::handle:horizontal:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 150, 255, 0.5)
                );
            }
            QScrollBar::add-line:horizontal,
            QScrollBar::sub-line:horizontal {
                border: none;
                background: none;
                width: 0;
            }
        """)
        
        # 设置默认文本
        self.editor.setPlainText("""# 🌸 小红书笔记标题

## 今日分享

大家好呀～今天给大家分享一个超实用的 **Markdown 编辑器**！

### ✨ 主要功能

1. **实时预览** - 左边写，右边看
2. **智能分页** - 自动适配小红书卡片尺寸
3. **一键导出** - 批量生成精美图片

### 📝 使用方法

- 在左侧输入 Markdown 文本
- 右侧实时显示预览效果
- 点击导出按钮保存图片

> 💡 小贴士：支持所有常用的 Markdown 语法哦～

### 代码示例

```python
def hello():
    print("Hello, 小红书!")
    return "❤️"
```

### 表格示例

| 功能 | 描述 | 状态 |
|------|------|------|
| 编辑 | Markdown编辑器 | ✅ |
| 预览 | 实时渲染 | ✅ |
| 导出 | 图片生成 | ✅ |

---

喜欢的话记得 **点赞收藏** 哦～ ❤️

关注我，获取更多实用工具！""")
        
        # 连接信号
        self.editor.textChanged.connect(self.textChanged.emit)
        self.editor.verticalScrollBar().valueChanged.connect(self.on_scroll)
        
        # 组装布局
        container_layout.addWidget(title_bar)
        container_layout.addWidget(self.editor)
        
        layout.addWidget(container)
        
    def get_text(self):
        """获取编辑器文本"""
        return self.editor.toPlainText()
    
    def on_scroll(self):
        """处理滚动事件"""
        scrollbar = self.editor.verticalScrollBar()
        if scrollbar.maximum() > 0:
            percentage = scrollbar.value() / scrollbar.maximum()
            self.scrollChanged.emit(percentage) main_window.py->text/plain-># ============================================
# src/ui/main_window.py
# ============================================
from PySide6.QtWidgets import (QMainWindow, QHBoxLayout, QVBoxLayout, 
                               QWidget, QToolBar, QSplitter, QPushButton,
                               QFileDialog, QMessageBox, QStatusBar, QLabel,
                               QGraphicsDropShadowEffect)
from PySide6.QtCore import Qt, QTimer
from PySide6.QtGui import QAction, QIcon, QColor
from src.ui.editor_widget import EditorWidget
from src.ui.preview_widget import PreviewWidget

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # 先创建自动更新计时器
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_preview)
        self.update_timer.setInterval(300)  # 300ms延迟
        
        # 然后初始化UI
        self.init_ui()
        self.setup_connections()
        
    def init_ui(self):
        """初始化UI"""
        self.setWindowTitle("📝 小红书 Markdown 编辑器")
        self.setGeometry(100, 100, 1700, 950)
        
        # 设置窗口样式 - 深色科技风背景
        self.setStyleSheet("""
            QMainWindow {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 1,
                    stop: 0 #0f0f1e,
                    stop: 0.5 #1a1a2e, 
                    stop: 1 #16213e
                );
            }
        """)
        
        # 创建工具栏
        toolbar = QToolBar()
        toolbar.setMovable(False)
        toolbar.setFixedHeight(65)
        toolbar.setStyleSheet("""
            QToolBar {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(30, 30, 45, 0.95),
                    stop: 1 rgba(20, 20, 35, 0.98)
                );
                border: none;
                border-bottom: 2px solid rgba(0, 224, 255, 0.3);
                padding: 10px 15px;
                spacing: 12px;
            }
            QToolButton {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.15),
                    stop: 1 rgba(0, 150, 255, 0.1)
                );
                border: 1px solid rgba(0, 224, 255, 0.4);
                border-radius: 10px;
                padding: 10px 20px;
                color: #00e0ff;
                font-weight: 600;
                font-size: 14px;
                margin: 0 5px;
                letter-spacing: 0.5px;
                min-width: 120px;
            }
            QToolButton:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.25),
                    stop: 1 rgba(0, 150, 255, 0.2)
                );
                border: 1px solid rgba(0, 224, 255, 0.6);
                color: #00f0ff;
            }
            QToolButton:pressed {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.35),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border: 1px solid #00e0ff;
                color: white;
            }
        """)
        self.addToolBar(toolbar)
        
        # 添加工具栏按钮
        export_action = QAction("📸 导出图片", self)
        export_action.triggered.connect(self.export_images)
        toolbar.addAction(export_action)
        
        toolbar.addSeparator()
        
        clear_action = QAction("🗑️ 清空内容", self)
        clear_action.triggered.connect(self.clear_content)
        toolbar.addAction(clear_action)
        
        # 创建状态栏
        self.status_bar = QStatusBar()
        self.status_bar.setFixedHeight(35)
        self.status_bar.setStyleSheet("""
            QStatusBar {
                background: rgba(20, 20, 35, 0.95);
                color: #8a92a6;
                border-top: 1px solid rgba(0, 224, 255, 0.2);
                padding: 6px 15px;
                font-size: 13px;
            }
            QStatusBar::item {
                border: none;
            }
        """)
        self.setStatusBar(self.status_bar)
        
        # 添加状态栏信息
        self.char_count_label = QLabel("字数: 0")
        self.char_count_label.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-weight: 500;
                padding: 4px 12px;
                background: rgba(0, 224, 255, 0.1);
                border: 1px solid rgba(0, 224, 255, 0.3);
                border-radius: 12px;
            }
        """)
        self.status_bar.addPermanentWidget(self.char_count_label)
        
        # 创建中心部件
        central_widget = QWidget()
        central_widget.setStyleSheet("""
            QWidget {
                background: transparent;
            }
        """)
        self.setCentralWidget(central_widget)
        
        # 创建布局
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(25, 25, 25, 25)
        layout.setSpacing(20)
        
        # 创建分割器
        splitter = QSplitter(Qt.Horizontal)
        splitter.setStyleSheet("""
            QSplitter::handle {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.2),
                    stop: 0.5 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 224, 255, 0.2)
                );
                width: 3px;
                border-radius: 1px;
            }
            QSplitter::handle:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.3),
                    stop: 0.5 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 224, 255, 0.3)
                );
            }
        """)
        
        # 创建编辑器和预览组件
        self.editor = EditorWidget()
        self.preview = PreviewWidget()
        
        # 添加阴影效果
        self.add_shadow_effect(self.editor)
        self.add_shadow_effect(self.preview)
        
        # 添加到分割器
        splitter.addWidget(self.editor)
        splitter.addWidget(self.preview)
        splitter.setSizes([850, 850])  # 设置初始宽度
        
        layout.addWidget(splitter)
        
        # 初始更新
        self.update_preview()
        self.update_char_count()
    
    def add_shadow_effect(self, widget):
        """为组件添加阴影效果"""
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(30)
        shadow.setXOffset(0)
        shadow.setYOffset(5)
        shadow.setColor(QColor(0, 224, 255, 50))
        widget.setGraphicsEffect(shadow)
        
    def setup_connections(self):
        """设置信号连接"""
        self.editor.textChanged.connect(self.on_text_changed)
        self.editor.scrollChanged.connect(self.preview.handle_scroll)
        self.preview.pageChanged.connect(self.on_page_changed)
        
    def on_text_changed(self):
        """文本改变时启动计时器"""
        self.update_timer.stop()
        self.update_timer.start()
        self.update_char_count()
        
    def update_preview(self):
        """更新预览"""
        self.update_timer.stop()
        markdown_text = self.editor.get_text()
        self.preview.update_content(markdown_text)
        
    def update_char_count(self):
        """更新字数统计"""
        text = self.editor.get_text()
        char_count = len(text.replace(" ", "").replace("\n", ""))
        self.char_count_label.setText(f"字数: {char_count}")
        
    def on_page_changed(self, current, total):
        """页码改变时更新状态栏"""
        self.status_bar.showMessage(f"页面: {current}/{total}", 2000)
        
    def clear_content(self):
        """清空内容"""
        reply = QMessageBox.question(
            self, "确认清空",
            "确定要清空所有内容吗？",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.editor.editor.clear()
            
    def export_images(self):
        """导出图片"""
        folder = QFileDialog.getExistingDirectory(self, "选择导出文件夹")
        if folder:
            try:
                self.preview.export_pages(folder)
                QMessageBox.information(
                    self, "导出成功",
                    f"图片已成功导出到:\n{folder}",
                    QMessageBox.Ok
                )
            except Exception as e:
                QMessageBox.critical(
                    self, "导出失败",
                    f"导出过程中出现错误:\n{str(e)}",
                    QMessageBox.Ok
                ) preview_widget.py->text/plain-># ============================================
# src/ui/preview_widget.py
# ============================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QFrame, 
                               QPushButton, QHBoxLayout, QProgressDialog,
                               QMessageBox, QScrollArea, QSlider)
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtCore import QUrl, QTimer, Signal, Qt, QSize
from pathlib import Path
from src.core.markdown_processor import MarkdownProcessor
from src.core.html_generator import HTMLGenerator
from src.utils.paginator import SmartPaginator
from src.utils.exporter import ImageExporter

class PreviewWidget(QWidget):
    pageChanged = Signal(int, int)  # 当前页，总页数
    
    def __init__(self):
        super().__init__()
        self.current_pages = []  # 存储分页后的HTML内容
        self.current_page = 1
        self.total_pages = 1
        self.markdown_text = ""  # 保存原始markdown文本
        self.current_zoom = 1.0  # 当前缩放比例
        self.init_ui()
        self.setup_exporter()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 创建容器框架
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: rgba(25, 25, 40, 0.95);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 16px;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        
        # 标题栏
        title_bar = QFrame()
        title_bar.setFixedHeight(50)
        title_bar.setStyleSheet("""
            QFrame {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.1),
                    stop: 0.5 rgba(0, 150, 255, 0.15),
                    stop: 1 rgba(0, 224, 255, 0.1)
                );
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-bottom: 1px solid rgba(0, 224, 255, 0.2);
                padding: 12px 20px;
            }
        """)
        title_layout = QHBoxLayout(title_bar)
        
        title = QLabel("👀 实时预览")
        title.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-size: 16px;
                font-weight: 600;
                letter-spacing: 0.5px;
            }
        """)
        
        # 缩放显示标签
        self.zoom_label = QLabel("100%")
        self.zoom_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                padding: 0 10px;
            }
        """)
        
        title_layout.addWidget(title)
        title_layout.addStretch()
        title_layout.addWidget(self.zoom_label)
        
        # 创建滚动区域来包含 WebView（固定尺寸）
        self.scroll_area = QScrollArea()
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                border: none;
                background: #2a2a3e;
            }
            QScrollBar:vertical {
                background: rgba(20, 20, 35, 0.5);
                width: 12px;
                border-radius: 6px;
                margin: 5px;
            }
            QScrollBar::handle:vertical {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border-radius: 6px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 150, 255, 0.5)
                );
            }
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                border: none;
                background: none;
                height: 0;
            }
            QScrollBar:horizontal {
                background: rgba(20, 20, 35, 0.5);
                height: 12px;
                border-radius: 6px;
                margin: 5px;
            }
            QScrollBar::handle:horizontal {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border-radius: 6px;
                min-width: 30px;
            }
            QScrollBar::handle:horizontal:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 150, 255, 0.5)
                );
            }
            QScrollBar::add-line:horizontal,
            QScrollBar::sub-line:horizontal {
                border: none;
                background: none;
                width: 0;
            }
        """)
        
        # Web视图 - 设置固定尺寸
        self.web_view = QWebEngineView()
        # 设置固定尺寸为小红书卡片尺寸
        self.web_view.setFixedSize(1080, 1440)
        self.web_view.setStyleSheet("""
            QWebEngineView {
                border: none;
                background: white;
            }
        """)
        
        # 禁用 WebView 的滚动条
        self.web_view.page().settings().setAttribute(
            self.web_view.page().settings().WebAttribute.ShowScrollBars, False
        )
        
        # 设置滚动区域
        self.scroll_area.setWidget(self.web_view)
        self.scroll_area.setWidgetResizable(False)  # 不自动调整大小
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setAlignment(Qt.AlignCenter)  # 居中显示
        
        # 翻页控制栏
        control_bar = QFrame()
        control_bar.setFixedHeight(60)
        control_bar.setStyleSheet("""
            QFrame {
                background: rgba(20, 20, 35, 0.8);
                padding: 10px 20px;
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
                border-top: 1px solid rgba(0, 224, 255, 0.1);
            }
        """)
        control_layout = QHBoxLayout(control_bar)
        
        self.prev_btn = QPushButton("⬅ 上一页")
        self.prev_btn.setFixedSize(100, 36)
        self.prev_btn.setStyleSheet(self.get_button_style())
        
        self.next_btn = QPushButton("下一页 ➡")
        self.next_btn.setFixedSize(100, 36)
        self.next_btn.setStyleSheet(self.get_button_style())
        
        # 缩放滑块
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setRange(25, 150)  # 25% - 150%
        self.zoom_slider.setValue(100)  # 默认100%
        self.zoom_slider.setFixedWidth(200)
        self.zoom_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                height: 6px;
                background: rgba(0, 224, 255, 0.2);
                border-radius: 3px;
            }
            QSlider::handle:horizontal {
                width: 18px;
                height: 18px;
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 #00e0ff,
                    stop: 1 #0096ff
                );
                border-radius: 9px;
                margin: -6px 0;
            }
            QSlider::handle:horizontal:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 #00f0ff,
                    stop: 1 #00a6ff
                );
            }
        """)
        
        # 缩放按钮
        self.zoom_fit_btn = QPushButton("🔍 适应窗口")
        self.zoom_fit_btn.setFixedSize(100, 36)
        self.zoom_fit_btn.setStyleSheet(self.get_button_style())
        
        self.zoom_100_btn = QPushButton("📐 100%")
        self.zoom_100_btn.setFixedSize(80, 36)
        self.zoom_100_btn.setStyleSheet(self.get_button_style())
        
        control_layout.addWidget(self.prev_btn)
        control_layout.addSpacing(20)
        control_layout.addWidget(QLabel("缩放:", styleSheet="color: #8a92a6;"))
        control_layout.addWidget(self.zoom_slider)
        control_layout.addWidget(self.zoom_100_btn)
        control_layout.addWidget(self.zoom_fit_btn)
        control_layout.addStretch()
        control_layout.addWidget(self.next_btn)
        
        # 组装布局
        container_layout.addWidget(title_bar)
        container_layout.addWidget(self.scroll_area, 1)
        container_layout.addWidget(control_bar)
        
        layout.addWidget(container)
        
        # 处理器
        self.markdown_processor = MarkdownProcessor()
        self.html_generator = HTMLGenerator()
        self.paginator = SmartPaginator()
        
        # 连接信号
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        self.zoom_fit_btn.clicked.connect(self.zoom_to_fit)
        self.zoom_100_btn.clicked.connect(self.zoom_to_100)
        
        # 初始化按钮状态
        self.update_buttons()
        
        # 延迟自适应（等待窗口完全加载）
        QTimer.singleShot(500, self.zoom_to_fit)
    
    def get_button_style(self) -> str:
        """获取按钮样式"""
        return """
            QPushButton {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.15),
                    stop: 1 rgba(0, 150, 255, 0.1)
                );
                border: 1px solid rgba(0, 224, 255, 0.4);
                color: #00e0ff;
                padding: 8px 16px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 13px;
            }
            QPushButton:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.25),
                    stop: 1 rgba(0, 150, 255, 0.2)
                );
                border: 1px solid rgba(0, 224, 255, 0.6);
            }
            QPushButton:pressed {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.35),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
            }
            QPushButton:disabled {
                background: rgba(30, 30, 45, 0.5);
                border-color: rgba(100, 100, 120, 0.3);
                color: rgba(100, 100, 120, 0.5);
            }
        """
    
    def on_zoom_changed(self, value):
        """处理缩放滑块变化"""
        zoom = value / 100.0
        self.set_zoom(zoom)
    
    def set_zoom(self, zoom_factor):
        """设置缩放比例"""
        self.current_zoom = zoom_factor
        self.web_view.setZoomFactor(zoom_factor)
        self.zoom_label.setText(f"{int(zoom_factor * 100)}%")
        
        # 不需要改变滑块值时的信号阻塞
        self.zoom_slider.blockSignals(True)
        self.zoom_slider.setValue(int(zoom_factor * 100))
        self.zoom_slider.blockSignals(False)
    
    def zoom_to_fit(self):
        """缩放到适应窗口"""
        if self.scroll_area and self.web_view:
            # 获取滚动区域的可视大小
            viewport_size = self.scroll_area.viewport().size()
            
            # 卡片固定尺寸
            card_width = 1080
            card_height = 1440
            
            # 计算缩放比例（留出一些边距）
            margin = 20
            scale_x = (viewport_size.width() - margin * 2) / card_width
            scale_y = (viewport_size.height() - margin * 2) / card_height
            scale = min(scale_x, scale_y, 1.0)  # 不超过100%
            
            # 应用缩放
            self.set_zoom(scale)
    
    def zoom_to_100(self):
        """恢复100%大小"""
        self.set_zoom(1.0)
    
    def setup_exporter(self):
        """设置导出器"""
        self.exporter = ImageExporter(self.web_view)
        self.exporter.progress.connect(self.on_export_progress)
        self.exporter.finished.connect(self.on_export_finished)
        self.exporter.page_exported.connect(self.on_page_exported)
        
    def update_content(self, markdown_text: str):
        """更新预览内容"""
        try:
            self.markdown_text = markdown_text
            
            # 处理 Markdown
            html_content = self.markdown_processor.parse(markdown_text)
            
            # 使用智能分页器进行分页
            self.current_pages = self.paginator.paginate(html_content)
            
            # 优化分页结果
            self.current_pages = self.paginator.optimize_pages(self.current_pages)
            
            self.total_pages = len(self.current_pages)
            self.current_page = 1
            
            # 显示第一页
            self.display_current_page()
            
            # 更新按钮
            self.update_buttons()
            
            # 保持当前缩放比例
            QTimer.singleShot(100, lambda: self.set_zoom(self.current_zoom))
            
        except Exception as e:
            self.show_error(f"预览错误: {str(e)}")
    
    def display_current_page(self):
        """显示当前页"""
        if not self.current_pages:
            return
            
        if 1 <= self.current_page <= len(self.current_pages):
            page_content = self.current_pages[self.current_page - 1]
            
            # 生成完整HTML
            full_html = self.html_generator.generate(page_content)
            
            # 加载到WebView
            self.web_view.setHtml(full_html, QUrl("file:///"))
    
    def prev_page(self):
        """上一页"""
        if self.current_page > 1:
            self.current_page -= 1
            self.display_current_page()
            self.update_buttons()
    
    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.display_current_page()
            self.update_buttons()
    
    def update_buttons(self):
        """更新按钮状态"""
        self.prev_btn.setEnabled(self.current_page > 1)
        self.next_btn.setEnabled(self.current_page < self.total_pages)
        
        # 更新标题栏显示（如果有多页）
        if self.total_pages > 1:
            page_info = f" (第 {self.current_page}/{self.total_pages} 页)"
            # 可以将页码信息添加到标题栏
    
    def export_pages(self, folder: str):
        """导出所有页面为图片"""
        if not self.current_pages:
            QMessageBox.warning(self, "提示", "没有可导出的内容")
            return
        
        # 创建进度对话框
        self.progress_dialog = QProgressDialog(
            "正在导出图片...", 
            "取消", 
            0, 
            self.total_pages, 
            self
        )
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setMinimumDuration(0)
        self.progress_dialog.canceled.connect(self.on_export_canceled)
        
        # 导出前恢复100%大小（确保导出的是原始尺寸）
        original_zoom = self.current_zoom
        self.web_view.setZoomFactor(1.0)
        
        # 开始导出
        self.exporter.export_pages(
            self.current_pages,
            folder,
            self.html_generator,
            format="PNG",
            quality=100
        )
        
        # 保存原始缩放比例，导出完成后恢复
        self._original_zoom_for_export = original_zoom
    
    def on_export_progress(self, current: int, total: int):
        """处理导出进度"""
        if hasattr(self, 'progress_dialog'):
            self.progress_dialog.setValue(current)
            self.progress_dialog.setLabelText(f"正在导出第 {current}/{total} 页...")
    
    def on_export_finished(self, success: bool, message: str):
        """处理导出完成"""
        # 关闭进度对话框
        if hasattr(self, 'progress_dialog') and self.progress_dialog is not None:
            try:
                self.progress_dialog.close()
                self.progress_dialog.deleteLater()
            except:
                pass
            finally:
                self.progress_dialog = None
        
        # 恢复原始缩放比例
        if hasattr(self, '_original_zoom_for_export'):
            self.set_zoom(self._original_zoom_for_export)
            delattr(self, '_original_zoom_for_export')
        
        if success:
            QMessageBox.information(self, "导出成功", message)
        else:
            QMessageBox.warning(self, "导出失败", message)
    
    def on_page_exported(self, page_num: int, file_path: str):
        """处理单页导出完成"""
        print(f"已导出第 {page_num} 页: {file_path}")
    
    def on_export_canceled(self):
        """处理导出取消"""
        self.exporter.cancel_export()
        # 恢复原始缩放
        if hasattr(self, '_original_zoom_for_export'):
            self.set_zoom(self._original_zoom_for_export)
            delattr(self, '_original_zoom_for_export')
    
    def handle_scroll(self, percentage: float):
        """处理编辑器滚动同步"""
        # 固定尺寸，不需要滚动同步
        pass
    
    def show_error(self, message: str):
        """显示错误信息"""
        error_html = f"""
        <html>
        <body style="padding: 20px; font-family: sans-serif; background: #1a1a2e; color: #e0e6ed;">
            <h3 style="color: #ff4757;">错误</h3>
            <p style="color: #8a92a6;">{message}</p>
        </body>
        </html>
        """
        self.web_view.setHtml(error_html) exporter.py->text/plain-># ============================================
# src/utils/exporter.py
# ============================================
from PySide6.QtCore import QObject, Signal, QTimer, QEventLoop, QSize, Qt, QPoint, QRect
from PySide6.QtGui import QImage, QPainter, QFont, QColor, QPageSize, QRegion
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtPrintSupport import QPrinter
from PySide6.QtWidgets import QWidget
from pathlib import Path
from typing import List, Optional
import json
import time

class ImageExporter(QObject):
    """图片导出器"""
    
    # 信号
    progress = Signal(int, int)  # 当前进度，总数
    finished = Signal(bool, str)  # 是否成功，消息
    page_exported = Signal(int, str)  # 页码，文件路径
    
    def __init__(self, web_view: QWebEngineView):
        super().__init__()
        self.web_view = web_view
        self.pages_to_export = []
        self.current_export_index = 0
        self.output_folder = ""
        self.html_generator = None
        self.export_format = "PNG"
        self.quality = 100
        self._is_exporting = False
        
    def export_pages(self, pages: List[str], output_folder: str, html_generator, 
                     format: str = "PNG", quality: int = 100) -> None:
        """
        导出多个页面为图片
        
        Args:
            pages: HTML页面内容列表
            output_folder: 输出文件夹路径
            html_generator: HTML生成器实例
            format: 图片格式 (PNG/JPEG)
            quality: 图片质量 (1-100)
        """
        self.pages_to_export = pages
        self.output_folder = Path(output_folder)
        self.current_export_index = 0
        self.html_generator = html_generator
        self.export_format = format
        self.quality = quality
        self._is_exporting = True
        
        # 确保输出文件夹存在
        self.output_folder.mkdir(parents=True, exist_ok=True)
        
        # 确保WebView是固定尺寸
        self.web_view.setFixedSize(1080, 1440)
        self.web_view.setZoomFactor(1.0)  # 重置缩放
        
        # 开始导出第一页
        self._export_next_page()
    
    def _export_next_page(self):
        """导出下一页"""
        if not self._is_exporting:
            return
            
        if self.current_export_index >= len(self.pages_to_export):
            # 导出完成
            self._is_exporting = False
            self.finished.emit(True, f"成功导出 {len(self.pages_to_export)} 张图片")
            return
        
        # 发送进度信号
        self.progress.emit(self.current_export_index + 1, len(self.pages_to_export))
        
        # 获取当前页内容
        page_content = self.pages_to_export[self.current_export_index]
        page_num = self.current_export_index + 1
        
        # 生成完整HTML（包含页码信息）
        full_html = self.html_generator.generate(
            page_content, 
            page_num=page_num, 
            total_pages=len(self.pages_to_export)
        )
        
        # 加载HTML到WebView
        self.web_view.setHtml(full_html, "file:///")
        
        # 等待页面加载完成后导出
        QTimer.singleShot(1500, lambda: self._capture_page(page_num))
    
    def _capture_page(self, page_num: int):
        """捕获当前页面为图片"""
        if not self._is_exporting:
            return
            
        # 构建输出文件名
        extension = self.export_format.lower()
        filename = f"card_{page_num:02d}.{extension}"
        output_path = self.output_folder / filename
        
        # 使用精确的捕获方法
        self._capture_fixed_size(output_path, page_num)
    
    def _capture_fixed_size(self, output_path: Path, page_num: int):
        """捕获固定尺寸的页面"""
        try:
            # 创建精确尺寸的图片（小红书卡片尺寸）
            target_width = 1080
            target_height = 1440
            
            # 创建目标图片
            image = QImage(target_width, target_height, QImage.Format_ARGB32)
            image.fill(Qt.white)
            
            # 创建painter
            painter = QPainter(image)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
            painter.setRenderHint(QPainter.RenderHint.TextAntialiasing, True)
            painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)
            
            # 确保WebView是正确的尺寸
            self.web_view.resize(target_width, target_height)
            
            # 渲染WebView到图片
            # 使用固定的源矩形来确保只捕获卡片区域
            source_rect = QRect(0, 0, target_width, target_height)
            target_rect = QRect(0, 0, target_width, target_height)
            
            # 渲染WebView
            if isinstance(self.web_view, QWidget):
                self.web_view.render(
                    painter,
                    QPoint(0, 0),
                    QRegion(source_rect),
                    QWidget.RenderFlag.DrawWindowBackground | QWidget.RenderFlag.DrawChildren
                )
            
            # 可选：添加导出时间水印
            self._add_export_watermark(painter, page_num)
            
            painter.end()
            
            # 保存图片
            success = image.save(str(output_path), self.export_format, self.quality)
            
            if success:
                self.page_exported.emit(page_num, str(output_path))
                # 继续导出下一页
                self.current_export_index += 1
                QTimer.singleShot(100, self._export_next_page)
            else:
                self._is_exporting = False
                self.finished.emit(False, f"保存图片失败: {output_path}")
                
        except Exception as e:
            self._is_exporting = False
            self.finished.emit(False, f"导出页面 {page_num} 时出错: {str(e)}")
    
    def _add_export_watermark(self, painter: QPainter, page_num: int):
        """添加导出水印（可选）"""
        # 设置水印字体和颜色
        font = QFont("Arial", 9)
        painter.setFont(font)
        painter.setPen(QColor(200, 200, 200, 80))
        
        # 在右下角添加生成时间（非常淡的水印）
        timestamp = time.strftime("%Y%m%d")
        painter.drawText(
            1000, 1420,
            f"{timestamp}"
        )
    
    def export_as_pdf(self, pages: List[str], output_file: str, html_generator):
        """
        导出为PDF文件（所有页面合并为一个PDF）
        
        Args:
            pages: HTML页面内容列表
            output_file: 输出PDF文件路径
            html_generator: HTML生成器实例
        """
        try:
            # 创建PDF打印机
            printer = QPrinter(QPrinter.PrinterMode.HighResolution)
            printer.setOutputFormat(QPrinter.OutputFormat.PdfFormat)
            printer.setOutputFileName(output_file)
            
            # 设置页面大小为小红书卡片比例
            # 注意：PDF使用点(point)作为单位，1点 = 1/72英寸
            # 1080px × 1440px 在 96 DPI 下约等于 810pt × 1080pt
            page_size = QPageSize(QSize(810, 1080), QPageSize.Unit.Point)
            printer.setPageSize(page_size)
            printer.setPageMargins(0, 0, 0, 0, QPrinter.Unit.Millimeter)
            
            # 合并所有页面内容
            combined_html = self._combine_pages_for_pdf(pages, html_generator)
            
            # 加载合并后的HTML
            self.web_view.setHtml(combined_html, "file:///")
            
            # 等待加载完成后打印
            loop = QEventLoop()
            
            def on_load_finished():
                self.web_view.page().print(printer, lambda success: loop.quit())
            
            QTimer.singleShot(1000, on_load_finished)
            loop.exec()
            
            self.finished.emit(True, f"PDF导出成功: {output_file}")
            
        except Exception as e:
            self.finished.emit(False, f"PDF导出失败: {str(e)}")
    
    def _combine_pages_for_pdf(self, pages: List[str], html_generator) -> str:
        """合并多个页面为PDF格式"""
        combined_content = ""
        
        for i, page in enumerate(pages, 1):
            if i > 1:
                # 添加分页符
                combined_content += '<div style="page-break-before: always;"></div>'
            
            # 添加页面内容，包装在固定尺寸的容器中
            combined_content += f'''
            <div style="width: 1080px; height: 1440px; position: relative; overflow: hidden;">
                {page}
            </div>
            '''
        
        # 生成完整HTML
        return html_generator.generate(combined_content)
    
    def cancel_export(self):
        """取消导出"""
        self._is_exporting = False
        self.pages_to_export = []
        self.finished.emit(False, "导出已取消") paginator.py->text/plain-># ============================================
# src/utils/paginator.py
# ============================================
from typing import List, Tuple, Optional
from dataclasses import dataclass
from bs4 import BeautifulSoup, NavigableString, Tag
import re

@dataclass
class PageElement:
    """页面元素"""
    type: str  # 'heading', 'paragraph', 'list', 'code', 'blockquote', 'table', 'hr', 'text'
    content: str  # HTML内容
    text: str  # 纯文本内容（用于计算高度）
    level: int = 0  # 标题级别或嵌套深度
    height: int = 0  # 估算高度（像素）
    can_break: bool = True  # 是否可以在此处分页
    
class SmartPaginator:
    """智能分页器"""
    
    # 元素高度估算（像素）- 调整为更准确的值
    ELEMENT_HEIGHTS = {
        'h1': 90,        # 大标题 + 底部边框
        'h2': 70,        # 二级标题
        'h3': 60,        # 三级标题
        'h4': 50,        # 四级标题
        'h5': 45,        # 五级标题
        'h6': 40,        # 六级标题
        'p_base': 25,    # 段落基础高度
        'p_line': 28,    # 段落每行高度（考虑行高1.8）
        'li': 35,        # 列表项
        'code_block': 40,  # 代码块基础高度
        'code_line': 24,   # 代码每行高度
        'blockquote': 60,  # 引用块基础高度
        'blockquote_line': 28,  # 引用每行高度
        'table_header': 45,  # 表格头
        'table_row': 40,     # 表格行
        'hr': 35,           # 分隔线
        'margin_bottom': 20,  # 元素底部间距
    }
    
    # 页面参数
    PAGE_HEIGHT = 1440  # 小红书卡片高度
    PAGE_WIDTH = 1080   # 小红书卡片宽度
    PADDING_TOP = 45    # 顶部内边距
    PADDING_BOTTOM = 70 # 底部内边距（包含水印和页码区域）
    PADDING_SIDES = 40  # 左右内边距
    
    # 内容区域实际宽度（用于计算文本换行）
    CONTENT_WIDTH = PAGE_WIDTH - (PADDING_SIDES * 2)  # 1000px
    
    # 有效内容高度
    CONTENT_HEIGHT = PAGE_HEIGHT - PADDING_TOP - PADDING_BOTTOM  # 1325px
    
    # 分页策略参数
    MIN_ORPHAN_LINES = 2  # 孤行控制：段落末尾最少保留行数
    MIN_WIDOW_LINES = 2   # 寡行控制：段落开头最少保留行数
    HEADING_KEEP_WITH = 150  # 标题后至少保留的内容高度
    
    # 字符宽度估算（像素）
    CHAR_WIDTH = 16  # 中文字符平均宽度
    CHAR_WIDTH_EN = 9  # 英文字符平均宽度
    
    def __init__(self):
        self.elements: List[PageElement] = []
        
    def parse_html_to_elements(self, html: str) -> List[PageElement]:
        """将HTML解析为页面元素列表，保持原始顺序"""
        elements = []
        
        # 使用BeautifulSoup解析HTML
        soup = BeautifulSoup(html, 'html.parser')
        
        # 遍历所有顶层元素
        for element in soup.children:
            if isinstance(element, NavigableString):
                # 处理纯文本
                text = str(element).strip()
                if text:
                    elements.append(PageElement(
                        type='text',
                        content=f'<p>{text}</p>',
                        text=text,
                        height=self._calculate_text_height(text),
                        can_break=True
                    ))
            elif isinstance(element, Tag):
                # 处理HTML标签
                parsed_element = self._parse_element(element)
                if parsed_element:
                    elements.append(parsed_element)
        
        return elements
    
    def _parse_element(self, element: Tag) -> Optional[PageElement]:
        """解析单个HTML元素"""
        tag_name = element.name.lower()
        
        # 标题元素
        if tag_name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
            level = int(tag_name[1])
            text = element.get_text(strip=True)
            height = self.ELEMENT_HEIGHTS[tag_name] + self.ELEMENT_HEIGHTS['margin_bottom']
            
            return PageElement(
                type='heading',
                content=str(element),
                text=text,
                level=level,
                height=height,
                can_break=False  # 标题前不分页
            )
        
        # 段落
        elif tag_name == 'p':
            text = element.get_text(strip=True)
            if not text:
                return None
                
            height = self._calculate_paragraph_height(text)
            
            return PageElement(
                type='paragraph',
                content=str(element),
                text=text,
                height=height,
                can_break=True
            )
        
        # 列表
        elif tag_name in ['ul', 'ol']:
            items = element.find_all('li')
            text = element.get_text(strip=True)
            height = len(items) * self.ELEMENT_HEIGHTS['li'] + self.ELEMENT_HEIGHTS['margin_bottom']
            
            return PageElement(
                type='list',
                content=str(element),
                text=text,
                height=height,
                can_break=len(items) > 3  # 列表项多于3个时可以分页
            )
        
        # 代码块
        elif tag_name == 'pre':
            text = element.get_text()
            lines = text.count('\n') + 1
            height = (self.ELEMENT_HEIGHTS['code_block'] + 
                     lines * self.ELEMENT_HEIGHTS['code_line'] +
                     self.ELEMENT_HEIGHTS['margin_bottom'])
            
            return PageElement(
                type='code',
                content=str(element),
                text=text,
                height=height,
                can_break=lines > 10  # 代码超过10行可以考虑分页
            )
        
        # 引用
        elif tag_name == 'blockquote':
            text = element.get_text(strip=True)
            height = self._calculate_blockquote_height(text)
            
            return PageElement(
                type='blockquote',
                content=str(element),
                text=text,
                height=height,
                can_break=True
            )
        
        # 表格
        elif tag_name == 'table':
            rows = element.find_all('tr')
            headers = element.find_all('th')
            text = element.get_text(strip=True)
            
            height = (len(headers) * self.ELEMENT_HEIGHTS['table_header'] +
                     (len(rows) - len(headers)) * self.ELEMENT_HEIGHTS['table_row'] +
                     self.ELEMENT_HEIGHTS['margin_bottom'])
            
            return PageElement(
                type='table',
                content=str(element),
                text=text,
                height=height,
                can_break=len(rows) > 5  # 表格行数多于5行时可以分页
            )
        
        # 分隔线
        elif tag_name == 'hr':
            return PageElement(
                type='hr',
                content=str(element),
                text='',
                height=self.ELEMENT_HEIGHTS['hr'],
                can_break=True
            )
        
        # 其他块级元素
        elif tag_name in ['div', 'section', 'article']:
            # 递归处理子元素
            sub_elements = []
            for child in element.children:
                if isinstance(child, Tag):
                    parsed = self._parse_element(child)
                    if parsed:
                        sub_elements.append(parsed)
            
            # 如果有子元素，返回第一个（简化处理）
            if sub_elements:
                return sub_elements[0]
        
        return None
    
    def _calculate_text_height(self, text: str) -> int:
        """计算纯文本高度"""
        lines = self._estimate_lines(text)
        return self.ELEMENT_HEIGHTS['p_base'] + lines * self.ELEMENT_HEIGHTS['p_line']
    
    def _calculate_paragraph_height(self, text: str) -> int:
        """计算段落高度"""
        lines = self._estimate_lines(text)
        height = self.ELEMENT_HEIGHTS['p_base'] + lines * self.ELEMENT_HEIGHTS['p_line']
        return height + self.ELEMENT_HEIGHTS['margin_bottom']
    
    def _calculate_blockquote_height(self, text: str) -> int:
        """计算引用块高度"""
        lines = self._estimate_lines(text, width_reduction=100)  # 引用有缩进
        height = self.ELEMENT_HEIGHTS['blockquote'] + lines * self.ELEMENT_HEIGHTS['blockquote_line']
        return height + self.ELEMENT_HEIGHTS['margin_bottom']
    
    def _estimate_lines(self, text: str, width_reduction: int = 0) -> int:
        """估算文本行数"""
        if not text:
            return 1
        
        # 计算可用宽度
        available_width = self.CONTENT_WIDTH - width_reduction
        
        # 粗略估算：中英文混合
        # 统计中文字符数
        chinese_chars = len(re.findall(r'[\u4e00-\u9fa5]', text))
        english_chars = len(text) - chinese_chars
        
        # 计算总宽度
        total_width = (chinese_chars * self.CHAR_WIDTH + 
                      english_chars * self.CHAR_WIDTH_EN)
        
        # 计算行数
        lines = max(1, int(total_width / available_width) + 1)
        
        # 考虑强制换行
        forced_breaks = text.count('\n')
        
        return lines + forced_breaks
    
    def paginate(self, html_content: str) -> List[str]:
        """执行智能分页"""
        # 如果内容很短，直接返回
        if not html_content or len(html_content.strip()) < 100:
            return [html_content] if html_content else ['<p>无内容</p>']
        
        # 解析HTML为元素
        elements = self.parse_html_to_elements(html_content)
        if not elements:
            return [html_content]
        
        pages = []
        current_page_elements = []
        current_height = 0
        
        for i, element in enumerate(elements):
            # 检查是否需要新页面
            need_new_page = False
            
            # 1. 基础高度检查
            if current_height + element.height > self.CONTENT_HEIGHT:
                need_new_page = True
            
            # 2. 标题关联检查（避免标题孤立）
            if element.type == 'heading':
                # 检查标题后是否有足够空间放置内容
                remaining_height = self.CONTENT_HEIGHT - current_height - element.height
                
                if remaining_height < self.HEADING_KEEP_WITH:
                    # 剩余空间不足，将标题移到下一页
                    need_new_page = True
                
                # 如果是第一个元素且不是第一页，不要分页
                if not current_page_elements and pages:
                    need_new_page = False
            
            # 3. 段落完整性检查
            if element.type == 'paragraph' and current_page_elements:
                # 如果段落太大，且当前页已有内容，考虑分页
                if element.height > self.CONTENT_HEIGHT * 0.6 and current_height > self.CONTENT_HEIGHT * 0.3:
                    need_new_page = True
            
            # 4. 避免页面过空
            if need_new_page and current_height < self.CONTENT_HEIGHT * 0.3:
                # 如果当前页面填充不到30%，尽量不分页
                if element.can_break or element.height < self.CONTENT_HEIGHT * 0.5:
                    need_new_page = False
            
            # 创建新页面
            if need_new_page and current_page_elements:
                page_html = ''.join([e.content for e in current_page_elements])
                pages.append(page_html)
                current_page_elements = []
                current_height = 0
            
            # 添加元素到当前页
            current_page_elements.append(element)
            current_height += element.height
        
        # 添加最后一页
        if current_page_elements:
            page_html = ''.join([e.content for e in current_page_elements])
            pages.append(page_html)
        
        # 优化分页结果
        pages = self.optimize_pages(pages)
        
        return pages if pages else [html_content]
    
    def optimize_pages(self, pages: List[str]) -> List[str]:
        """优化分页结果，合并过短的页面"""
        if len(pages) <= 1:
            return pages
        
        optimized = []
        i = 0
        
        while i < len(pages):
            current_page = pages[i]
            
            # 估算当前页面高度
            current_elements = self.parse_html_to_elements(current_page)
            current_height = sum(e.height for e in current_elements)
            
            # 如果页面过短，尝试与下一页合并
            if current_height < self.CONTENT_HEIGHT * 0.4 and i < len(pages) - 1:
                next_page = pages[i + 1]
                next_elements = self.parse_html_to_elements(next_page)
                next_height = sum(e.height for e in next_elements)
                
                # 如果合并后不超过最大高度，则合并
                if current_height + next_height <= self.CONTENT_HEIGHT:
                    optimized.append(current_page + next_page)
                    i += 2  # 跳过下一页
                    continue
            
            optimized.append(current_page)
            i += 1
        
        return optimized if optimized else pages
    
    def debug_pagination(self, html_content: str) -> List[dict]:
        """调试分页，返回详细信息"""
        elements = self.parse_html_to_elements(html_content)
        pages_info = []
        
        pages = self.paginate(html_content)
        for i, page in enumerate(pages, 1):
            page_elements = self.parse_html_to_elements(page)
            total_height = sum(e.height for e in page_elements)
            
            pages_info.append({
                'page_num': i,
                'elements_count': len(page_elements),
                'total_height': total_height,
                'max_height': self.CONTENT_HEIGHT,
                'fill_rate': f"{(total_height / self.CONTENT_HEIGHT * 100):.1f}%",
                'elements': [
                    {
                        'type': e.type,
                        'height': e.height,
                        'text_preview': e.text[:50] + '...' if len(e.text) > 50 else e.text
                    }
                    for e in page_elements
                ]
            })
        
        return pages_info style_manager.py->text/plain-># ============================================
# src/utils/style_manager.py
# ============================================
from typing import Dict, Any
from dataclasses import dataclass

@dataclass
class ThemeConfig:
    """主题配置"""
    name: str
    primary_color: str
    secondary_color: str
    text_color: str
    background: str
    font_family: str
    heading_font: str
    code_font: str
    
class StyleManager:
    """样式管理器"""
    
    # 预设主题
    THEMES = {
        "xiaohongshu": ThemeConfig(
            name="小红书",
            primary_color="#FF2442",
            secondary_color="#FF6B6B",
            text_color="#2c3e50",
            background="linear-gradient(135deg, #ffeef8 0%, #ffe0f0 100%)",
            font_family='-apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"JetBrains Mono", "Cascadia Code", "Consolas", monospace'
        ),
        "instagram": ThemeConfig(
            name="Instagram",
            primary_color="#E4405F",
            secondary_color="#BC2A8D",
            text_color="#262626",
            background="linear-gradient(45deg, #F9ED69 0%, #EE2A7B 50%, #6228D7 100%)",
            font_family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
            heading_font='"Segoe UI", Roboto, sans-serif',
            code_font='"Monaco", "Courier New", monospace'
        ),
        "wechat": ThemeConfig(
            name="微信",
            primary_color="#07C160",
            secondary_color="#4CAF50",
            text_color="#353535",
            background="linear-gradient(180deg, #F7F7F7 0%, #FFFFFF 100%)",
            font_family='"PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Microsoft YaHei", sans-serif',
            code_font='"SF Mono", "Monaco", "Inconsolata", monospace'
        ),
        "zhihu": ThemeConfig(
            name="知乎",
            primary_color="#0084FF",
            secondary_color="#1890FF",
            text_color="#1A1A1A",
            background="linear-gradient(180deg, #FFFFFF 0%, #F6F6F6 100%)",
            font_family='"PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"Source Code Pro", "Consolas", monospace'
        ),
        "dark": ThemeConfig(
            name="深色模式",
            primary_color="#00E0FF",
            secondary_color="#0096FF",
            text_color="#E0E6ED",
            background="linear-gradient(135deg, #0F0F1E 0%, #1A1A2E 50%, #16213E 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Fira Code", "JetBrains Mono", monospace'
        )
    }
    
    def __init__(self, theme: str = "xiaohongshu"):
        self.current_theme = theme
        self.custom_styles = {}
        
    def get_theme(self, theme_name: str = None) -> ThemeConfig:
        """获取主题配置"""
        if theme_name is None:
            theme_name = self.current_theme
        return self.THEMES.get(theme_name, self.THEMES["xiaohongshu"])
    
    def set_theme(self, theme_name: str):
        """设置当前主题"""
        if theme_name in self.THEMES:
            self.current_theme = theme_name
    
    def generate_css(self, theme_name: str = None) -> str:
        """生成主题CSS"""
        theme = self.get_theme(theme_name)
        
        return f"""
        /* 主题: {theme.name} */
        :root {{
            --primary-color: {theme.primary_color};
            --secondary-color: {theme.secondary_color};
            --text-color: {theme.text_color};
            --font-family: {theme.font_family};
            --heading-font: {theme.heading_font};
            --code-font: {theme.code_font};
        }}
        
        body {{
            font-family: var(--font-family);
            background: {theme.background};
            color: var(--text-color);
        }}
        
        h1, h2, h3, h4, h5, h6 {{
            font-family: var(--heading-font);
            color: var(--primary-color);
        }}
        
        h1 {{
            border-bottom-color: {self._lighten_color(theme.primary_color, 0.7)};
        }}
        
        h2::before {{
            background: linear-gradient(180deg, {theme.primary_color}, {theme.secondary_color});
        }}
        
        strong {{
            color: var(--primary-color);
            background: linear-gradient(180deg, transparent 70%, {self._lighten_color(theme.primary_color, 0.8)} 70%);
        }}
        
        ul li::marker, ol li::marker {{
            color: var(--primary-color);
        }}
        
        blockquote {{
            border-left-color: var(--primary-color);
            background: linear-gradient(90deg, {self._lighten_color(theme.primary_color, 0.95)} 0%, #FFFFFF 100%);
        }}
        
        code {{
            font-family: var(--code-font);
            background: {self._lighten_color(theme.primary_color, 0.95)};
            color: {self._darken_color(theme.primary_color, 0.2)};
        }}
        
        pre {{
            font-family: var(--code-font);
        }}
        
        th {{
            background: linear-gradient(135deg, {theme.primary_color}, {theme.secondary_color});
        }}
        
        a {{
            color: var(--primary-color);
            border-bottom-color: {self._lighten_color(theme.primary_color, 0.5)};
        }}
        
        a:hover {{
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
            background: {self._lighten_color(theme.primary_color, 0.95)};
        }}
        
        ::-webkit-scrollbar-thumb {{
            background: linear-gradient(180deg, {theme.secondary_color}, {theme.primary_color});
        }}
        
        ::-webkit-scrollbar-thumb:hover {{
            background: linear-gradient(180deg, {theme.primary_color}, {self._darken_color(theme.primary_color, 0.2)});
        }}
        """
    
    def _lighten_color(self, color: str, amount: float) -> str:
        """使颜色变浅"""
        # 简化实现，实际应该进行RGB计算
        if amount >= 0.9:
            return f"{color}10"  # 添加透明度
        elif amount >= 0.7:
            return f"{color}30"
        else:
            return f"{color}50"
    
    def _darken_color(self, color: str, amount: float) -> str:
        """使颜色变深"""
        # 简化实现
        return color
    
    def get_export_settings(self, theme_name: str = None) -> Dict[str, Any]:
        """获取导出设置"""
        theme = self.get_theme(theme_name)
        
        return {
            "page_width": 1080,
            "page_height": 1440,
            "padding": {
                "top": 45,
                "bottom": 45,
                "left": 40,
                "right": 40
            },
            "font_size": 16,
            "line_height": 1.8,
            "paragraph_spacing": 20,
            "image_quality": 100,
            "format": "PNG"
        }
    
    def apply_custom_styles(self, styles: Dict[str, str]):
        """应用自定义样式"""
        self.custom_styles.update(styles)
    
    def get_combined_css(self, theme_name: str = None) -> str:
        """获取组合的CSS（主题 + 自定义）"""
        base_css = self.generate_css(theme_name)
        
        if self.custom_styles:
            custom_css = "\n/* 自定义样式 */\n"
            for selector, rules in self.custom_styles.items():
                custom_css += f"{selector} {{\n{rules}\n}}\n"
            return base_css + custom_css
        
        return base_css
### 系统:
我来分析你的需求并制定实施计划：

## 需求分析

1. **三种尺寸**（保持3:4比例，字体不变）：
   - 小尺寸：720×960px（内容少，适合简短分享）
   - 中尺寸：1080×1440px（当前默认）  
   - 大尺寸：1440×1920px（内容多，适合长文）

2. **多种配色风格**：扩展现有的5种主题

## 实施步骤

### 第一步：添加尺寸选择功能 ✅ （本次完成）
### 第二步：扩展配色主题
### 第三步：优化UI交互

## 第一步实现方案

需要修改4个文件，我按修改量从小到大说明：

### 1. **html_generator.py** - 修改较小
在 `__init__` 方法中添加尺寸参数：
```python
# 第7行附近，修改初始化方法
def __init__(self, font_size: int = 18, page_size: str = "medium"):
    self.resource_path = Path(__file__).parent.parent / "resources"
    self.base_font_size = font_size
    
    # 添加页面尺寸配置
    self.page_sizes = {
        "small": {"width": 720, "height": 960},
        "medium": {"width": 1080, "height": 1440},
        "large": {"width": 1440, "height": 1920}
    }
    self.current_size = page_size
    self.page_width = self.page_sizes[page_size]["width"]
    self.page_height = self.page_sizes[page_size]["height"]
```

在 `get_css` 方法中使用动态尺寸（第45行附近）：
```python
# 将固定的 1080px 和 1440px 替换为动态值
html, body {{
    width: {self.page_width}px;
    height: {self.page_height}px;
    overflow: hidden !important;
}}

.container {{
    width: {self.page_width}px;
    height: {self.page_height}px;
    position: relative;
}}
```

### 2. **exporter.py** - 修改较小
第89行附近，使用动态尺寸：
```python
def _capture_fixed_size(self, output_path: Path, page_num: int):
    """捕获固定尺寸的页面"""
    try:
        # 从html_generator获取当前尺寸
        target_width = self.html_generator.page_width
        target_height = self.html_generator.page_height
```

### 3. **paginator.py** - 修改较大，需要完整代码 代码
```python
# ============================================
# src/utils/paginator.py
# ============================================
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass
from bs4 import BeautifulSoup, NavigableString, Tag
import re

@dataclass
class PageElement:
    """页面元素"""
    type: str  # 'heading', 'paragraph', 'list', 'code', 'blockquote', 'table', 'hr', 'text'
    content: str  # HTML内容
    text: str  # 纯文本内容（用于计算高度）
    level: int = 0  # 标题级别或嵌套深度
    height: int = 0  # 估算高度（像素）
    can_break: bool = True  # 是否可以在此处分页
    
class SmartPaginator:
    """智能分页器 - 支持多尺寸"""
    
    # 元素高度估算（像素）- 调整为更准确的值
    ELEMENT_HEIGHTS = {
        'h1': 90,        # 大标题 + 底部边框
        'h2': 70,        # 二级标题
        'h3': 60,        # 三级标题
        'h4': 50,        # 四级标题
        'h5': 45,        # 五级标题
        'h6': 40,        # 六级标题
        'p_base': 25,    # 段落基础高度
        'p_line': 28,    # 段落每行高度（考虑行高1.8）
        'li': 35,        # 列表项
        'code_block': 40,  # 代码块基础高度
        'code_line': 24,   # 代码每行高度
        'blockquote': 60,  # 引用块基础高度
        'blockquote_line': 28,  # 引用每行高度
        'table_header': 45,  # 表格头
        'table_row': 40,     # 表格行
        'hr': 35,           # 分隔线
        'margin_bottom': 20,  # 元素底部间距
    }
    
    # 页面尺寸配置
    PAGE_SIZES = {
        "small": {
            "width": 720,
            "height": 960,
            "padding_top": 35,
            "padding_bottom": 50,
            "padding_sides": 30
        },
        "medium": {
            "width": 1080,
            "height": 1440,
            "padding_top": 45,
            "padding_bottom": 70,
            "padding_sides": 40
        },
        "large": {
            "width": 1440,
            "height": 1920,
            "padding_top": 55,
            "padding_bottom": 90,
            "padding_sides": 50
        }
    }
    
    # 分页策略参数
    MIN_ORPHAN_LINES = 2  # 孤行控制：段落末尾最少保留行数
    MIN_WIDOW_LINES = 2   # 寡行控制：段落开头最少保留行数
    HEADING_KEEP_WITH = 150  # 标题后至少保留的内容高度
    
    # 字符宽度估算（像素）
    CHAR_WIDTH = 16  # 中文字符平均宽度
    CHAR_WIDTH_EN = 9  # 英文字符平均宽度
    
    def __init__(self, page_size: str = "medium"):
        """
        初始化分页器
        
        Args:
            page_size: 页面尺寸 ("small", "medium", "large")
        """
        self.elements: List[PageElement] = []
        self.set_page_size(page_size)
        
    def set_page_size(self, size: str):
        """设置页面尺寸"""
        if size not in self.PAGE_SIZES:
            size = "medium"
        
        config = self.PAGE_SIZES[size]
        self.page_size_name = size
        self.page_width = config["width"]
        self.page_height = config["height"]
        self.padding_top = config["padding_top"]
        self.padding_bottom = config["padding_bottom"]
        self.padding_sides = config["padding_sides"]
        
        # 计算内容区域
        self.content_width = self.page_width - (self.padding_sides * 2)
        self.content_height = self.page_height - self.padding_top - self.padding_bottom
        
        # 根据尺寸调整分页策略
        if size == "small":
            self.HEADING_KEEP_WITH = 100  # 小尺寸页面，标题后保留空间可以更少
        elif size == "large":
            self.HEADING_KEEP_WITH = 200  # 大尺寸页面，标题后保留更多空间
        else:
            self.HEADING_KEEP_WITH = 150
    
    def get_page_info(self) -> Dict:
        """获取当前页面配置信息"""
        return {
            "size_name": self.page_size_name,
            "width": self.page_width,
            "height": self.page_height,
            "content_width": self.content_width,
            "content_height": self.content_height,
            "padding": {
                "top": self.padding_top,
                "bottom": self.padding_bottom,
                "sides": self.padding_sides
            }
        }
        
    def parse_html_to_elements(self, html: str) -> List[PageElement]:
        """将HTML解析为页面元素列表，保持原始顺序"""
        elements = []
        
        # 使用BeautifulSoup解析HTML
        soup = BeautifulSoup(html, 'html.parser')
        
        # 遍历所有顶层元素
        for element in soup.children:
            if isinstance(element, NavigableString):
                # 处理纯文本
                text = str(element).strip()
                if text:
                    elements.append(PageElement(
                        type='text',
                        content=f'<p>{text}</p>',
                        text=text,
                        height=self._calculate_text_height(text),
                        can_break=True
                    ))
            elif isinstance(element, Tag):
                # 处理HTML标签
                parsed_element = self._parse_element(element)
                if parsed_element:
                    elements.append(parsed_element)
        
        return elements
    
    def _parse_element(self, element: Tag) -> Optional[PageElement]:
        """解析单个HTML元素"""
        tag_name = element.name.lower()
        
        # 标题元素
        if tag_name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
            level = int(tag_name[1])
            text = element.get_text(strip=True)
            height = self.ELEMENT_HEIGHTS[tag_name] + self.ELEMENT_HEIGHTS['margin_bottom']
            
            return PageElement(
                type='heading',
                content=str(element),
                text=text,
                level=level,
                height=height,
                can_break=False  # 标题前不分页
            )
        
        # 段落
        elif tag_name == 'p':
            text = element.get_text(strip=True)
            if not text:
                return None
                
            height = self._calculate_paragraph_height(text)
            
            return PageElement(
                type='paragraph',
                content=str(element),
                text=text,
                height=height,
                can_break=True
            )
        
        # 列表
        elif tag_name in ['ul', 'ol']:
            items = element.find_all('li')
            text = element.get_text(strip=True)
            height = len(items) * self.ELEMENT_HEIGHTS['li'] + self.ELEMENT_HEIGHTS['margin_bottom']
            
            return PageElement(
                type='list',
                content=str(element),
                text=text,
                height=height,
                can_break=len(items) > 3  # 列表项多于3个时可以分页
            )
        
        # 代码块
        elif tag_name == 'pre':
            text = element.get_text()
            lines = text.count('\n') + 1
            height = (self.ELEMENT_HEIGHTS['code_block'] + 
                     lines * self.ELEMENT_HEIGHTS['code_line'] +
                     self.ELEMENT_HEIGHTS['margin_bottom'])
            
            return PageElement(
                type='code',
                content=str(element),
                text=text,
                height=height,
                can_break=lines > 10  # 代码超过10行可以考虑分页
            )
        
        # 引用
        elif tag_name == 'blockquote':
            text = element.get_text(strip=True)
            height = self._calculate_blockquote_height(text)
            
            return PageElement(
                type='blockquote',
                content=str(element),
                text=text,
                height=height,
                can_break=True
            )
        
        # 表格
        elif tag_name == 'table':
            rows = element.find_all('tr')
            headers = element.find_all('th')
            text = element.get_text(strip=True)
            
            height = (len(headers) * self.ELEMENT_HEIGHTS['table_header'] +
                     (len(rows) - len(headers)) * self.ELEMENT_HEIGHTS['table_row'] +
                     self.ELEMENT_HEIGHTS['margin_bottom'])
            
            return PageElement(
                type='table',
                content=str(element),
                text=text,
                height=height,
                can_break=len(rows) > 5  # 表格行数多于5行时可以分页
            )
        
        # 分隔线
        elif tag_name == 'hr':
            return PageElement(
                type='hr',
                content=str(element),
                text='',
                height=self.ELEMENT_HEIGHTS['hr'],
                can_break=True
            )
        
        # 其他块级元素
        elif tag_name in ['div', 'section', 'article']:
            # 递归处理子元素
            sub_elements = []
            for child in element.children:
                if isinstance(child, Tag):
                    parsed = self._parse_element(child)
                    if parsed:
                        sub_elements.append(parsed)
            
            # 如果有子元素，返回第一个（简化处理）
            if sub_elements:
                return sub_elements[0]
        
        return None
    
    def _calculate_text_height(self, text: str) -> int:
        """计算纯文本高度"""
        lines = self._estimate_lines(text)
        return self.ELEMENT_HEIGHTS['p_base'] + lines * self.ELEMENT_HEIGHTS['p_line']
    
    def _calculate_paragraph_height(self, text: str) -> int:
        """计算段落高度"""
        lines = self._estimate_lines(text)
        height = self.ELEMENT_HEIGHTS['p_base'] + lines * self.ELEMENT_HEIGHTS['p_line']
        return height + self.ELEMENT_HEIGHTS['margin_bottom']
    
    def _calculate_blockquote_height(self, text: str) -> int:
        """计算引用块高度"""
        lines = self._estimate_lines(text, width_reduction=100)  # 引用有缩进
        height = self.ELEMENT_HEIGHTS['blockquote'] + lines * self.ELEMENT_HEIGHTS['blockquote_line']
        return height + self.ELEMENT_HEIGHTS['margin_bottom']
    
    def _estimate_lines(self, text: str, width_reduction: int = 0) -> int:
        """估算文本行数 - 根据页面宽度动态计算"""
        if not text:
            return 1
        
        # 计算可用宽度（使用动态内容宽度）
        available_width = self.content_width - width_reduction
        
        # 粗略估算：中英文混合
        # 统计中文字符数
        chinese_chars = len(re.findall(r'[\u4e00-\u9fa5]', text))
        english_chars = len(text) - chinese_chars
        
        # 计算总宽度
        total_width = (chinese_chars * self.CHAR_WIDTH + 
                      english_chars * self.CHAR_WIDTH_EN)
        
        # 计算行数
        lines = max(1, int(total_width / available_width) + 1)
        
        # 考虑强制换行
        forced_breaks = text.count('\n')
        
        return lines + forced_breaks
    
    def paginate(self, html_content: str) -> List[str]:
        """执行智能分页"""
        # 如果内容很短，直接返回
        if not html_content or len(html_content.strip()) < 100:
            return [html_content] if html_content else ['<p>无内容</p>']
        
        # 解析HTML为元素
        elements = self.parse_html_to_elements(html_content)
        if not elements:
            return [html_content]
        
        pages = []
        current_page_elements = []
        current_height = 0
        
        for i, element in enumerate(elements):
            # 检查是否需要新页面
            need_new_page = False
            
            # 1. 基础高度检查（使用动态内容高度）
            if current_height + element.height > self.content_height:
                need_new_page = True
            
            # 2. 标题关联检查（避免标题孤立）
            if element.type == 'heading':
                # 检查标题后是否有足够空间放置内容
                remaining_height = self.content_height - current_height - element.height
                
                if remaining_height < self.HEADING_KEEP_WITH:
                    # 剩余空间不足，将标题移到下一页
                    need_new_page = True
                
                # 如果是第一个元素且不是第一页，不要分页
                if not current_page_elements and pages:
                    need_new_page = False
            
            # 3. 段落完整性检查
            if element.type == 'paragraph' and current_page_elements:
                # 如果段落太大，且当前页已有内容，考虑分页
                if element.height > self.content_height * 0.6 and current_height > self.content_height * 0.3:
                    need_new_page = True
            
            # 4. 避免页面过空（根据页面尺寸调整阈值）
            min_fill_ratio = 0.25 if self.page_size_name == "small" else 0.3
            if need_new_page and current_height < self.content_height * min_fill_ratio:
                # 如果当前页面填充不足，尽量不分页
                if element.can_break or element.height < self.content_height * 0.5:
                    need_new_page = False
            
            # 创建新页面
            if need_new_page and current_page_elements:
                page_html = ''.join([e.content for e in current_page_elements])
                pages.append(page_html)
                current_page_elements = []
                current_height = 0
            
            # 添加元素到当前页
            current_page_elements.append(element)
            current_height += element.height
        
        # 添加最后一页
        if current_page_elements:
            page_html = ''.join([e.content for e in current_page_elements])
            pages.append(page_html)
        
        # 优化分页结果
        pages = self.optimize_pages(pages)
        
        return pages if pages else [html_content]
    
    def optimize_pages(self, pages: List[str]) -> List[str]:
        """优化分页结果，合并过短的页面"""
        if len(pages) <= 1:
            return pages
        
        optimized = []
        i = 0
        
        # 根据页面尺寸调整合并阈值
        merge_threshold = 0.35 if self.page_size_name == "small" else 0.4
        
        while i < len(pages):
            current_page = pages[i]
            
            # 估算当前页面高度
            current_elements = self.parse_html_to_elements(current_page)
            current_height = sum(e.height for e in current_elements)
            
            # 如果页面过短，尝试与下一页合并
            if current_height < self.content_height * merge_threshold and i < len(pages) - 1:
                next_page = pages[i + 1]
                next_elements = self.parse_html_to_elements(next_page)
                next_height = sum(e.height for e in next_elements)
                
                # 如果合并后不超过最大高度，则合并
                if current_height + next_height <= self.content_height:
                    optimized.append(current_page + next_page)
                    i += 2  # 跳过下一页
                    continue
            
            optimized.append(current_page)
            i += 1
        
        return optimized if optimized else pages
    
    def debug_pagination(self, html_content: str) -> List[dict]:
        """调试分页，返回详细信息"""
        elements = self.parse_html_to_elements(html_content)
        pages_info = []
        
        pages = self.paginate(html_content)
        for i, page in enumerate(pages, 1):
            page_elements = self.parse_html_to_elements(page)
            total_height = sum(e.height for e in page_elements)
            
            pages_info.append({
                'page_num': i,
                'page_size': self.page_size_name,
                'content_dimensions': f"{self.content_width}×{self.content_height}px",
                'elements_count': len(page_elements),
                'total_height': total_height,
                'max_height': self.content_height,
                'fill_rate': f"{(total_height / self.content_height * 100):.1f}%",
                'elements': [
                    {
                        'type': e.type,
                        'height': e.height,
                        'text_preview': e.text[:50] + '...' if len(e.text) > 50 else e.text
                    }
                    for e in page_elements
                ]
            })
        
        return pages_info
```
 ### 4. **preview_widget.py** - 修改较大，需要完整代码 代码
```python
# ============================================
# src/ui/preview_widget.py
# ============================================
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QFrame, 
                               QPushButton, QHBoxLayout, QProgressDialog,
                               QMessageBox, QScrollArea, QSlider, QComboBox)
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtCore import QUrl, QTimer, Signal, Qt, QSize
from pathlib import Path
from src.core.markdown_processor import MarkdownProcessor
from src.core.html_generator import HTMLGenerator
from src.utils.paginator import SmartPaginator
from src.utils.exporter import ImageExporter

class PreviewWidget(QWidget):
    pageChanged = Signal(int, int)  # 当前页，总页数
    sizeChanged = Signal(str)  # 尺寸改变信号
    
    def __init__(self):
        super().__init__()
        self.current_pages = []  # 存储分页后的HTML内容
        self.current_page = 1
        self.total_pages = 1
        self.markdown_text = ""  # 保存原始markdown文本
        self.current_zoom = 1.0  # 当前缩放比例
        self.current_size = "medium"  # 当前页面尺寸
        self.init_ui()
        self.setup_exporter()
        
    def init_ui(self):
        """初始化UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # 创建容器框架
        container = QFrame()
        container.setStyleSheet("""
            QFrame {
                background: rgba(25, 25, 40, 0.95);
                border: 1px solid rgba(0, 224, 255, 0.2);
                border-radius: 16px;
            }
        """)
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)
        
        # 标题栏
        title_bar = QFrame()
        title_bar.setFixedHeight(50)
        title_bar.setStyleSheet("""
            QFrame {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.1),
                    stop: 0.5 rgba(0, 150, 255, 0.15),
                    stop: 1 rgba(0, 224, 255, 0.1)
                );
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-bottom: 1px solid rgba(0, 224, 255, 0.2);
                padding: 12px 20px;
            }
        """)
        title_layout = QHBoxLayout(title_bar)
        
        title = QLabel("👀 实时预览")
        title.setStyleSheet("""
            QLabel {
                color: #00e0ff;
                font-size: 16px;
                font-weight: 600;
                letter-spacing: 0.5px;
            }
        """)
        
        # 尺寸选择下拉框
        self.size_selector = QComboBox()
        self.size_selector.addItems(["小尺寸 (720×960)", "中尺寸 (1080×1440)", "大尺寸 (1440×1920)"])
        self.size_selector.setCurrentIndex(1)  # 默认中尺寸
        self.size_selector.setFixedWidth(150)
        self.size_selector.setStyleSheet("""
            QComboBox {
                background: rgba(0, 224, 255, 0.1);
                border: 1px solid rgba(0, 224, 255, 0.3);
                color: #00e0ff;
                padding: 5px 10px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 500;
            }
            QComboBox:hover {
                background: rgba(0, 224, 255, 0.15);
                border: 1px solid rgba(0, 224, 255, 0.5);
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 5px solid #00e0ff;
                margin-right: 5px;
            }
            QComboBox QAbstractItemView {
                background: rgba(25, 25, 40, 0.98);
                border: 1px solid rgba(0, 224, 255, 0.3);
                color: #00e0ff;
                selection-background-color: rgba(0, 224, 255, 0.2);
                outline: none;
            }
        """)
        
        # 页面信息标签
        self.page_info_label = QLabel("")
        self.page_info_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                padding: 0 10px;
            }
        """)
        
        # 缩放显示标签
        self.zoom_label = QLabel("100%")
        self.zoom_label.setStyleSheet("""
            QLabel {
                color: #8a92a6;
                font-size: 12px;
                padding: 0 10px;
            }
        """)
        
        title_layout.addWidget(title)
        title_layout.addWidget(QLabel("尺寸:", styleSheet="color: #8a92a6; font-size: 12px;"))
        title_layout.addWidget(self.size_selector)
        title_layout.addWidget(self.page_info_label)
        title_layout.addStretch()
        title_layout.addWidget(self.zoom_label)
        
        # 创建滚动区域来包含 WebView
        self.scroll_area = QScrollArea()
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                border: none;
                background: #2a2a3e;
            }
            QScrollBar:vertical {
                background: rgba(20, 20, 35, 0.5);
                width: 12px;
                border-radius: 6px;
                margin: 5px;
            }
            QScrollBar::handle:vertical {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border-radius: 6px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 150, 255, 0.5)
                );
            }
            QScrollBar::add-line:vertical,
            QScrollBar::sub-line:vertical {
                border: none;
                background: none;
                height: 0;
            }
            QScrollBar:horizontal {
                background: rgba(20, 20, 35, 0.5);
                height: 12px;
                border-radius: 6px;
                margin: 5px;
            }
            QScrollBar::handle:horizontal {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.4),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
                border-radius: 6px;
                min-width: 30px;
            }
            QScrollBar::handle:horizontal:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 rgba(0, 224, 255, 0.6),
                    stop: 1 rgba(0, 150, 255, 0.5)
                );
            }
            QScrollBar::add-line:horizontal,
            QScrollBar::sub-line:horizontal {
                border: none;
                background: none;
                width: 0;
            }
        """)
        
        # Web视图 - 动态尺寸
        self.web_view = QWebEngineView()
        self.update_web_view_size()
        self.web_view.setStyleSheet("""
            QWebEngineView {
                border: none;
                background: white;
            }
        """)
        
        # 禁用 WebView 的滚动条
        self.web_view.page().settings().setAttribute(
            self.web_view.page().settings().WebAttribute.ShowScrollBars, False
        )
        
        # 设置滚动区域
        self.scroll_area.setWidget(self.web_view)
        self.scroll_area.setWidgetResizable(False)  # 不自动调整大小
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setAlignment(Qt.AlignCenter)  # 居中显示
        
        # 翻页控制栏
        control_bar = QFrame()
        control_bar.setFixedHeight(60)
        control_bar.setStyleSheet("""
            QFrame {
                background: rgba(20, 20, 35, 0.8);
                padding: 10px 20px;
                border-bottom-left-radius: 16px;
                border-bottom-right-radius: 16px;
                border-top: 1px solid rgba(0, 224, 255, 0.1);
            }
        """)
        control_layout = QHBoxLayout(control_bar)
        
        self.prev_btn = QPushButton("⬅ 上一页")
        self.prev_btn.setFixedSize(100, 36)
        self.prev_btn.setStyleSheet(self.get_button_style())
        
        self.next_btn = QPushButton("下一页 ➡")
        self.next_btn.setFixedSize(100, 36)
        self.next_btn.setStyleSheet(self.get_button_style())
        
        # 缩放滑块
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setRange(25, 150)  # 25% - 150%
        self.zoom_slider.setValue(100)  # 默认100%
        self.zoom_slider.setFixedWidth(200)
        self.zoom_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                height: 6px;
                background: rgba(0, 224, 255, 0.2);
                border-radius: 3px;
            }
            QSlider::handle:horizontal {
                width: 18px;
                height: 18px;
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 #00e0ff,
                    stop: 1 #0096ff
                );
                border-radius: 9px;
                margin: -6px 0;
            }
            QSlider::handle:horizontal:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 #00f0ff,
                    stop: 1 #00a6ff
                );
            }
        """)
        
        # 缩放按钮
        self.zoom_fit_btn = QPushButton("🔍 适应窗口")
        self.zoom_fit_btn.setFixedSize(100, 36)
        self.zoom_fit_btn.setStyleSheet(self.get_button_style())
        
        self.zoom_100_btn = QPushButton("📐 100%")
        self.zoom_100_btn.setFixedSize(80, 36)
        self.zoom_100_btn.setStyleSheet(self.get_button_style())
        
        control_layout.addWidget(self.prev_btn)
        control_layout.addSpacing(20)
        control_layout.addWidget(QLabel("缩放:", styleSheet="color: #8a92a6;"))
        control_layout.addWidget(self.zoom_slider)
        control_layout.addWidget(self.zoom_100_btn)
        control_layout.addWidget(self.zoom_fit_btn)
        control_layout.addStretch()
        control_layout.addWidget(self.next_btn)
        
        # 组装布局
        container_layout.addWidget(title_bar)
        container_layout.addWidget(self.scroll_area, 1)
        container_layout.addWidget(control_bar)
        
        layout.addWidget(container)
        
        # 处理器 - 初始化时使用默认尺寸
        self.markdown_processor = MarkdownProcessor()
        self.html_generator = HTMLGenerator(page_size="medium")
        self.paginator = SmartPaginator(page_size="medium")
        
        # 连接信号
        self.prev_btn.clicked.connect(self.prev_page)
        self.next_btn.clicked.connect(self.next_page)
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        self.zoom_fit_btn.clicked.connect(self.zoom_to_fit)
        self.zoom_100_btn.clicked.connect(self.zoom_to_100)
        self.size_selector.currentIndexChanged.connect(self.on_size_changed)
        
        # 初始化按钮状态
        self.update_buttons()
        
        # 延迟自适应（等待窗口完全加载）
        QTimer.singleShot(500, self.zoom_to_fit)
    
    def get_button_style(self) -> str:
        """获取按钮样式"""
        return """
            QPushButton {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.15),
                    stop: 1 rgba(0, 150, 255, 0.1)
                );
                border: 1px solid rgba(0, 224, 255, 0.4);
                color: #00e0ff;
                padding: 8px 16px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 13px;
            }
            QPushButton:hover {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.25),
                    stop: 1 rgba(0, 150, 255, 0.2)
                );
                border: 1px solid rgba(0, 224, 255, 0.6);
            }
            QPushButton:pressed {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 rgba(0, 224, 255, 0.35),
                    stop: 1 rgba(0, 150, 255, 0.3)
                );
            }
            QPushButton:disabled {
                background: rgba(30, 30, 45, 0.5);
                border-color: rgba(100, 100, 120, 0.3);
                color: rgba(100, 100, 120, 0.5);
            }
        """
    
    def on_size_changed(self, index):
        """处理尺寸改变"""
        size_map = {0: "small", 1: "medium", 2: "large"}
        new_size = size_map.get(index, "medium")
        
        if new_size != self.current_size:
            self.current_size = new_size
            
            # 更新各组件的尺寸设置
            self.html_generator = HTMLGenerator(page_size=new_size)
            self.paginator.set_page_size(new_size)
            
            # 更新WebView尺寸
            self.update_web_view_size()
            
            # 重新处理内容
            if self.markdown_text:
                self.update_content(self.markdown_text)
            
            # 发送尺寸改变信号
            self.sizeChanged.emit(new_size)
            
            # 延迟后自适应缩放
            QTimer.singleShot(100, self.zoom_to_fit)
    
    def update_web_view_size(self):
        """更新WebView尺寸"""
        size_config = {
            "small": (720, 960),
            "medium": (1080, 1440),
            "large": (1440, 1920)
        }
        width, height = size_config.get(self.current_size, (1080, 1440))
        self.web_view.setFixedSize(width, height)
    
    def on_zoom_changed(self, value):
        """处理缩放滑块变化"""
        zoom = value / 100.0
        self.set_zoom(zoom)
    
    def set_zoom(self, zoom_factor):
        """设置缩放比例"""
        self.current_zoom = zoom_factor
        self.web_view.setZoomFactor(zoom_factor)
        self.zoom_label.setText(f"{int(zoom_factor * 100)}%")
        
        # 不需要改变滑块值时的信号阻塞
        self.zoom_slider.blockSignals(True)
        self.zoom_slider.setValue(int(zoom_factor * 100))
        self.zoom_slider.blockSignals(False)
    
    def zoom_to_fit(self):
        """缩放到适应窗口"""
        if self.scroll_area and self.web_view:
            # 获取滚动区域的可视大小
            viewport_size = self.scroll_area.viewport().size()
            
            # 获取当前页面尺寸
            card_width = self.web_view.width()
            card_height = self.web_view.height()
            
            # 计算缩放比例（留出一些边距）
            margin = 20
            scale_x = (viewport_size.width() - margin * 2) / card_width
            scale_y = (viewport_size.height() - margin * 2) / card_height
            scale = min(scale_x, scale_y, 1.0)  # 不超过100%
            
            # 应用缩放
            self.set_zoom(scale)
    
    def zoom_to_100(self):
        """恢复100%大小"""
        self.set_zoom(1.0)
    
    def setup_exporter(self):
        """设置导出器"""
        self.exporter = ImageExporter(self.web_view)
        self.exporter.progress.connect(self.on_export_progress)
        self.exporter.finished.connect(self.on_export_finished)
        self.exporter.page_exported.connect(self.on_page_exported)
        
    def update_content(self, markdown_text: str):
        """更新预览内容"""
        try:
            self.markdown_text = markdown_text
            
            # 处理 Markdown
            html_content = self.markdown_processor.parse(markdown_text)
            
            # 使用智能分页器进行分页
            self.current_pages = self.paginator.paginate(html_content)
            
            # 优化分页结果
            self.current_pages = self.paginator.optimize_pages(self.current_pages)
            
            self.total_pages = len(self.current_pages)
            self.current_page = 1
            
            # 显示第一页
            self.display_current_page()
            
            # 更新按钮
            self.update_buttons()
            
            # 更新页面信息
            self.update_page_info()
            
            # 保持当前缩放比例
            QTimer.singleShot(100, lambda: self.set_zoom(self.current_zoom))
            
        except Exception as e:
            self.show_error(f"预览错误: {str(e)}")
    
    def update_page_info(self):
        """更新页面信息显示"""
        if self.total_pages > 1:
            self.page_info_label.setText(f"第 {self.current_page}/{self.total_pages} 页")
        else:
            self.page_info_label.setText("")
    
    def display_current_page(self):
        """显示当前页"""
        if not self.current_pages:
            return
            
        if 1 <= self.current_page <= len(self.current_pages):
            page_content = self.current_pages[self.current_page - 1]
            
            # 生成完整HTML
            full_html = self.html_generator.generate(page_content)
            
            # 加载到WebView
            self.web_view.setHtml(full_html, QUrl("file:///"))
    
    def prev_page(self):
        """上一页"""
        if self.current_page > 1:
            self.current_page -= 1
            self.display_current_page()
            self.update_buttons()
            self.update_page_info()
    
    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.display_current_page()
            self.update_buttons()
            self.update_page_info()
    
    def update_buttons(self):
        """更新按钮状态"""
        self.prev_btn.setEnabled(self.current_page > 1)
        self.next_btn.setEnabled(self.current_page < self.total_pages)
        
        # 发送页面改变信号
        self.pageChanged.emit(self.current_page, self.total_pages)
    
    def export_pages(self, folder: str):
        """导出所有页面为图片"""
        if not self.current_pages:
            QMessageBox.warning(self, "提示", "没有可导出的内容")
            return
        
        # 创建进度对话框
        self.progress_dialog = QProgressDialog(
            "正在导出图片...", 
            "取消", 
            0, 
            self.total_pages, 
            self
        )
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setMinimumDuration(0)
        self.progress_dialog.canceled.connect(self.on_export_canceled)
        
        # 导出前恢复100%大小（确保导出的是原始尺寸）
        original_zoom = self.current_zoom
        self.web_view.setZoomFactor(1.0)
        
        # 开始导出
        self.exporter.export_pages(
            self.current_pages,
            folder,
            self.html_generator,
            format="PNG",
            quality=100
        )
        
        # 保存原始缩放比例，导出完成后恢复
        self._original_zoom_for_export = original_zoom
    
    def on_export_progress(self, current: int, total: int):
        """处理导出进度"""
        if hasattr(self, 'progress_dialog'):
            self.progress_dialog.setValue(current)
            self.progress_dialog.setLabelText(f"正在导出第 {current}/{total} 页...")
    
    def on_export_finished(self, success: bool, message: str):
        """处理导出完成"""
        # 关闭进度对话框
        if hasattr(self, 'progress_dialog') and self.progress_dialog is not None:
            try:
                self.progress_dialog.close()
                self.progress_dialog.deleteLater()
            except:
                pass
            finally:
                self.progress_dialog = None
        
        # 恢复原始缩放比例
        if hasattr(self, '_original_zoom_for_export'):
            self.set_zoom(self._original_zoom_for_export)
            delattr(self, '_original_zoom_for_export')
        
        if success:
            # 添加尺寸信息到消息中
            size_info = f"({self.current_size}: {self.web_view.width()}×{self.web_view.height()}px)"
            QMessageBox.information(self, "导出成功", f"{message}\n尺寸: {size_info}")
        else:
            QMessageBox.warning(self, "导出失败", message)
    
    def on_page_exported(self, page_num: int, file_path: str):
        """处理单页导出完成"""
        print(f"已导出第 {page_num} 页: {file_path}")
    
    def on_export_canceled(self):
        """处理导出取消"""
        self.exporter.cancel_export()
        # 恢复原始缩放
        if hasattr(self, '_original_zoom_for_export'):
            self.set_zoom(self._original_zoom_for_export)
            delattr(self, '_original_zoom_for_export')
    
    def handle_scroll(self, percentage: float):
        """处理编辑器滚动同步"""
        # 固定尺寸，不需要滚动同步
        pass
    
    def show_error(self, message: str):
        """显示错误信息"""
        error_html = f"""
        <html>
        <body style="padding: 20px; font-family: sans-serif; background: #1a1a2e; color: #e0e6ed;">
            <h3 style="color: #ff4757;">错误</h3>
            <p style="color: #8a92a6;">{message}</p>
        </body>
        </html>
        """
        self.web_view.setHtml(error_html)
```
 ## 实施总结

### 修改清单

#### 1. **html_generator.py** （小修改）
- **第7行**：修改 `__init__` 方法，添加 `page_size` 参数和尺寸配置
- **第45-60行**：在 `get_css()` 中将固定的 `1080px/1440px` 替换为 `{self.page_width}px/{self.page_height}px`

#### 2. **exporter.py** （小修改）  
- **第89行** `_capture_fixed_size` 方法：
```python
# 替换固定值
target_width = self.html_generator.page_width
target_height = self.html_generator.page_height
```

#### 3. **paginator.py** （大修改）
- 使用上面提供的完整代码替换原文件
- 主要改动：
  - 添加了 `PAGE_SIZES` 配置字典
  - 新增 `set_page_size()` 方法
  - 所有高度计算改为动态值

#### 4. **preview_widget.py** （大修改）
- 使用上面提供的完整代码替换原文件
- 主要改动：
  - 添加尺寸选择下拉框
  - 新增 `on_size_changed()` 方法
  - 更新 WebView 尺寸动态调整

## 测试要点

1. **尺寸切换**：确保三种尺寸切换流畅
2. **内容适配**：验证不同尺寸下分页效果
3. **导出功能**：确认导出的图片尺寸正确
4. **缩放功能**：测试"适应窗口"按钮

## 下一步计划

完成第一步后，第二步将：
1. 扩展 `style_manager.py` 添加更多配色主题
2. 在工具栏添加主题选择器
3. 实现主题切换的实时预览

需要我继续第二步的实现吗？
### 用户:
继续
### 系统:
## 第二步：扩展配色主题系统

### 实施方案

我将添加更多配色主题，并在工具栏添加主题选择器，实现实时切换预览。

### 1. **style_manager.py** - 完整更新版本（扩展主题） 代码
```python
# ============================================
# src/utils/style_manager.py
# ============================================
from typing import Dict, Any, Tuple
from dataclasses import dataclass
import colorsys

@dataclass
class ThemeConfig:
    """主题配置"""
    name: str
    primary_color: str
    secondary_color: str
    text_color: str
    background: str
    font_family: str
    heading_font: str
    code_font: str
    accent_color: str = ""  # 强调色
    link_color: str = ""    # 链接色
    
class StyleManager:
    """样式管理器 - 扩展版"""
    
    # 预设主题 - 12种风格
    THEMES = {
        # 社交媒体风格
        "xiaohongshu": ThemeConfig(
            name="小红书经典",
            primary_color="#FF2442",
            secondary_color="#FF6B6B",
            text_color="#2c3e50",
            background="linear-gradient(135deg, #ffeef8 0%, #ffe0f0 100%)",
            font_family='-apple-system, BlinkMacSystemFont, "PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"JetBrains Mono", "Cascadia Code", "Consolas", monospace',
            accent_color="#FFB6C1",
            link_color="#FF69B4"
        ),
        
        "instagram": ThemeConfig(
            name="Instagram渐变",
            primary_color="#E4405F",
            secondary_color="#BC2A8D",
            text_color="#262626",
            background="linear-gradient(45deg, #F9ED69 0%, #EE2A7B 50%, #6228D7 100%)",
            font_family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
            heading_font='"Segoe UI", Roboto, sans-serif',
            code_font='"Monaco", "Courier New", monospace',
            accent_color="#FCAF45",
            link_color="#833AB4"
        ),
        
        "wechat": ThemeConfig(
            name="微信简约",
            primary_color="#07C160",
            secondary_color="#4CAF50",
            text_color="#353535",
            background="linear-gradient(180deg, #F7F7F7 0%, #FFFFFF 100%)",
            font_family='"PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Microsoft YaHei", sans-serif',
            code_font='"SF Mono", "Monaco", "Inconsolata", monospace',
            accent_color="#95EC69",
            link_color="#576B95"
        ),
        
        "douyin": ThemeConfig(
            name="抖音酷黑",
            primary_color="#FE2C55",
            secondary_color="#25F4EE",
            text_color="#FFFFFF",
            background="linear-gradient(135deg, #000000 0%, #161823 100%)",
            font_family='"PingFang SC", "Helvetica Neue", Arial, sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"Fira Code", "Source Code Pro", monospace',
            accent_color="#00F2EA",
            link_color="#FE2C55"
        ),
        
        # 知识平台风格
        "zhihu": ThemeConfig(
            name="知乎蓝",
            primary_color="#0084FF",
            secondary_color="#1890FF",
            text_color="#1A1A1A",
            background="linear-gradient(180deg, #FFFFFF 0%, #F6F6F6 100%)",
            font_family='"PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif',
            heading_font='"PingFang SC", "Helvetica Neue", sans-serif',
            code_font='"Source Code Pro", "Consolas", monospace',
            accent_color="#5BBCFF",
            link_color="#175199"
        ),
        
        "notion": ThemeConfig(
            name="Notion极简",
            primary_color="#000000",
            secondary_color="#2F3437",
            text_color="#37352F",
            background="linear-gradient(180deg, #FFFFFF 0%, #FAFAFA 100%)",
            font_family='"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            heading_font='"Inter", -apple-system, sans-serif',
            code_font='"SFMono-Regular", "Consolas", "Liberation Mono", monospace',
            accent_color="#EB5757",
            link_color="#0070F3"
        ),
        
        # 优雅风格
        "elegant_purple": ThemeConfig(
            name="优雅紫",
            primary_color="#6B46C1",
            secondary_color="#9333EA",
            text_color="#1F2937",
            background="linear-gradient(135deg, #F9FAFB 0%, #F3E8FF 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Playfair Display", "PingFang SC", serif',
            code_font='"JetBrains Mono", "Cascadia Code", monospace',
            accent_color="#A78BFA",
            link_color="#7C3AED"
        ),
        
        "ocean_blue": ThemeConfig(
            name="海洋蓝",
            primary_color="#0EA5E9",
            secondary_color="#06B6D4",
            text_color="#0F172A",
            background="linear-gradient(135deg, #F0F9FF 0%, #E0F2FE 50%, #BAE6FD 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Fira Code", "Consolas", monospace',
            accent_color="#38BDF8",
            link_color="#0284C7"
        ),
        
        "sunset_orange": ThemeConfig(
            name="日落橙",
            primary_color="#F97316",
            secondary_color="#FB923C",
            text_color="#1C1917",
            background="linear-gradient(135deg, #FFF7ED 0%, #FED7AA 50%, #FDBA74 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Source Code Pro", "Monaco", monospace',
            accent_color="#FCD34D",
            link_color="#EA580C"
        ),
        
        "forest_green": ThemeConfig(
            name="森林绿",
            primary_color="#059669",
            secondary_color="#10B981",
            text_color="#064E3B",
            background="linear-gradient(135deg, #ECFDF5 0%, #D1FAE5 50%, #A7F3D0 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"JetBrains Mono", monospace',
            accent_color="#34D399",
            link_color="#047857"
        ),
        
        # 深色主题
        "dark_mode": ThemeConfig(
            name="深色模式",
            primary_color="#00E0FF",
            secondary_color="#0096FF",
            text_color="#E0E6ED",
            background="linear-gradient(135deg, #0F0F1E 0%, #1A1A2E 50%, #16213E 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Fira Code", "JetBrains Mono", monospace',
            accent_color="#00F0FF",
            link_color="#00B8D4"
        ),
        
        "midnight": ThemeConfig(
            name="午夜紫",
            primary_color="#B794F4",
            secondary_color="#9F7AEA",
            text_color="#E9D8FD",
            background="linear-gradient(135deg, #1A202C 0%, #2D3748 50%, #4A5568 100%)",
            font_family='"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
            heading_font='"Inter", "PingFang SC", sans-serif',
            code_font='"Cascadia Code", "Fira Code", monospace',
            accent_color="#D6BCFA",
            link_color="#B794F4"
        )
    }
    
    def __init__(self, theme: str = "xiaohongshu"):
        self.current_theme = theme
        self.custom_styles = {}
        
    def get_theme(self, theme_name: str = None) -> ThemeConfig:
        """获取主题配置"""
        if theme_name is None:
            theme_name = self.current_theme
        return self.THEMES.get(theme_name, self.THEMES["xiaohongshu"])
    
    def get_theme_list(self) -> list:
        """获取所有主题列表"""
        return list(self.THEMES.keys())
    
    def get_theme_display_names(self) -> Dict[str, str]:
        """获取主题显示名称"""
        return {key: theme.name for key, theme in self.THEMES.items()}
    
    def set_theme(self, theme_name: str):
        """设置当前主题"""
        if theme_name in self.THEMES:
            self.current_theme = theme_name
    
    def hex_to_rgb(self, hex_color: str) -> Tuple[int, int, int]:
        """十六进制颜色转RGB"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    def rgb_to_hex(self, r: int, g: int, b: int) -> str:
        """RGB转十六进制"""
        return f"#{r:02x}{g:02x}{b:02x}"
    
    def lighten_color(self, hex_color: str, amount: float) -> str:
        """使颜色变浅（amount: 0-1）"""
        r, g, b = self.hex_to_rgb(hex_color)
        # 转换为HSL
        h, l, s = colorsys.rgb_to_hls(r/255, g/255, b/255)
        # 增加亮度
        l = min(1.0, l + (1 - l) * amount)
        # 转回RGB
        r, g, b = colorsys.hls_to_rgb(h, l, s)
        return self.rgb_to_hex(int(r*255), int(g*255), int(b*255))
    
    def darken_color(self, hex_color: str, amount: float) -> str:
        """使颜色变深（amount: 0-1）"""
        r, g, b = self.hex_to_rgb(hex_color)
        # 转换为HSL
        h, l, s = colorsys.rgb_to_hls(r/255, g/255, b/255)
        # 降低亮度
        l = max(0.0, l * (1 - amount))
        # 转回RGB
        r, g, b = colorsys.hls_to_rgb(h, l, s)
        return self.rgb_to_hex(int(r*255), int(g*255), int(b*255))
    
    def add_alpha(self, hex_color: str, alpha: float) -> str:
        """添加透明度（返回rgba格式）"""
        r, g, b = self.hex_to_rgb(hex_color)
        return f"rgba({r}, {g}, {b}, {alpha})"
    
    def generate_css(self, theme_name: str = None, font_size: int = 18) -> str:
        """生成主题CSS"""
        theme = self.get_theme(theme_name)
        
        # 生成派生颜色
        primary_light = self.lighten_color(theme.primary_color, 0.9)
        primary_dark = self.darken_color(theme.primary_color, 0.2)
        secondary_light = self.lighten_color(theme.secondary_color, 0.9)
        
        # 检查是否为深色主题
        is_dark = theme_name in ["dark_mode", "midnight", "douyin"]
        
        return f"""
        /* 主题: {theme.name} */
        :root {{
            --primary-color: {theme.primary_color};
            --secondary-color: {theme.secondary_color};
            --accent-color: {theme.accent_color or theme.secondary_color};
            --text-color: {theme.text_color};
            --link-color: {theme.link_color or theme.primary_color};
            --font-family: {theme.font_family};
            --heading-font: {theme.heading_font};
            --code-font: {theme.code_font};
            --primary-light: {primary_light};
            --primary-dark: {primary_dark};
            --secondary-light: {secondary_light};
            --base-font-size: {font_size}px;
        }}
        
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: var(--font-family);
            background: {theme.background};
            color: var(--text-color);
            font-size: var(--base-font-size);
            line-height: 1.85;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }}
        
        /* 标题样式 */
        h1, h2, h3, h4, h5, h6 {{
            font-family: var(--heading-font);
            color: var(--primary-color);
            font-weight: 700;
            letter-spacing: -0.02em;
        }}
        
        h1 {{
            font-size: calc(var(--base-font-size) + 16px);
            margin-bottom: 28px;
            padding-bottom: 16px;
            border-bottom: 3px solid {self.add_alpha(theme.primary_color, 0.2)};
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }}
        
        h2 {{
            font-size: calc(var(--base-font-size) + 10px);
            margin-top: 38px;
            margin-bottom: 22px;
            position: relative;
            padding-left: 20px;
        }}
        
        h2::before {{
            content: "";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 24px;
            background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
            border-radius: 3px;
            box-shadow: 0 2px 8px {self.add_alpha(theme.primary_color, 0.3)};
        }}
        
        h3 {{
            font-size: calc(var(--base-font-size) + 5px);
            margin-top: 30px;
            margin-bottom: 18px;
            color: {theme.text_color if not is_dark else theme.secondary_color};
        }}
        
        /* 段落样式 */
        p {{
            margin-bottom: 22px;
            font-size: var(--base-font-size);
            color: var(--text-color);
            text-align: justify;
            line-height: 1.85;
        }}
        
        /* 强调样式 */
        strong {{
            color: var(--primary-color);
            font-weight: 600;
            background: linear-gradient(180deg, transparent 70%, {self.add_alpha(theme.primary_color, 0.2)} 70%);
            padding: 0 4px;
            border-radius: 2px;
        }}
        
        em {{
            font-style: italic;
            color: {self.darken_color(theme.text_color, 0.2) if not is_dark else self.lighten_color(theme.text_color, 0.2)};
        }}
        
        /* 列表样式 */
        ul, ol {{
            margin: 24px 0;
            padding-left: 38px;
        }}
        
        li {{
            margin-bottom: 16px;
            font-size: var(--base-font-size);
            color: var(--text-color);
            line-height: 1.85;
            position: relative;
        }}
        
        ul li::marker {{
            color: var(--primary-color);
            font-size: calc(var(--base-font-size) + 2px);
        }}
        
        ol li::marker {{
            color: var(--primary-color);
            font-weight: 600;
        }}
        
        /* 引用样式 */
        blockquote {{
            border-left: 4px solid var(--primary-color);
            margin: 28px 0;
            padding: 20px 28px;
            background: {self.add_alpha(theme.primary_color, 0.05) if not is_dark else self.add_alpha(theme.primary_color, 0.1)};
            border-radius: 10px;
            position: relative;
            box-shadow: 0 4px 15px {self.add_alpha(theme.primary_color, 0.1)};
        }}
        
        blockquote::before {{
            content: '"';
            position: absolute;
            top: -10px;
            left: 24px;
            font-size: 48px;
            color: {self.add_alpha(theme.primary_color, 0.3)};
            font-family: Georgia, serif;
            font-weight: bold;
        }}
        
        blockquote p {{
            color: {self.darken_color(theme.text_color, 0.1) if not is_dark else self.lighten_color(theme.text_color, 0.1)};
            font-style: italic;
            margin-bottom: 0;
            font-size: calc(var(--base-font-size) - 1px);
        }}
        
        /* 行内代码 */
        code {{
            background: {self.add_alpha(theme.primary_color, 0.1)};
            padding: 4px 10px;
            border-radius: 6px;
            font-family: var(--code-font);
            font-size: calc(var(--base-font-size) - 2px);
            color: {theme.primary_color if not is_dark else theme.accent_color};
            font-weight: 500;
            border: 1px solid {self.add_alpha(theme.primary_color, 0.2)};
        }}
        
        /* 代码块 */
        pre {{
            background: {('#1e1e1e' if not is_dark else '#0a0a0f')};
            color: #d4d4d4;
            padding: 26px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 28px 0;
            box-shadow: 0 8px 24px {self.add_alpha('#000000', 0.15)};
            position: relative;
            border: 1px solid {self.add_alpha(theme.primary_color, 0.2)};
        }}
        
        pre::before {{
            content: "CODE";
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 11px;
            color: {self.add_alpha(theme.text_color, 0.5)};
            font-weight: 600;
            letter-spacing: 1px;
            font-family: var(--font-family);
        }}
        
        pre code {{
            background: none;
            color: #d4d4d4;
            padding: 0;
            font-size: calc(var(--base-font-size) - 3px);
            line-height: 1.7;
            border: none;
        }}
        
        /* 表格样式 */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 28px 0;
            font-size: calc(var(--base-font-size) - 1px);
            box-shadow: 0 4px 15px {self.add_alpha(theme.primary_color, 0.08)};
            border-radius: 10px;
            overflow: hidden;
        }}
        
        th {{
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px 20px;
            text-align: left;
            font-weight: 600;
            font-size: calc(var(--base-font-size) - 1px);
            letter-spacing: 0.5px;
        }}
        
        td {{
            padding: 15px 20px;
            border-bottom: 1px solid {self.add_alpha(theme.text_color, 0.1)};
            color: var(--text-color);
        }}
        
        tr:nth-child(even) {{
            background: {self.add_alpha(theme.primary_color, 0.03)};
        }}
        
        tr:hover {{
            background: {self.add_alpha(theme.primary_color, 0.08)};
            transition: background 0.3s ease;
        }}
        
        tr:last-child td {{
            border-bottom: none;
        }}
        
        /* 分隔线 */
        hr {{
            border: none;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent, 
                {self.add_alpha(theme.primary_color, 0.3)} 20%, 
                {self.add_alpha(theme.primary_color, 0.3)} 80%, 
                transparent);
            margin: 38px 0;
            position: relative;
        }}
        
        hr::after {{
            content: "✦";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: {theme.background.split('(')[0] + '(180deg, #FFFFFF 0%, #FFFFFF 100%)' if 'gradient' in theme.background else '#FFFFFF'};
            color: var(--primary-color);
            padding: 0 10px;
            font-size: 20px;
        }}
        
        /* 链接样式 */
        a {{
            color: var(--link-color);
            text-decoration: none;
            border-bottom: 2px solid {self.add_alpha(theme.link_color or theme.primary_color, 0.3)};
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding-bottom: 1px;
            position: relative;
        }}
        
        a:hover {{
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
            background: {self.add_alpha(theme.primary_color, 0.08)};
            padding: 2px 6px;
            margin: -2px -6px;
            border-radius: 4px;
        }}
        
        /* 动画效果 */
        @keyframes fadeIn {{
            from {{
                opacity: 0;
                transform: translateY(10px);
            }}
            to {{
                opacity: 1;
                transform: translateY(0);
            }}
        }}
        
        .content > * {{
            animation: fadeIn 0.5s ease-out backwards;
        }}
        
        .content > *:nth-child(1) {{ animation-delay: 0.05s; }}
        .content > *:nth-child(2) {{ animation-delay: 0.1s; }}
        .content > *:nth-child(3) {{ animation-delay: 0.15s; }}
        .content > *:nth-child(4) {{ animation-delay: 0.2s; }}
        .content > *:nth-child(5) {{ animation-delay: 0.25s; }}
        
        /* 自定义滚动条 */
        ::-webkit-scrollbar {{
            width: 8px;
            height: 8px;
        }}
        
        ::-webkit-scrollbar-track {{
            background: {self.add_alpha(theme.text_color, 0.05)};
            border-radius: 4px;
        }}
        
        ::-webkit-scrollbar-thumb {{
            background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));
            border-radius: 4px;
        }}
        
        ::-webkit-scrollbar-thumb:hover {{
            background: linear-gradient(180deg, var(--secondary-color), var(--primary-color));
        }}
        """
    
    def get_export_settings(self, theme_name: str = None) -> Dict[str, Any]:
        """获取导出设置"""
        theme = self.get_theme(theme_name)
        
        return {
            "theme_name": theme.name,
            "page_width": 1080,
            "page_height": 1440,
            "padding": {
                "top": 45,
                "bottom": 45,
                "left": 40,
                "right": 40
            },
            "font_size": 16,
            "line_height": 1.8,
            "paragraph_spacing": 20,
            "image_quality": 100,
            "format": "PNG",
            "colors": {
                "primary": theme.primary_color,
                "secondary": theme.secondary_color,
                "text": theme.text_color,
                "background": theme.background
            }
        }
    
    def apply_custom_styles(self, styles: Dict[str, str]):
        """应用自定义样式"""
        self.custom_styles.update(styles)
    
    def get_combined_css(self, theme_name: str = None, font_size: int = 18) -> str:
        """获取组合的CSS（主题 + 自定义）"""
        base_css = self.generate_css(theme_name, font_size)
        
        if self.custom_styles:
            custom_css = "\n/* 自定义样式 */\n"
            for selector, rules in self.custom_styles.items():
                custom_css += f"{selector} {{\n{rules}\n}}\n"
            return base_css + custom_css
        
        return base_css
```
 ### 2. **html_generator.py** - 更新以支持主题 代码
```python
# ============================================
# src/core/html_generator.py
# ============================================
from pathlib import Path
from typing import Optional
from src.utils.style_manager import StyleManager

class HTMLGenerator:
    def __init__(self, font_size: int = 18, page_size: str = "medium", theme: str = "xiaohongshu"):
        self.resource_path = Path(__file__).parent.parent / "resources"
        self.base_font_size = font_size  # 基础字体大小，默认18px
        
        # 页面尺寸配置
        self.page_sizes = {
            "small": {"width": 720, "height": 960},
            "medium": {"width": 1080, "height": 1440},
            "large": {"width": 1440, "height": 1920}
        }
        self.current_size = page_size
        self.page_width = self.page_sizes[page_size]["width"]
        self.page_height = self.page_sizes[page_size]["height"]
        
        # 样式管理器
        self.style_manager = StyleManager(theme)
        self.current_theme = theme
        
    def set_page_size(self, size: str):
        """设置页面尺寸"""
        if size in self.page_sizes:
            self.current_size = size
            self.page_width = self.page_sizes[size]["width"]
            self.page_height = self.page_sizes[size]["height"]
    
    def set_theme(self, theme: str):
        """设置主题"""
        self.current_theme = theme
        self.style_manager.set_theme(theme)
    
    def set_font_size(self, size: int):
        """设置基础字体大小"""
        self.base_font_size = size
        
    def generate(self, content: str, page_num: int = 0, total_pages: int = 0) -> str:
        """
        生成完整的 HTML 页面
        
        Args:
            content: HTML内容
            page_num: 当前页码（0表示不显示）
            total_pages: 总页数
        """
        # 生成主题CSS
        theme_css = self.style_manager.generate_css(self.current_theme, self.base_font_size)
        
        # 生成页面特定CSS
        page_css = self.get_page_css()
        
        # 获取JavaScript
        js = self.get_js()
        
        # 生成页码信息（如果需要）
        page_info = ""
        if page_num > 0 and total_pages > 1:
            page_info = f"""
            <div class="page-info">
                <span class="page-number">{page_num}</span>
                <span class="page-separator">/</span>
                <span class="page-total">{total_pages}</span>
            </div>
            """
        
        html = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小红书卡片 - {self.style_manager.get_theme().name}</title>
    <style>
        {theme_css}
        {page_css}
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="content" id="content">
                {content}
            </div>
            {page_info}
        </div>
    </div>
    <script>{js}</script>
</body>
</html>
"""
        return html
    
    def get_page_css(self) -> str:
        """获取页面布局CSS"""
        theme = self.style_manager.get_theme()
        
        # 检查是否为深色主题
        is_dark = self.current_theme in ["dark_mode", "midnight", "douyin"]
        
        return f"""
        /* 页面布局 */
        html, body {{
            width: {self.page_width}px;
            height: {self.page_height}px;
            overflow: hidden !important;
            margin: 0;
            padding: 0;
        }}
        
        .container {{
            width: {self.page_width}px;
            height: {self.page_height}px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
        }}
        
        .card {{
            width: 100%;
            height: 100%;
            background: {'rgba(255, 255, 255, 0.98)' if not is_dark else 'rgba(20, 20, 35, 0.98)'};
            border-radius: 20px;
            box-shadow: 0 20px 60px {self.style_manager.add_alpha(theme.primary_color, 0.15)},
                        0 10px 30px {self.style_manager.add_alpha('#000000', 0.1)};
            overflow: hidden;
            position: relative;
        }}
        
        .content {{
            padding: 50px 45px 70px 45px;
            color: var(--text-color);
            line-height: 1.85;
            height: 100%;
            overflow: hidden !important;
            position: relative;
        }}
        
        /* 页码信息 */
        .page-info {{
            position: absolute;
            bottom: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 16px;
            background: {self.style_manager.add_alpha(theme.primary_color, 0.1)};
            border-radius: 20px;
            border: 1px solid {self.style_manager.add_alpha(theme.primary_color, 0.2)};
        }}
        
        .page-number {{
            font-weight: 700;
            color: var(--primary-color);
            font-size: 14px;
        }}
        
        .page-separator {{
            color: {self.style_manager.add_alpha(theme.text_color, 0.4)};
            font-size: 12px;
        }}
        
        .page-total {{
            color: {self.style_manager.add_alpha(theme.text_color, 0.6)};
            font-size: 14px;
        }}
        
        /* 装饰元素 */
        .card::before {{
            content: "";
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, {self.style_manager.add_alpha(theme.primary_color, 0.1)} 0%, transparent 70%);
            pointer-events: none;
        }}
        
        .card::after {{
            content: "";
            position: absolute;
            bottom: -50%;
            left: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, {self.style_manager.add_alpha(theme.secondary_color, 0.1)} 0%, transparent 70%);
            pointer-events: none;
        }}
        
        /* 响应式图片 */
        img {{
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 8px 24px {self.style_manager.add_alpha('#000000', 0.1)};
        }}
        
        /* 隐藏滚动条 */
        ::-webkit-scrollbar {{
            display: none !important;
        }}
        
        * {{
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }}
        
        /* 打印样式 */
        @media print {{
            body {{
                background: white;
                padding: 0;
            }}
            
            .container {{
                max-width: 100%;
            }}
            
            .card {{
                box-shadow: none;
                border-radius: 0;
                page-break-inside: avoid;
            }}
            
            .card::before,
            .card::after {{
                display: none;
            }}
        }}
        """
    
    def get_js(self) -> str:
        """获取JavaScript代码"""
        return """
        // 页面加载完成后的处理
        document.addEventListener('DOMContentLoaded', function() {
            // 添加淡入动画
            const content = document.getElementById('content');
            if (content) {
                content.style.opacity = '0';
                content.style.transition = 'opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                setTimeout(() => {
                    content.style.opacity = '1';
                }, 100);
            }
            
            // 图片延迟加载和动画
            const images = document.querySelectorAll('img');
            images.forEach((img, index) => {
                img.loading = 'lazy';
                img.style.opacity = '0';
                img.style.transform = 'translateY(20px)';
                img.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                
                // 图片加载完成后显示
                if (img.complete) {
                    setTimeout(() => {
                        img.style.opacity = '1';
                        img.style.transform = 'translateY(0)';
                    }, 100 * (index + 1));
                } else {
                    img.addEventListener('load', () => {
                        setTimeout(() => {
                            img.style.opacity = '1';
                            img.style.transform = 'translateY(0)';
                        }, 100);
                    });
                }
            });
            
            // 代码块增强
            const codeBlocks = document.querySelectorAll('pre');
            codeBlocks.forEach(block => {
                // 添加语言标识
                const code = block.querySelector('code');
                if (code && code.className) {
                    const lang = code.className.replace('language-', '');
                    if (lang) {
                        block.setAttribute('data-language', lang.toUpperCase());
                    }
                }
            });
            
            // 表格增强
            const tables = document.querySelectorAll('table');
            tables.forEach(table => {
                // 添加响应式包装
                const wrapper = document.createElement('div');
                wrapper.style.overflowX = 'auto';
                wrapper.style.marginBottom = '20px';
                table.parentNode.insertBefore(wrapper, table);
                wrapper.appendChild(table);
            });
            
            // 确保内容不超出
            function ensureContentFit() {
                const card = document.querySelector('.card');
                const content = document.querySelector('.content');
                if (card && content) {
                    content.style.maxHeight = '100%';
                    content.style.overflow = 'hidden';
                }
            }
            
            ensureContentFit();
            window.addEventListener('resize', ensureContentFit);
        });
        
        // 禁用所有滚动
        window.addEventListener('scroll', function(e) {
            e.preventDefault();
            window.scrollTo(0, 0);
        }, { passive: false });
        
        window.addEventListener('wheel', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        window.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
        """
```
 ### 3. **main_window.py** - 添加主题选择器

由于 main_window.py 改动较大，我提供关键修改位置：

**在工具栏部分添加（约第45行后）**：

```python
# 在创建工具栏按钮后添加主题选择器
from PySide6.QtWidgets import QComboBox

# ... existing toolbar code ...

# 添加分隔器
toolbar.addSeparator()

# 主题选择器
theme_label = QLabel("主题:")
theme_label.setStyleSheet("""
    QLabel {
        color: #00e0ff;
        font-size: 14px;
        padding: 0 10px;
    }
""")
toolbar.addWidget(theme_label)

self.theme_selector = QComboBox()
self.theme_selector.setFixedWidth(150)

# 从style_manager获取主题列表
from src.utils.style_manager import StyleManager
style_manager = StyleManager()
themes = style_manager.get_theme_display_names()

for key, name in themes.items():
    self.theme_selector.addItem(name, key)

self.theme_selector.setCurrentText("小红书经典")
self.theme_selector.setStyleSheet("""
    QComboBox {
        background: qlineargradient(
            x1: 0, y1: 0, x2: 0, y2: 1,
            stop: 0 rgba(0, 224, 255, 0.15),
            stop: 1 rgba(0, 150, 255, 0.1)
        );
        border: 1px solid rgba(0, 224, 255, 0.4);
        border-radius: 8px;
        padding: 8px 12px;
        color: #00e0ff;
        font-weight: 500;
        font-size: 13px;
    }
    QComboBox:hover {
        background: qlineargradient(
            x1: 0, y1: 0, x2: 0, y2: 1,
            stop: 0 rgba(0, 224, 255, 0.25),
            stop: 1 rgba(0, 150, 255, 0.2)
        );
        border: 1px solid rgba(0, 224, 255, 0.6);
    }
    QComboBox::drop-down {
        border: none;
        width: 25px;
    }
    QComboBox::down-arrow {
        image: none;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 6px solid #00e0ff;
        margin-right: 8px;
    }
    QComboBox QAbstractItemView {
        background: rgba(25, 25, 40, 0.98);
        border: 1px solid rgba(0, 224, 255, 0.4);
        color: #00e0ff;
        selection-background-color: rgba(0, 224, 255, 0.3);
        outline: none;
        padding: 5px;
    }
    QComboBox QAbstractItemView::item {
        min-height: 30px;
        padding: 5px;
    }
    QComboBox QAbstractItemView::item:hover {
        background: rgba(0, 224, 255, 0.2);
    }
""")

toolbar.addWidget(self.theme_selector)

# 连接主题选择信号
self.theme_selector.currentIndexChanged.connect(self.on_theme_changed)
```

**在 setup_connections 方法后添加**：

```python
def on_theme_changed(self, index):
    """处理主题改变"""
    theme_key = self.theme_selector.currentData()
    if theme_key:
        # 通知预览组件更新主题
        self.preview.change_theme(theme_key)
        
        # 更新状态栏
        theme_name = self.theme_selector.currentText()
        self.status_bar.showMessage(f"已切换到主题: {theme_name}", 3000)
```

### 4. **preview_widget.py** - 添加主题切换方法

在 PreviewWidget 类中添加以下方法（约第450行后）：

```python
def change_theme(self, theme: str):
    """切换主题"""
    # 更新HTML生成器的主题
    self.html_generator.set_theme(theme)
    
    # 如果有内容，重新渲染当前页
    if self.current_pages:
        self.display_current_page()
        
    # 触发主题改变信号（如果需要）
    # self.themeChanged.emit(theme)
```

## 完整的使用流程

1. **启动应用**
   - 默认显示"小红书经典"主题
   - 中等尺寸（1080×1440）

2. **选择尺寸**
   - 在预览区顶部选择：小/中/大
   - 内容会自动重新分页

3. **选择主题**
   - 在工具栏选择12种主题之一
   - 实时预览效果

4. **导出图片**
   - 点击"导出图片"
   - 保持当前尺寸和主题导出

## 主题特色说明

### 社交媒体风格
- **小红书经典**：粉色系，温暖亲切
- **Instagram渐变**：彩虹渐变，活力十足
- **微信简约**：绿色系，清新简洁
- **抖音酷黑**：黑色背景，霓虹色彩

### 知识平台风格
- **知乎蓝**：专业可信，知识分享
- **Notion极简**：黑白极简，专注内容

### 优雅风格
- **优雅紫**：高贵典雅，艺术气息
- **海洋蓝**：清爽舒适，专业感
- **日落橙**：温暖活力，创意十足
- **森林绿**：自然清新，护眼舒适

### 深色主题
- **深色模式**：科技感，护眼
- **午夜紫**：神秘优雅，夜间阅读

## 测试建议

1. 切换不同主题，检查颜色搭配
2. 测试不同尺寸下的分页效果
3. 验证导出图片的主题是否正确
4. 检查深色主题的可读性

需要我继续第三步（优化UI交互）吗？
